diff -Naur ../orig/sed-4.9/config.h ./config.h
--- ../orig/sed-4.9/config.h	1970-01-01 03:00:00.000000000 +0300
+++ ./config.h	2022-12-01 17:11:10.025214400 +0300
@@ -0,0 +1,2576 @@
+/* config.h.  Generated from config_h.in by configure.  */
+/* config_h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* Define to the number of bits in type 'ptrdiff_t'. */
+#define BITSIZEOF_PTRDIFF_T 32
+
+/* Define to the number of bits in type 'sig_atomic_t'. */
+#define BITSIZEOF_SIG_ATOMIC_T 32
+
+/* Define to the number of bits in type 'size_t'. */
+#define BITSIZEOF_SIZE_T 32
+
+/* Define to the number of bits in type 'wchar_t'. */
+#define BITSIZEOF_WCHAR_T 16
+
+/* Define to the number of bits in type 'wint_t'. */
+#define BITSIZEOF_WINT_T 16
+
+/* Define to 1 if using 'alloca.c'. */
+/* #undef C_ALLOCA */
+
+/* the name of the file descriptor member of DIR */
+/* #undef DIR_FD_MEMBER_NAME */
+
+#ifdef DIR_FD_MEMBER_NAME
+# define DIR_TO_FD(Dir_p) ((Dir_p)->DIR_FD_MEMBER_NAME)
+#else
+# define DIR_TO_FD(Dir_p) -1
+#endif
+
+
+/* Define to 1 if // is a file system root distinct from /. */
+#define DOUBLE_SLASH_IS_DISTINCT_ROOT 1
+
+/* Define to 1 if translation of program messages to the user's native
+   language is requested. */
+/* #undef ENABLE_NLS */
+
+/* Define this to 1 if F_DUPFD behavior does not match POSIX */
+/* #undef FCNTL_DUPFD_BUGGY */
+
+/* Define to nothing if C supports flexible array members, and to 1 if it does
+   not. That way, with a declaration like 'struct s { int n; short
+   d[FLEXIBLE_ARRAY_MEMBER]; };', the struct hack can be used with pre-C99
+   compilers. Use 'FLEXSIZEOF (struct s, d, N * sizeof (short))' to calculate
+   the size in bytes of such a struct containing an N-element array. */
+#define FLEXIBLE_ARRAY_MEMBER 1
+
+/* Define to 1 if fopen() fails to recognize a trailing slash. */
+/* #undef FOPEN_TRAILING_SLASH_BUG */
+
+/* Enable compile-time and run-time bounds-checking, and some warnings,
+      without upsetting glibc 2.15+. */
+   #if !defined _FORTIFY_SOURCE && defined __OPTIMIZE__ && __OPTIMIZE__
+   # define _FORTIFY_SOURCE 2
+   #endif
+  
+
+/* Define to 1 if the system's ftello function has the Solaris bug. */
+/* #undef FTELLO_BROKEN_AFTER_SWITCHING_FROM_READ_TO_WRITE */
+
+/* Define to 1 if the system's ftello function has the macOS bug. */
+/* #undef FTELLO_BROKEN_AFTER_UNGETC */
+
+/* Define to 1 if fflush is known to work on stdin as per POSIX.1-2008, 0 if
+   fflush is known to not work, -1 if unknown. */
+#define FUNC_FFLUSH_STDIN 0
+
+/* Define to 1 if mkdir mistakenly creates a directory given with a trailing
+   dot component. */
+#define FUNC_MKDIR_DOT_BUG 1
+
+/* Define to 1 if nl_langinfo (YESEXPR) returns a non-empty string. */
+/* #undef FUNC_NL_LANGINFO_YESEXPR_WORKS */
+
+/* Define to 1 if realpath() can malloc memory, always gives an absolute path,
+   and handles a trailing slash correctly. */
+/* #undef FUNC_REALPATH_NEARLY_WORKS */
+
+/* Define to 1 if realpath() can malloc memory, always gives an absolute path,
+   and handles leading slashes and a trailing slash correctly. */
+/* #undef FUNC_REALPATH_WORKS */
+
+/* Define to 1 if ungetc is broken when used on arbitrary bytes. */
+/* #undef FUNC_UNGETC_BROKEN */
+
+/* Define this to 'void' or 'struct timezone' to match the system's
+   declaration of the second argument to gettimeofday. */
+#define GETTIMEOFDAY_TIMEZONE void
+
+/* Define to 1 if getxattr works with XATTR_NAME_POSIX_ACL_ACCESS and
+   XATTR_NAME_POSIX_ACL_DEFAULT. */
+/* #undef GETXATTR_WITH_POSIX_ACLS */
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module canonicalize-lgpl shall be considered present. */
+#define GNULIB_CANONICALIZE_LGPL 1
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module close-stream shall be considered present. */
+#define GNULIB_CLOSE_STREAM 1
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module fflush shall be considered present. */
+#define GNULIB_FFLUSH IN_SED_GNULIB_TESTS
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module fopen-gnu shall be considered present. */
+#define GNULIB_FOPEN_GNU IN_SED_GNULIB_TESTS
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module fscanf shall be considered present. */
+#define GNULIB_FSCANF 1
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module isblank shall be considered present. */
+#define GNULIB_ISBLANK IN_SED_GNULIB_TESTS
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module lock shall be considered present. */
+#define GNULIB_LOCK 1
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module mkostemp shall be considered present. */
+#define GNULIB_MKOSTEMP 1
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module msvc-nothrow shall be considered present. */
+#define GNULIB_MSVC_NOTHROW 1
+
+/* Define to 1 to disable use of VLAs */
+#define GNULIB_NO_VLA 1
+
+/* enable some gnulib portability checks */
+/* #undef GNULIB_PORTCHECK */
+
+/* Define to 1 if printf and friends should be labeled with attribute
+   "__gnu_printf__" instead of "__printf__" */
+#define GNULIB_PRINTF_ATTRIBUTE_FLAVOR_GNU 1
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module reallocarray shall be considered present. */
+#define GNULIB_REALLOCARRAY 1
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module scanf shall be considered present. */
+#define GNULIB_SCANF 1
+
+/* Define to 1 if you want the FILE stream functions getc, putc, etc. to use
+   unlocked I/O if available, throughout the package. Unlocked I/O can improve
+   performance, sometimes dramatically. But unlocked I/O is safe only in
+   single-threaded programs, as well as in multithreaded programs for which
+   you can guarantee that every FILE stream, including stdin, stdout, stderr,
+   is used only in a single thread. */
+#define GNULIB_STDIO_SINGLE_THREAD 1
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module strerror shall be considered present. */
+#define GNULIB_STRERROR 1
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module strerror_r-posix shall be considered present. */
+#define GNULIB_STRERROR_R_POSIX IN_SED_GNULIB_TESTS
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module tempname shall be considered present. */
+#define GNULIB_TEMPNAME 1
+
+/* Define to 1 when the gnulib module accept should be tested. */
+#define GNULIB_TEST_ACCEPT 1
+
+/* Define to 1 when the gnulib module bind should be tested. */
+#define GNULIB_TEST_BIND 1
+
+/* Define to 1 when the gnulib module btowc should be tested. */
+#define GNULIB_TEST_BTOWC 1
+
+/* Define to 1 when the gnulib module calloc-gnu should be tested. */
+#define GNULIB_TEST_CALLOC_GNU 1
+
+/* Define to 1 when the gnulib module calloc-posix should be tested. */
+#define GNULIB_TEST_CALLOC_POSIX 1
+
+/* Define to 1 when the gnulib module canonicalize_file_name should be tested.
+   */
+#define GNULIB_TEST_CANONICALIZE_FILE_NAME 1
+
+/* Define to 1 when the gnulib module chdir should be tested. */
+#define GNULIB_TEST_CHDIR 1
+
+/* Define to 1 when the gnulib module cloexec should be tested. */
+#define GNULIB_TEST_CLOEXEC 1
+
+/* Define to 1 when the gnulib module close should be tested. */
+#define GNULIB_TEST_CLOSE 1
+
+/* Define to 1 when the gnulib module closedir should be tested. */
+#define GNULIB_TEST_CLOSEDIR 1
+
+/* Define to 1 when the gnulib module connect should be tested. */
+#define GNULIB_TEST_CONNECT 1
+
+/* Define to 1 when the gnulib module dirfd should be tested. */
+#define GNULIB_TEST_DIRFD 1
+
+/* Define to 1 when the gnulib module dup2 should be tested. */
+#define GNULIB_TEST_DUP2 1
+
+/* Define to 1 when the gnulib module environ should be tested. */
+#define GNULIB_TEST_ENVIRON 1
+
+/* Define to 1 when the gnulib module explicit_bzero should be tested. */
+#define GNULIB_TEST_EXPLICIT_BZERO 1
+
+/* Define to 1 when the gnulib module fcntl should be tested. */
+#define GNULIB_TEST_FCNTL 1
+
+/* Define to 1 when the gnulib module fdopen should be tested. */
+#define GNULIB_TEST_FDOPEN 1
+
+/* Define to 1 when the gnulib module fflush should be tested. */
+#define GNULIB_TEST_FFLUSH 1
+
+/* Define to 1 when the gnulib module fgetc should be tested. */
+#define GNULIB_TEST_FGETC 1
+
+/* Define to 1 when the gnulib module fgets should be tested. */
+#define GNULIB_TEST_FGETS 1
+
+/* Define to 1 when the gnulib module fopen should be tested. */
+#define GNULIB_TEST_FOPEN 1
+
+/* Define to 1 when the gnulib module fopen-gnu should be tested. */
+#define GNULIB_TEST_FOPEN_GNU 1
+
+/* Define to 1 when the gnulib module fprintf should be tested. */
+#define GNULIB_TEST_FPRINTF 1
+
+/* Define to 1 when the gnulib module fpurge should be tested. */
+#define GNULIB_TEST_FPURGE 1
+
+/* Define to 1 when the gnulib module fputc should be tested. */
+#define GNULIB_TEST_FPUTC 1
+
+/* Define to 1 when the gnulib module fputs should be tested. */
+#define GNULIB_TEST_FPUTS 1
+
+/* Define to 1 when the gnulib module fread should be tested. */
+#define GNULIB_TEST_FREAD 1
+
+/* Define to 1 when the gnulib module free-posix should be tested. */
+#define GNULIB_TEST_FREE_POSIX 1
+
+/* Define to 1 when the gnulib module fscanf should be tested. */
+#define GNULIB_TEST_FSCANF 1
+
+/* Define to 1 when the gnulib module fseek should be tested. */
+#define GNULIB_TEST_FSEEK 1
+
+/* Define to 1 when the gnulib module fseeko should be tested. */
+#define GNULIB_TEST_FSEEKO 1
+
+/* Define to 1 when the gnulib module fstat should be tested. */
+#define GNULIB_TEST_FSTAT 1
+
+/* Define to 1 when the gnulib module ftell should be tested. */
+#define GNULIB_TEST_FTELL 1
+
+/* Define to 1 when the gnulib module ftello should be tested. */
+#define GNULIB_TEST_FTELLO 1
+
+/* Define to 1 when the gnulib module ftruncate should be tested. */
+#define GNULIB_TEST_FTRUNCATE 1
+
+/* Define to 1 when the gnulib module fwrite should be tested. */
+#define GNULIB_TEST_FWRITE 1
+
+/* Define to 1 when the gnulib module getc should be tested. */
+#define GNULIB_TEST_GETC 1
+
+/* Define to 1 when the gnulib module getchar should be tested. */
+#define GNULIB_TEST_GETCHAR 1
+
+/* Define to 1 when the gnulib module getcwd should be tested. */
+#define GNULIB_TEST_GETCWD 1
+
+/* Define to 1 when the gnulib module getdelim should be tested. */
+#define GNULIB_TEST_GETDELIM 1
+
+/* Define to 1 when the gnulib module getdtablesize should be tested. */
+#define GNULIB_TEST_GETDTABLESIZE 1
+
+/* Define to 1 when the gnulib module getpagesize should be tested. */
+#define GNULIB_TEST_GETPAGESIZE 1
+
+/* Define to 1 when the gnulib module getrandom should be tested. */
+#define GNULIB_TEST_GETRANDOM 1
+
+/* Define to 1 when the gnulib module gettimeofday should be tested. */
+#define GNULIB_TEST_GETTIMEOFDAY 1
+
+/* Define to 1 when the gnulib module ioctl should be tested. */
+#define GNULIB_TEST_IOCTL 1
+
+/* Define to 1 when the gnulib module link should be tested. */
+#define GNULIB_TEST_LINK 1
+
+/* Define to 1 when the gnulib module listen should be tested. */
+#define GNULIB_TEST_LISTEN 1
+
+/* Define to 1 when the gnulib module localeconv should be tested. */
+#define GNULIB_TEST_LOCALECONV 1
+
+/* Define to 1 when the gnulib module localename should be tested. */
+#define GNULIB_TEST_LOCALENAME 1
+
+/* Define to 1 when the gnulib module lseek should be tested. */
+#define GNULIB_TEST_LSEEK 1
+
+/* Define to 1 when the gnulib module lstat should be tested. */
+#define GNULIB_TEST_LSTAT 1
+
+/* Define to 1 when the gnulib module malloc-gnu should be tested. */
+#define GNULIB_TEST_MALLOC_GNU 1
+
+/* Define to 1 when the gnulib module malloc-posix should be tested. */
+#define GNULIB_TEST_MALLOC_POSIX 1
+
+/* Define to 1 when the gnulib module mbrlen should be tested. */
+#define GNULIB_TEST_MBRLEN 1
+
+/* Define to 1 when the gnulib module mbrtowc should be tested. */
+#define GNULIB_TEST_MBRTOWC 1
+
+/* Define to 1 when the gnulib module mbsinit should be tested. */
+#define GNULIB_TEST_MBSINIT 1
+
+/* Define to 1 when the gnulib module mbtowc should be tested. */
+#define GNULIB_TEST_MBTOWC 1
+
+/* Define to 1 when the gnulib module memchr should be tested. */
+#define GNULIB_TEST_MEMCHR 1
+
+/* Define to 1 when the gnulib module mempcpy should be tested. */
+#define GNULIB_TEST_MEMPCPY 1
+
+/* Define to 1 when the gnulib module memrchr should be tested. */
+#define GNULIB_TEST_MEMRCHR 1
+
+/* Define to 1 when the gnulib module mkdir should be tested. */
+#define GNULIB_TEST_MKDIR 1
+
+/* Define to 1 when the gnulib module mkostemp should be tested. */
+#define GNULIB_TEST_MKOSTEMP 1
+
+/* Define to 1 when the gnulib module nanosleep should be tested. */
+#define GNULIB_TEST_NANOSLEEP 1
+
+/* Define to 1 when the gnulib module nl_langinfo should be tested. */
+#define GNULIB_TEST_NL_LANGINFO 1
+
+/* Define to 1 when the gnulib module open should be tested. */
+#define GNULIB_TEST_OPEN 1
+
+/* Define to 1 when the gnulib module opendir should be tested. */
+#define GNULIB_TEST_OPENDIR 1
+
+/* Define to 1 when the gnulib module perror should be tested. */
+#define GNULIB_TEST_PERROR 1
+
+/* Define to 1 when the gnulib module pipe should be tested. */
+#define GNULIB_TEST_PIPE 1
+
+/* Define to 1 when the gnulib module printf should be tested. */
+#define GNULIB_TEST_PRINTF 1
+
+/* Define to 1 when the gnulib module pselect should be tested. */
+#define GNULIB_TEST_PSELECT 1
+
+/* Define to 1 when the gnulib module pthread_sigmask should be tested. */
+#define GNULIB_TEST_PTHREAD_SIGMASK 1
+
+/* Define to 1 when the gnulib module pthread-thread should be tested. */
+#define GNULIB_TEST_PTHREAD_THREAD 1
+
+/* Define to 1 when the gnulib module putc should be tested. */
+#define GNULIB_TEST_PUTC 1
+
+/* Define to 1 when the gnulib module putchar should be tested. */
+#define GNULIB_TEST_PUTCHAR 1
+
+/* Define to 1 when the gnulib module putenv should be tested. */
+#define GNULIB_TEST_PUTENV 1
+
+/* Define to 1 when the gnulib module puts should be tested. */
+#define GNULIB_TEST_PUTS 1
+
+/* Define to 1 when the gnulib module raise should be tested. */
+#define GNULIB_TEST_RAISE 1
+
+/* Define to 1 when the gnulib module rawmemchr should be tested. */
+#define GNULIB_TEST_RAWMEMCHR 1
+
+/* Define to 1 when the gnulib module readdir should be tested. */
+#define GNULIB_TEST_READDIR 1
+
+/* Define to 1 when the gnulib module readlink should be tested. */
+#define GNULIB_TEST_READLINK 1
+
+/* Define to 1 when the gnulib module reallocarray should be tested. */
+#define GNULIB_TEST_REALLOCARRAY 1
+
+/* Define to 1 when the gnulib module realloc-gnu should be tested. */
+#define GNULIB_TEST_REALLOC_GNU 1
+
+/* Define to 1 when the gnulib module realloc-posix should be tested. */
+#define GNULIB_TEST_REALLOC_POSIX 1
+
+/* Define to 1 when the gnulib module realpath should be tested. */
+#define GNULIB_TEST_REALPATH 1
+
+/* Define to 1 when the gnulib module rename should be tested. */
+#define GNULIB_TEST_RENAME 1
+
+/* Define to 1 when the gnulib module rmdir should be tested. */
+#define GNULIB_TEST_RMDIR 1
+
+/* Define to 1 when the gnulib module scanf should be tested. */
+#define GNULIB_TEST_SCANF 1
+
+/* Define to 1 when the gnulib module select should be tested. */
+#define GNULIB_TEST_SELECT 1
+
+/* Define to 1 when the gnulib module setenv should be tested. */
+#define GNULIB_TEST_SETENV 1
+
+/* Define to 1 when the gnulib module setlocale should be tested. */
+#define GNULIB_TEST_SETLOCALE 1
+
+/* Define to 1 when the gnulib module setlocale_null should be tested. */
+#define GNULIB_TEST_SETLOCALE_NULL 1
+
+/* Define to 1 when the gnulib module setsockopt should be tested. */
+#define GNULIB_TEST_SETSOCKOPT 1
+
+/* Define to 1 when the gnulib module sigprocmask should be tested. */
+#define GNULIB_TEST_SIGPROCMASK 1
+
+/* Define to 1 when the gnulib module sleep should be tested. */
+#define GNULIB_TEST_SLEEP 1
+
+/* Define to 1 when the gnulib module socket should be tested. */
+#define GNULIB_TEST_SOCKET 1
+
+/* Define to 1 when the gnulib module stat should be tested. */
+#define GNULIB_TEST_STAT 1
+
+/* Define to 1 when the gnulib module strdup should be tested. */
+#define GNULIB_TEST_STRDUP 1
+
+/* Define to 1 when the gnulib module strerror should be tested. */
+#define GNULIB_TEST_STRERROR 1
+
+/* Define to 1 when the gnulib module strerror_r should be tested. */
+#define GNULIB_TEST_STRERROR_R 1
+
+/* Define to 1 when the gnulib module strverscmp should be tested. */
+#define GNULIB_TEST_STRVERSCMP 1
+
+/* Define to 1 when the gnulib module symlink should be tested. */
+#define GNULIB_TEST_SYMLINK 1
+
+/* Define to 1 when the gnulib module unsetenv should be tested. */
+#define GNULIB_TEST_UNSETENV 1
+
+/* Define to 1 when the gnulib module vfprintf should be tested. */
+#define GNULIB_TEST_VFPRINTF 1
+
+/* Define to 1 when the gnulib module vprintf should be tested. */
+#define GNULIB_TEST_VPRINTF 1
+
+/* Define to 1 when the gnulib module wcrtomb should be tested. */
+#define GNULIB_TEST_WCRTOMB 1
+
+/* Define to 1 when the gnulib module wctob should be tested. */
+#define GNULIB_TEST_WCTOB 1
+
+/* Define to 1 when the gnulib module wctomb should be tested. */
+#define GNULIB_TEST_WCTOMB 1
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module xalloc shall be considered present. */
+#define GNULIB_XALLOC 1
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module xalloc-die shall be considered present. */
+#define GNULIB_XALLOC_DIE 1
+
+/* Define to 1 if you have the 'aclsort' function. */
+/* #undef HAVE_ACLSORT */
+
+/* Define to 1 if you have the <aclv.h> header file. */
+/* #undef HAVE_ACLV_H */
+
+/* Define to 1 if you have the 'aclx_get' function. */
+/* #undef HAVE_ACLX_GET */
+
+/* Define to 1 if you have the 'acl_copy_ext_native' function. */
+/* #undef HAVE_ACL_COPY_EXT_NATIVE */
+
+/* Define to 1 if you have the 'acl_create_entry_np' function. */
+/* #undef HAVE_ACL_CREATE_ENTRY_NP */
+
+/* Define to 1 if you have the 'acl_delete_def_file' function. */
+/* #undef HAVE_ACL_DELETE_DEF_FILE */
+
+/* Define to 1 if you have the 'acl_delete_fd_np' function. */
+/* #undef HAVE_ACL_DELETE_FD_NP */
+
+/* Define to 1 if you have the 'acl_delete_file_np' function. */
+/* #undef HAVE_ACL_DELETE_FILE_NP */
+
+/* Define to 1 if you have the 'acl_entries' function. */
+/* #undef HAVE_ACL_ENTRIES */
+
+/* Define to 1 if you have the 'acl_extended_file' function. */
+/* #undef HAVE_ACL_EXTENDED_FILE */
+
+/* Define to 1 if the constant ACL_FIRST_ENTRY exists. */
+/* #undef HAVE_ACL_FIRST_ENTRY */
+
+/* Define to 1 if you have the 'acl_free' function. */
+/* #undef HAVE_ACL_FREE */
+
+/* Define to 1 if you have the 'acl_free_text' function. */
+/* #undef HAVE_ACL_FREE_TEXT */
+
+/* Define to 1 if you have the 'acl_from_mode' function. */
+/* #undef HAVE_ACL_FROM_MODE */
+
+/* Define to 1 if you have the 'acl_from_text' function. */
+/* #undef HAVE_ACL_FROM_TEXT */
+
+/* Define to 1 if you have the 'acl_get_fd' function. */
+/* #undef HAVE_ACL_GET_FD */
+
+/* Define to 1 if you have the 'acl_get_file' function. */
+/* #undef HAVE_ACL_GET_FILE */
+
+/* Define to 1 if you have the <acl/libacl.h> header file. */
+/* #undef HAVE_ACL_LIBACL_H */
+
+/* Define to 1 if you have the 'acl_set_fd' function. */
+/* #undef HAVE_ACL_SET_FD */
+
+/* Define to 1 if you have the 'acl_set_file' function. */
+/* #undef HAVE_ACL_SET_FILE */
+
+/* Define to 1 if you have the 'acl_to_short_text' function. */
+/* #undef HAVE_ACL_TO_SHORT_TEXT */
+
+/* Define to 1 if you have the 'acl_trivial' function. */
+/* #undef HAVE_ACL_TRIVIAL */
+
+/* Define to 1 if the ACL type ACL_TYPE_EXTENDED exists. */
+/* #undef HAVE_ACL_TYPE_EXTENDED */
+
+/* Define to 1 if you have 'alloca' after including <alloca.h>, a header that
+   may be supplied by this distribution. */
+#define HAVE_ALLOCA 1
+
+/* Define to 1 if <alloca.h> works. */
+/* #undef HAVE_ALLOCA_H */
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+/* #undef HAVE_ARPA_INET_H */
+
+/* Define to 1 if you have the <bcrypt.h> header file. */
+/* #undef HAVE_BCRYPT_H */
+
+/* Define to 1 if you have the <bp-sym.h> header file. */
+/* #undef HAVE_BP_SYM_H */
+
+/* Define to 1 if you have the 'btowc' function. */
+#define HAVE_BTOWC 1
+
+/* Define to 1 if nanosleep mishandles large arguments. */
+/* #undef HAVE_BUG_BIG_NANOSLEEP */
+
+/* Define to 1 if you have the 'canonicalize_file_name' function. */
+/* #undef HAVE_CANONICALIZE_FILE_NAME */
+
+/* Define to 1 if you have the 'catgets' function. */
+/* #undef HAVE_CATGETS */
+
+/* Define to 1 if you have the Mac OS X function
+   CFLocaleCopyPreferredLanguages in the CoreFoundation framework. */
+/* #undef HAVE_CFLOCALECOPYPREFERREDLANGUAGES */
+
+/* Define to 1 if you have the Mac OS X function CFPreferencesCopyAppValue in
+   the CoreFoundation framework. */
+/* #undef HAVE_CFPREFERENCESCOPYAPPVALUE */
+
+/* Define to 1 if you have the 'clock_getres' function. */
+/* #undef HAVE_CLOCK_GETRES */
+
+/* Define to 1 if you have the 'clock_gettime' function. */
+/* #undef HAVE_CLOCK_GETTIME */
+
+/* Define to 1 if you have the 'clock_settime' function. */
+/* #undef HAVE_CLOCK_SETTIME */
+
+/* Define to 1 if you have the 'closedir' function. */
+/* #undef HAVE_CLOSEDIR */
+
+/* Define to 1 if you have the <crtdefs.h> header file. */
+#define HAVE_CRTDEFS_H 1
+
+/* Define to 1 if the alignas and alignof keywords work. */
+/* #undef HAVE_C_ALIGNASOF */
+
+/* Define to 1 if bool, true and false work as per C2023. */
+#define HAVE_C_BOOL 1
+
+/* Define to 1 if the static_assert keyword works. */
+/* #undef HAVE_C_STATIC_ASSERT */
+
+/* Define to 1 if C supports variable-length arrays. */
+/* #undef HAVE_C_VARARRAYS */
+
+/* Define if the GNU dcgettext() function is already present or preinstalled.
+   */
+/* #undef HAVE_DCGETTEXT */
+
+/* Define to 1 if you have the declaration of 'alarm', and to 0 if you don't.
+   */
+#define HAVE_DECL_ALARM 0
+
+/* Define to 1 if you have the declaration of 'clearerr_unlocked', and to 0 if
+   you don't. */
+#define HAVE_DECL_CLEARERR_UNLOCKED 0
+
+/* Define to 1 if you have the declaration of 'dirfd', and to 0 if you don't.
+   */
+#define HAVE_DECL_DIRFD 0
+
+/* Define to 1 if you have the declaration of 'ecvt', and to 0 if you don't.
+   */
+#define HAVE_DECL_ECVT 1
+
+/* Define to 1 if you have the declaration of 'execvpe', and to 0 if you
+   don't. */
+#define HAVE_DECL_EXECVPE 0
+
+/* Define to 1 if you have the declaration of 'fcloseall', and to 0 if you
+   don't. */
+#define HAVE_DECL_FCLOSEALL 1
+
+/* Define to 1 if you have the declaration of 'fcvt', and to 0 if you don't.
+   */
+#define HAVE_DECL_FCVT 1
+
+/* Define to 1 if you have the declaration of 'feof_unlocked', and to 0 if you
+   don't. */
+#define HAVE_DECL_FEOF_UNLOCKED 0
+
+/* Define to 1 if you have the declaration of 'ferror_unlocked', and to 0 if
+   you don't. */
+#define HAVE_DECL_FERROR_UNLOCKED 0
+
+/* Define to 1 if you have the declaration of 'fflush_unlocked', and to 0 if
+   you don't. */
+#define HAVE_DECL_FFLUSH_UNLOCKED 0
+
+/* Define to 1 if you have the declaration of 'fgets_unlocked', and to 0 if
+   you don't. */
+#define HAVE_DECL_FGETS_UNLOCKED 0
+
+/* Define to 1 if you have the declaration of 'fpurge', and to 0 if you don't.
+   */
+#define HAVE_DECL_FPURGE 0
+
+/* Define to 1 if you have the declaration of 'fputc_unlocked', and to 0 if
+   you don't. */
+#define HAVE_DECL_FPUTC_UNLOCKED 0
+
+/* Define to 1 if you have the declaration of 'fputs_unlocked', and to 0 if
+   you don't. */
+#define HAVE_DECL_FPUTS_UNLOCKED 0
+
+/* Define to 1 if you have the declaration of 'fread_unlocked', and to 0 if
+   you don't. */
+#define HAVE_DECL_FREAD_UNLOCKED 0
+
+/* Define to 1 if you have the declaration of 'fseeko', and to 0 if you don't.
+   */
+#define HAVE_DECL_FSEEKO 0
+
+/* Define to 1 if you have the declaration of 'ftello', and to 0 if you don't.
+   */
+#define HAVE_DECL_FTELLO 0
+
+/* Define to 1 if you have the declaration of 'fwrite_unlocked', and to 0 if
+   you don't. */
+#define HAVE_DECL_FWRITE_UNLOCKED 0
+
+/* Define to 1 if you have the declaration of 'gcvt', and to 0 if you don't.
+   */
+#define HAVE_DECL_GCVT 1
+
+/* Define to 1 if you have the declaration of 'getchar_unlocked', and to 0 if
+   you don't. */
+#define HAVE_DECL_GETCHAR_UNLOCKED 0
+
+/* Define to 1 if you have the declaration of 'getc_unlocked', and to 0 if you
+   don't. */
+#define HAVE_DECL_GETC_UNLOCKED 0
+
+/* Define to 1 if you have the declaration of 'getdelim', and to 0 if you
+   don't. */
+#define HAVE_DECL_GETDELIM 0
+
+/* Define to 1 if you have the declaration of 'getdtablesize', and to 0 if you
+   don't. */
+#define HAVE_DECL_GETDTABLESIZE 0
+
+/* Define to 1 if you have the declaration of 'inet_pton', and to 0 if you
+   don't. */
+#define HAVE_DECL_INET_PTON 0
+
+/* Define to 1 if you have the declaration of 'isblank', and to 0 if you
+   don't. */
+#define HAVE_DECL_ISBLANK 0
+
+/* Define to 1 if you have the declaration of 'mbrlen', and to 0 if you don't.
+   */
+/* #undef HAVE_DECL_MBRLEN */
+
+/* Define to 1 if you have the declaration of 'mbrtowc', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_MBRTOWC */
+
+/* Define to 1 if you have the declaration of 'mbsinit', and to 0 if you
+   don't. */
+#define HAVE_DECL_MBSINIT 1
+
+/* Define to 1 if you have the declaration of 'memrchr', and to 0 if you
+   don't. */
+#define HAVE_DECL_MEMRCHR 0
+
+/* Define to 1 if you have the declaration of 'program_invocation_name', and
+   to 0 if you don't. */
+#define HAVE_DECL_PROGRAM_INVOCATION_NAME 0
+
+/* Define to 1 if you have the declaration of 'program_invocation_short_name',
+   and to 0 if you don't. */
+#define HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME 0
+
+/* Define to 1 if you have the declaration of 'putchar_unlocked', and to 0 if
+   you don't. */
+#define HAVE_DECL_PUTCHAR_UNLOCKED 0
+
+/* Define to 1 if you have the declaration of 'putc_unlocked', and to 0 if you
+   don't. */
+#define HAVE_DECL_PUTC_UNLOCKED 0
+
+/* Define to 1 if you have the declaration of 'setenv', and to 0 if you don't.
+   */
+#define HAVE_DECL_SETENV 0
+
+/* Define to 1 if you have the declaration of 'sleep', and to 0 if you don't.
+   */
+#define HAVE_DECL_SLEEP 0
+
+/* Define to 1 if you have the declaration of 'strdup', and to 0 if you don't.
+   */
+#define HAVE_DECL_STRDUP 1
+
+/* Define to 1 if you have the declaration of 'strerror_r', and to 0 if you
+   don't. */
+#define HAVE_DECL_STRERROR_R 0
+
+/* Define to 1 if you have the declaration of 'towlower', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_TOWLOWER */
+
+/* Define to 1 if you have the declaration of 'unsetenv', and to 0 if you
+   don't. */
+#define HAVE_DECL_UNSETENV 0
+
+/* Define to 1 if you have the declaration of 'wcrtomb', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_WCRTOMB */
+
+/* Define to 1 if you have the declaration of 'wcsdup', and to 0 if you don't.
+   */
+#define HAVE_DECL_WCSDUP 1
+
+/* Define to 1 if you have the declaration of 'wctob', and to 0 if you don't.
+   */
+/* #undef HAVE_DECL_WCTOB */
+
+/* Define to 1 if you have the declaration of '_fseeki64', and to 0 if you
+   don't. */
+#define HAVE_DECL__FSEEKI64 1
+
+/* Define to 1 if you have the declaration of '_putenv', and to 0 if you
+   don't. */
+#define HAVE_DECL__PUTENV 1
+
+/* Define to 1 if you have the declaration of '__argv', and to 0 if you don't.
+   */
+#define HAVE_DECL___ARGV 1
+
+/* Define to 1 if you have the declaration of '__fpending', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL___FPENDING */
+
+/* Define to 1 if you have the <dirent.h> header file. */
+/* #undef HAVE_DIRENT_H */
+
+/* Define to 1 if you have the 'dirfd' function. */
+/* #undef HAVE_DIRFD */
+
+/* Define to 1 if you have the 'duplocale' function. */
+/* #undef HAVE_DUPLOCALE */
+
+/* Define if you have the declaration of environ. */
+#define HAVE_ENVIRON_DECL 1
+
+/* Define to 1 if you have the <errno.h> header file. */
+#define HAVE_ERRNO_H 1
+
+/* Define to 1 if you have the 'explicit_bzero' function. */
+/* #undef HAVE_EXPLICIT_BZERO */
+
+/* Define to 1 if you have the 'explicit_memset' function. */
+/* #undef HAVE_EXPLICIT_MEMSET */
+
+/* Define to 1 if you have the 'faccessat' function. */
+/* #undef HAVE_FACCESSAT */
+
+/* Define to 1 if you have the 'facl' function. */
+/* #undef HAVE_FACL */
+
+/* Define if the locale_t type contains insufficient information, as on
+   OpenBSD. */
+/* #undef HAVE_FAKE_LOCALES */
+
+/* Define to 1 if you have the 'fchmod' function. */
+/* #undef HAVE_FCHMOD */
+
+/* Define to 1 if you have the 'fchown' function. */
+/* #undef HAVE_FCHOWN */
+
+/* Define to 1 if you have the 'fcntl' function. */
+/* #undef HAVE_FCNTL */
+
+/* Define to 1 if you have the <features.h> header file. */
+/* #undef HAVE_FEATURES_H */
+
+/* Define to 1 if you have the 'flockfile' function. */
+/* #undef HAVE_FLOCKFILE */
+
+/* Defined if "rt" can be used as a mode to fopen. */
+#define HAVE_FOPEN_RT 1
+
+/* Define to 1 if you have the 'fpurge' function. */
+/* #undef HAVE_FPURGE */
+
+/* Define to 1 if you have the 'freelocale' function. */
+/* #undef HAVE_FREELOCALE */
+
+/* Define if the 'free' function is guaranteed to preserve errno. */
+/* #undef HAVE_FREE_POSIX */
+
+/* Define to 1 if you have the 'ftruncate' function. */
+/* #undef HAVE_FTRUNCATE */
+
+/* Define to 1 if you have the 'funlockfile' function. */
+/* #undef HAVE_FUNLOCKFILE */
+
+/* Define to 1 if you have the 'getacl' function. */
+/* #undef HAVE_GETACL */
+
+/* Define to 1 if you have the 'getcwd' function. */
+#define HAVE_GETCWD 1
+
+/* Define to 1 if you have the 'getdelim' function. */
+/* #undef HAVE_GETDELIM */
+
+/* Define to 1 if you have the 'getdtablesize' function. */
+/* #undef HAVE_GETDTABLESIZE */
+
+/* Define to 1 if you have the 'getexecname' function. */
+/* #undef HAVE_GETEXECNAME */
+
+/* Define to 1 if you have the 'getlocalename_l' function. */
+/* #undef HAVE_GETLOCALENAME_L */
+
+/* Define to 1 if you have the 'getprogname' function. */
+/* #undef HAVE_GETPROGNAME */
+
+/* Define to 1 if you have the 'getrandom' function. */
+/* #undef HAVE_GETRANDOM */
+
+/* Define if the GNU gettext() function is already present or preinstalled. */
+/* #undef HAVE_GETTEXT */
+
+/* Define to 1 if you have the 'gettimeofday' function. */
+/* #undef HAVE_GETTIMEOFDAY */
+
+/* Define if the uselocale exists, may be safely called, and returns
+   sufficient information. */
+/* #undef HAVE_GOOD_USELOCALE */
+
+/* Define if you have the iconv() function and it works. */
+/* #undef HAVE_ICONV */
+
+/* Define to 1 if you have the 'inet_pton' function. */
+/* #undef HAVE_INET_PTON */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+/* #undef HAVE_INTTYPES_H */
+
+/* Define to 1 if you have the 'ioctl' function. */
+/* #undef HAVE_IOCTL */
+
+/* Define to 1 if <sys/socket.h> defines AF_INET. */
+#define HAVE_IPV4 1
+
+/* Define to 1 if <sys/socket.h> defines AF_INET6. */
+#define HAVE_IPV6 1
+
+/* Define to 1 if you have the 'isascii' function. */
+/* #undef HAVE_ISASCII */
+
+/* Define to 1 if you have the 'isatty' function. */
+#define HAVE_ISATTY 1
+
+/* Define to 1 if you have the 'isblank' function. */
+/* #undef HAVE_ISBLANK */
+
+/* Define to 1 if you have the 'iswcntrl' function. */
+#define HAVE_ISWCNTRL 1
+
+/* Define to 1 if you have the 'iswctype' function. */
+#define HAVE_ISWCTYPE 1
+
+/* Define if you have <langinfo.h> and nl_langinfo(CODESET). */
+/* #undef HAVE_LANGINFO_CODESET */
+
+/* Define to 1 if you have the <langinfo.h> header file. */
+/* #undef HAVE_LANGINFO_H */
+
+/* Define if your <locale.h> file defines LC_MESSAGES. */
+/* #undef HAVE_LC_MESSAGES */
+
+/* Define to 1 if you have the <libintl.h> header file. */
+/* #undef HAVE_LIBINTL_H */
+
+/* Define to 1 if the bcrypt library is guaranteed to be present. */
+/* #undef HAVE_LIB_BCRYPT */
+
+/* Define to 1 if you have the <limits.h> header file. */
+#define HAVE_LIMITS_H 1
+
+/* Define to 1 if you have the 'link' function. */
+/* #undef HAVE_LINK */
+
+/* Define to 1 if you have the <locale.h> header file. */
+#define HAVE_LOCALE_H 1
+
+/* Define to 1 if the system has the type 'long long int'. */
+#define HAVE_LONG_LONG_INT 1
+
+/* Define to 1 if you have the 'lstat' function. */
+/* #undef HAVE_LSTAT */
+
+/* Define to 1 if you have the <malloc.h> header file. */
+#define HAVE_MALLOC_H 1
+
+/* Define if malloc, realloc, and calloc set errno on allocation failure. */
+#define HAVE_MALLOC_POSIX 1
+
+/* Define to 1 if mmap()'s MAP_ANONYMOUS flag is available after including
+   config.h and <sys/mman.h>. */
+/* #undef HAVE_MAP_ANONYMOUS */
+
+/* Define to 1 if you have the 'mbrlen' function. */
+#define HAVE_MBRLEN 1
+
+/* Define to 1 if you have the 'mbrtowc' function. */
+#define HAVE_MBRTOWC 1
+
+/* Define to 1 if you have the 'mbsinit' function. */
+/* #undef HAVE_MBSINIT */
+
+/* Define to 1 if <wchar.h> declares mbstate_t. */
+#define HAVE_MBSTATE_T 1
+
+/* Define to 1 if you have the 'mbtowc' function. */
+#define HAVE_MBTOWC 1
+
+/* Define to 1 if you have the <mcheck.h> header file. */
+/* #undef HAVE_MCHECK_H */
+
+/* Define to 1 if you have the 'memcpy' function. */
+#define HAVE_MEMCPY 1
+
+/* Define to 1 if you have the 'mempcpy' function. */
+/* #undef HAVE_MEMPCPY */
+
+/* Define to 1 if you have the 'memrchr' function. */
+/* #undef HAVE_MEMRCHR */
+
+/* Define to 1 if you have the 'memset_s' function. */
+/* #undef HAVE_MEMSET_S */
+
+/* Define to 1 if you have the <minix/config.h> header file. */
+/* #undef HAVE_MINIX_CONFIG_H */
+
+/* Define to 1 if <limits.h> defines the MIN and MAX macros. */
+/* #undef HAVE_MINMAX_IN_LIMITS_H */
+
+/* Define to 1 if <sys/param.h> defines the MIN and MAX macros. */
+/* #undef HAVE_MINMAX_IN_SYS_PARAM_H */
+
+/* Define to 1 if you have the 'mkostemp' function. */
+/* #undef HAVE_MKOSTEMP */
+
+/* Define to 1 if you have the 'mprotect' function. */
+/* #undef HAVE_MPROTECT */
+
+/* Define to 1 if you have the 'mquery' function. */
+/* #undef HAVE_MQUERY */
+
+/* Define to 1 on MSVC platforms that have the "invalid parameter handler"
+   concept. */
+#define HAVE_MSVC_INVALID_PARAMETER_HANDLER 1
+
+/* Define if the locale_t type does not contain the name of each locale
+   category. */
+/* #undef HAVE_NAMELESS_LOCALES */
+
+/* Define to 1 if you have the <netdb.h> header file. */
+/* #undef HAVE_NETDB_H */
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+/* #undef HAVE_NETINET_IN_H */
+
+/* Define to 1 if you have the 'newlocale' function. */
+/* #undef HAVE_NEWLOCALE */
+
+/* Define to 1 if you have the 'nl_langinfo' function. */
+/* #undef HAVE_NL_LANGINFO */
+
+/* Define to 1 if the system has obstacks that work with any size object. */
+/* #undef HAVE_OBSTACK */
+
+/* Define to 1 if you have the 'opendir' function. */
+/* #undef HAVE_OPENDIR */
+
+/* Define to 1 if you have the <OS.h> header file. */
+/* #undef HAVE_OS_H */
+
+/* Define to 1 if you have the 'pathconf' function. */
+/* #undef HAVE_PATHCONF */
+
+/* Define to 1 if you have the 'pipe' function. */
+/* #undef HAVE_PIPE */
+
+/* Define to 1 if you have the 'popen' function. */
+/* #undef HAVE_POPEN */
+
+/* Define to 1 if you have the 'pselect' function. */
+/* #undef HAVE_PSELECT */
+
+/* Define to 1 if you have the 'pstat_getprocvm' function. */
+/* #undef HAVE_PSTAT_GETPROCVM */
+
+/* Define if you have the <pthread.h> header and the POSIX threads API. */
+/* #undef HAVE_PTHREAD_API */
+
+/* Define to 1 if you have the 'pthread_atfork' function. */
+/* #undef HAVE_PTHREAD_ATFORK */
+
+/* Define to 1 if you have the <pthread.h> header file. */
+/* #undef HAVE_PTHREAD_H */
+
+/* Define if the <pthread.h> defines PTHREAD_MUTEX_RECURSIVE. */
+/* #undef HAVE_PTHREAD_MUTEX_RECURSIVE */
+
+/* Define if the POSIX multithreading library has read/write locks. */
+/* #undef HAVE_PTHREAD_RWLOCK */
+
+/* Define if the 'pthread_rwlock_rdlock' function prefers a writer to a
+   reader. */
+/* #undef HAVE_PTHREAD_RWLOCK_RDLOCK_PREFER_WRITER */
+
+/* Define to 1 if the pthread_sigmask function can be used (despite bugs). */
+/* #undef HAVE_PTHREAD_SIGMASK */
+
+/* Define to 1 if the system has the type 'pthread_spinlock_t'. */
+/* #undef HAVE_PTHREAD_SPINLOCK_T */
+
+/* Define to 1 if the system has the type 'pthread_t'. */
+/* #undef HAVE_PTHREAD_T */
+
+/* Define to 1 if you have the 'raise' function. */
+#define HAVE_RAISE 1
+
+/* Define to 1 if you have the 'rawmemchr' function. */
+/* #undef HAVE_RAWMEMCHR */
+
+/* Define to 1 if you have the 'readdir' function. */
+/* #undef HAVE_READDIR */
+
+/* Define to 1 if you have the 'readlink' function. */
+/* #undef HAVE_READLINK */
+
+/* Define to 1 if you have the 'reallocarray' function. */
+/* #undef HAVE_REALLOCARRAY */
+
+/* Define to 1 if you have the 'realpath' function. */
+/* #undef HAVE_REALPATH */
+
+/* Define to 1 if the system has the type 'sa_family_t'. */
+/* #undef HAVE_SA_FAMILY_T */
+
+/* Define to 1 if you have the <sched.h> header file. */
+/* #undef HAVE_SCHED_H */
+
+/* Define to 1 if you have the <sdkddkver.h> header file. */
+/* #undef HAVE_SDKDDKVER_H */
+
+/* Define to 1 if you have the <search.h> header file. */
+#define HAVE_SEARCH_H 1
+
+/* Define to 1 if you have the <selinux/context.h> header file. */
+/* #undef HAVE_SELINUX_CONTEXT_H */
+
+/* Define to 1 if you have the <selinux/label.h> header file. */
+/* #undef HAVE_SELINUX_LABEL_H */
+
+/* Define to 1 if you have the <selinux/selinux.h> header file. */
+#define HAVE_SELINUX_SELINUX_H 0
+
+/* Define to 1 if you have the 'setdtablesize' function. */
+/* #undef HAVE_SETDTABLESIZE */
+
+/* Define to 1 if you have the 'setenv' function. */
+/* #undef HAVE_SETENV */
+
+/* Define to 1 if you have the 'setlocale' function. */
+#define HAVE_SETLOCALE 1
+
+/* Define to 1 if you have the 'shutdown' function. */
+/* #undef HAVE_SHUTDOWN */
+
+/* Define to 1 if 'sig_atomic_t' is a signed integer type. */
+#define HAVE_SIGNED_SIG_ATOMIC_T 1
+
+/* Define to 1 if 'wchar_t' is a signed integer type. */
+/* #undef HAVE_SIGNED_WCHAR_T */
+
+/* Define to 1 if 'wint_t' is a signed integer type. */
+/* #undef HAVE_SIGNED_WINT_T */
+
+/* Define to 1 if the system has the type 'sigset_t'. */
+/* #undef HAVE_SIGSET_T */
+
+/* Define to 1 if you have the 'sleep' function. */
+/* #undef HAVE_SLEEP */
+
+/* Define to 1 if you have the 'snprintf' function. */
+/* #undef HAVE_SNPRINTF */
+
+/* Define if the locale_t type is as on Solaris 11.4. */
+/* #undef HAVE_SOLARIS114_LOCALES */
+
+/* Define to 1 if you have the 'statacl' function. */
+/* #undef HAVE_STATACL */
+
+/* Define to 1 if you have the <stdalign.h> header file. */
+/* #undef HAVE_STDALIGN_H */
+
+/* Define to 1 if you have the <stdbool.h> header file. */
+/* #undef HAVE_STDBOOL_H */
+
+/* Define to 1 if you have the <stdckdint.h> header file. */
+/* #undef HAVE_STDCKDINT_H */
+
+/* Define to 1 if you have the <stdint.h> header file. */
+/* #undef HAVE_STDINT_H */
+
+/* Define to 1 if you have the <stdio_ext.h> header file. */
+/* #undef HAVE_STDIO_EXT_H */
+
+/* Define to 1 if you have the <stdio.h> header file. */
+#define HAVE_STDIO_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the 'strchr' function. */
+#define HAVE_STRCHR 1
+
+/* Define to 1 if you have the 'strerror_r' function. */
+/* #undef HAVE_STRERROR_R */
+
+/* Define to 1 if you have the <strings.h> header file. */
+/* #undef HAVE_STRINGS_H */
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the 'strtoul' function. */
+#define HAVE_STRTOUL 1
+
+/* Define to 1 if 'decimal_point' is a member of 'struct lconv'. */
+/* #undef HAVE_STRUCT_LCONV_DECIMAL_POINT */
+
+/* Define to 1 if the system has the type 'struct sockaddr_storage'. */
+#define HAVE_STRUCT_SOCKADDR_STORAGE 1
+
+/* Define to 1 if 'ss_family' is a member of 'struct sockaddr_storage'. */
+#define HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY 1
+
+/* Define to 1 if 'st_atimensec' is a member of 'struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_ATIMENSEC */
+
+/* Define to 1 if 'st_atimespec.tv_nsec' is a member of 'struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC */
+
+/* Define to 1 if 'st_atim.st__tim.tv_nsec' is a member of 'struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_ATIM_ST__TIM_TV_NSEC */
+
+/* Define to 1 if 'st_atim.tv_nsec' is a member of 'struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC */
+
+/* Define to 1 if 'st_birthtimensec' is a member of 'struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC */
+
+/* Define to 1 if 'st_birthtimespec.tv_nsec' is a member of 'struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */
+
+/* Define to 1 if 'st_birthtim.tv_nsec' is a member of 'struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIM_TV_NSEC */
+
+/* Define to 1 if you have the 'strverscmp' function. */
+/* #undef HAVE_STRVERSCMP */
+
+/* Define to 1 if you have the 'symlink' function. */
+/* #undef HAVE_SYMLINK */
+
+/* Define to 1 if you have the <sys/acl.h> header file. */
+/* #undef HAVE_SYS_ACL_H */
+
+/* Define to 1 if you have the <sys/bitypes.h> header file. */
+/* #undef HAVE_SYS_BITYPES_H */
+
+/* Define to 1 if you have the <sys/cdefs.h> header file. */
+/* #undef HAVE_SYS_CDEFS_H */
+
+/* Define to 1 if you have the <sys/inttypes.h> header file. */
+/* #undef HAVE_SYS_INTTYPES_H */
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+/* #undef HAVE_SYS_IOCTL_H */
+
+/* Define to 1 if you have the <sys/mman.h> header file. */
+/* #undef HAVE_SYS_MMAN_H */
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+/* #undef HAVE_SYS_PARAM_H */
+
+/* Define to 1 if you have the <sys/random.h> header file. */
+/* #undef HAVE_SYS_RANDOM_H */
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+/* #undef HAVE_SYS_SELECT_H */
+
+/* Define to 1 if you have the <sys/single_threaded.h> header file. */
+/* #undef HAVE_SYS_SINGLE_THREADED_H */
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+/* #undef HAVE_SYS_SOCKET_H */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+/* #undef HAVE_SYS_TIME_H */
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/uio.h> header file. */
+/* #undef HAVE_SYS_UIO_H */
+
+/* Define to 1 if you have the <sys/wait.h> header file. */
+/* #undef HAVE_SYS_WAIT_H */
+
+/* Define to 1 if you have the 'thrd_create' function. */
+/* #undef HAVE_THRD_CREATE */
+
+/* Define to 1 if you have the <threads.h> header file. */
+/* #undef HAVE_THREADS_H */
+
+/* Define to 1 if you have the 'towlower' function. */
+/* #undef HAVE_TOWLOWER */
+
+/* Define to 1 if you have the 'tsearch' function. */
+/* #undef HAVE_TSEARCH */
+
+/* Define to 1 if you have the <unistd.h> header file. */
+/* #undef HAVE_UNISTD_H */
+
+/* Define to 1 if you have the 'unsetenv' function. */
+/* #undef HAVE_UNSETENV */
+
+/* Define to 1 if the system has the type 'unsigned long long int'. */
+#define HAVE_UNSIGNED_LONG_LONG_INT 1
+
+/* Define to 1 if you have the 'uselocale' function. */
+/* #undef HAVE_USELOCALE */
+
+/* Define if you have a global __progname variable */
+/* #undef HAVE_VAR___PROGNAME */
+
+/* Define to 1 or 0, depending whether the compiler supports simple visibility
+   declarations. */
+#define HAVE_VISIBILITY 0
+
+/* Define to 1 if you have the <wchar.h> header file. */
+#define HAVE_WCHAR_H 1
+
+/* Define if you have the 'wchar_t' type. */
+#define HAVE_WCHAR_T 1
+
+/* Define to 1 if you have the 'wcrtomb' function. */
+#define HAVE_WCRTOMB 1
+
+/* Define to 1 if you have the 'wctob' function. */
+#define HAVE_WCTOB 1
+
+/* Define to 1 if you have the <wctype.h> header file. */
+#define HAVE_WCTYPE_H 1
+
+/* Define to 1 if the compiler and linker support weak declarations of
+   symbols. */
+/* #undef HAVE_WEAK_SYMBOLS */
+
+/* Define to 1 if you have the <winsock2.h> header file. */
+#define HAVE_WINSOCK2_H 1
+
+/* Define if you have the 'wint_t' type. */
+#define HAVE_WINT_T 1
+
+/* Define to 1 if O_NOATIME works. */
+#define HAVE_WORKING_O_NOATIME 0
+
+/* Define to 1 if O_NOFOLLOW works. */
+#define HAVE_WORKING_O_NOFOLLOW 0
+
+/* Define if the uselocale function exists and may safely be called. */
+/* #undef HAVE_WORKING_USELOCALE */
+
+/* Define to 1 if you have the <ws2tcpip.h> header file. */
+#define HAVE_WS2TCPIP_H 1
+
+/* Define to 1 if you have the <xlocale.h> header file. */
+/* #undef HAVE_XLOCALE_H */
+
+/* Define to 1 if you have the '_chsize' function. */
+#define HAVE__CHSIZE 1
+
+/* Define to 1 if you have the '_fseeki64' function. */
+#define HAVE__FSEEKI64 1
+
+/* Define to 1 if you have the '_ftelli64' function. */
+#define HAVE__FTELLI64 1
+
+/* Define to 1 if you have the '_set_invalid_parameter_handler' function. */
+#define HAVE__SET_INVALID_PARAMETER_HANDLER 1
+
+/* Define to 1 if the compiler supports __builtin_expect,
+   and to 2 if <builtins.h> does.  */
+/* #undef HAVE___BUILTIN_EXPECT */
+#ifndef HAVE___BUILTIN_EXPECT
+# define __builtin_expect(e, c) (e)
+#elif HAVE___BUILTIN_EXPECT == 2
+# include <builtins.h>
+#endif
+    
+
+/* Define to 1 if you have the '__fpurge' function. */
+/* #undef HAVE___FPURGE */
+
+/* Define to 1 if you have the '__freading' function. */
+/* #undef HAVE___FREADING */
+
+/* Define to 1 if you have the '__fwriting' function. */
+/* #undef HAVE___FWRITING */
+
+/* Define to 1 if ctype.h defines __header_inline. */
+/* #undef HAVE___HEADER_INLINE */
+
+/* Please see the Gnulib manual for how to use these macros.
+
+   Suppress extern inline with HP-UX cc, as it appears to be broken; see
+   <https://lists.gnu.org/r/bug-texinfo/2013-02/msg00030.html>.
+
+   Suppress extern inline with Sun C in standards-conformance mode, as it
+   mishandles inline functions that call each other.  E.g., for 'inline void f
+   (void) { } inline void g (void) { f (); }', c99 incorrectly complains
+   'reference to static identifier "f" in extern inline function'.
+   This bug was observed with Oracle Developer Studio 12.6
+   (Sun C 5.15 SunOS_sparc 2017/05/30).
+
+   Suppress extern inline (with or without __attribute__ ((__gnu_inline__)))
+   on configurations that mistakenly use 'static inline' to implement
+   functions or macros in standard C headers like <ctype.h>.  For example,
+   if isdigit is mistakenly implemented via a static inline function,
+   a program containing an extern inline function that calls isdigit
+   may not work since the C standard prohibits extern inline functions
+   from calling static functions (ISO C 99 section 6.7.4.(3).
+   This bug is known to occur on:
+
+     OS X 10.8 and earlier; see:
+     https://lists.gnu.org/r/bug-gnulib/2012-12/msg00023.html
+
+     DragonFly; see
+     http://muscles.dragonflybsd.org/bulk/clang-master-potential/20141111_102002/logs/ah-tty-0.3.12.log
+
+     FreeBSD; see:
+     https://lists.gnu.org/r/bug-gnulib/2014-07/msg00104.html
+
+   OS X 10.9 has a macro __header_inline indicating the bug is fixed for C and
+   for clang but remains for g++; see <https://trac.macports.org/ticket/41033>.
+   Assume DragonFly and FreeBSD will be similar.
+
+   GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
+   inline semantics, unless -fgnu89-inline is used.  It defines a macro
+   __GNUC_STDC_INLINE__ to indicate this situation or a macro
+   __GNUC_GNU_INLINE__ to indicate the opposite situation.
+   GCC 4.2 with -std=c99 or -std=gnu99 implements the GNU C inline
+   semantics but warns, unless -fgnu89-inline is used:
+     warning: C99 inline functions are not supported; using GNU89
+     warning: to disable this warning use -fgnu89-inline or the gnu_inline function attribute
+   It defines a macro __GNUC_GNU_INLINE__ to indicate this situation.
+ */
+#if (((defined __APPLE__ && defined __MACH__) \
+      || defined __DragonFly__ || defined __FreeBSD__) \
+     && (defined HAVE___HEADER_INLINE \
+         ? (defined __cplusplus && defined __GNUC_STDC_INLINE__ \
+            && ! defined __clang__) \
+         : ((! defined _DONT_USE_CTYPE_INLINE_ \
+             && (defined __GNUC__ || defined __cplusplus)) \
+            || (defined _FORTIFY_SOURCE && 0 < _FORTIFY_SOURCE \
+                && defined __GNUC__ && ! defined __cplusplus))))
+# define _GL_EXTERN_INLINE_STDHEADER_BUG
+#endif
+#if ((__GNUC__ \
+      ? defined __GNUC_STDC_INLINE__ && __GNUC_STDC_INLINE__ \
+      : (199901L <= __STDC_VERSION__ \
+         && !defined __HP_cc \
+         && !defined __PGI \
+         && !(defined __SUNPRO_C && __STDC__))) \
+     && !defined _GL_EXTERN_INLINE_STDHEADER_BUG)
+# define _GL_INLINE inline
+# define _GL_EXTERN_INLINE extern inline
+# define _GL_EXTERN_INLINE_IN_USE
+#elif (2 < __GNUC__ + (7 <= __GNUC_MINOR__) && !defined __STRICT_ANSI__ \
+       && !defined _GL_EXTERN_INLINE_STDHEADER_BUG)
+# if defined __GNUC_GNU_INLINE__ && __GNUC_GNU_INLINE__
+   /* __gnu_inline__ suppresses a GCC 4.2 diagnostic.  */
+#  define _GL_INLINE extern inline __attribute__ ((__gnu_inline__))
+# else
+#  define _GL_INLINE extern inline
+# endif
+# define _GL_EXTERN_INLINE extern
+# define _GL_EXTERN_INLINE_IN_USE
+#else
+# define _GL_INLINE _GL_UNUSED static
+# define _GL_EXTERN_INLINE _GL_UNUSED static
+#endif
+
+/* In GCC 4.6 (inclusive) to 5.1 (exclusive),
+   suppress bogus "no previous prototype for 'FOO'"
+   and "no previous declaration for 'FOO'" diagnostics,
+   when FOO is an inline function in the header; see
+   <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54113> and
+   <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63877>.  */
+#if __GNUC__ == 4 && 6 <= __GNUC_MINOR__
+# if defined __GNUC_STDC_INLINE__ && __GNUC_STDC_INLINE__
+#  define _GL_INLINE_HEADER_CONST_PRAGMA
+# else
+#  define _GL_INLINE_HEADER_CONST_PRAGMA \
+     _Pragma ("GCC diagnostic ignored \"-Wsuggest-attribute=const\"")
+# endif
+# define _GL_INLINE_HEADER_BEGIN \
+    _Pragma ("GCC diagnostic push") \
+    _Pragma ("GCC diagnostic ignored \"-Wmissing-prototypes\"") \
+    _Pragma ("GCC diagnostic ignored \"-Wmissing-declarations\"") \
+    _GL_INLINE_HEADER_CONST_PRAGMA
+# define _GL_INLINE_HEADER_END \
+    _Pragma ("GCC diagnostic pop")
+#else
+# define _GL_INLINE_HEADER_BEGIN
+# define _GL_INLINE_HEADER_END
+#endif
+
+/* Define to 1 if the compiler supports the keyword '__inline'. */
+#define HAVE___INLINE 1
+
+/* Define to 1 if you have the '__xpg_strerror_r' function. */
+/* #undef HAVE___XPG_STRERROR_R */
+
+/* Define if localename.c overrides newlocale(), duplocale(), freelocale(). */
+/* #undef LOCALENAME_ENHANCE_LOCALE_FUNCS */
+
+/* Define to 1 if lseek does not detect pipes. */
+/* #undef LSEEK_PIPE_BROKEN */
+
+/* Define to 1 if 'lstat' dereferences a symlink specified with a trailing
+   slash. */
+/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */
+
+/* If malloc(0) is != NULL, define this to 1. Otherwise define this to 0. */
+#define MALLOC_0_IS_NONNULL 1
+
+/* Define to a substitute value for mmap()'s MAP_ANONYMOUS flag. */
+/* #undef MAP_ANONYMOUS */
+
+/* Define if the mbrtowc function does not return (size_t) -2 for empty input.
+   */
+/* #undef MBRTOWC_EMPTY_INPUT_BUG */
+
+/* Define if the mbrtowc function may signal encoding errors in the C locale.
+   */
+/* #undef MBRTOWC_IN_C_LOCALE_MAYBE_EILSEQ */
+
+/* Define if the mbrtowc function has the NULL pwc argument bug. */
+/* #undef MBRTOWC_NULL_ARG1_BUG */
+
+/* Define if the mbrtowc function has the NULL string argument bug. */
+/* #undef MBRTOWC_NULL_ARG2_BUG */
+
+/* Define if the mbrtowc function does not return 0 for a NUL character. */
+/* #undef MBRTOWC_NUL_RETVAL_BUG */
+
+/* Define if the mbrtowc function returns a wrong return value. */
+/* #undef MBRTOWC_RETVAL_BUG */
+
+/* Define if the mbrtowc function stores a wide character when reporting
+   incomplete input. */
+/* #undef MBRTOWC_STORES_INCOMPLETE_BUG */
+
+/* Use GNU style printf and scanf.  */
+#ifndef __USE_MINGW_ANSI_STDIO
+# define __USE_MINGW_ANSI_STDIO 1
+#endif
+
+
+/* Define to 1 on musl libc. */
+/* #undef MUSL_LIBC */
+
+/* Define to 1 if assertions should be disabled. */
+/* #undef NDEBUG */
+
+/* Define to 1 to enable general improvements of setlocale. */
+#define NEED_SETLOCALE_IMPROVED 0
+
+/* Define to 1 to enable a multithread-safety fix of setlocale. */
+#define NEED_SETLOCALE_MTSAFE 0
+
+/* Define to 1 if nl_langinfo is multithread-safe. */
+/* #undef NL_LANGINFO_MTSAFE */
+
+/* Define to 1 if open() fails to recognize a trailing slash. */
+/* #undef OPEN_TRAILING_SLASH_BUG */
+
+/* Name of package */
+#define PACKAGE "sed"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "bug-sed@gnu.org"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "GNU sed"
+
+/* String identifying the packager of this software */
+/* #undef PACKAGE_PACKAGER */
+
+/* Packager info for bug reports (URL/e-mail/...) */
+/* #undef PACKAGE_PACKAGER_BUG_REPORTS */
+
+/* Packager-specific version information */
+/* #undef PACKAGE_PACKAGER_VERSION */
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "GNU sed 4.9"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "sed"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL "https://www.gnu.org/software/sed/"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "4.9"
+
+/* Define to the type that is the result of default argument promotions of
+   type mode_t. */
+#define PROMOTED_MODE_T mode_t
+
+/* Define if pthread_create is an inline function. */
+/* #undef PTHREAD_CREATE_IS_INLINE */
+
+/* Define if the pthread_in_use() detection is hard. */
+/* #undef PTHREAD_IN_USE_DETECTION_HARD */
+
+/* Define to 1 if pthread_sigmask(), when it fails, returns -1 and sets errno.
+   */
+/* #undef PTHREAD_SIGMASK_FAILS_WITH_ERRNO */
+
+/* Define to 1 if pthread_sigmask may return 0 and have no effect. */
+/* #undef PTHREAD_SIGMASK_INEFFECTIVE */
+
+/* Define to 1 if pthread_sigmask() unblocks signals incorrectly. */
+/* #undef PTHREAD_SIGMASK_UNBLOCK_BUG */
+
+/* Define to l, ll, u, ul, ull, etc., as suitable for constants of type
+   'ptrdiff_t'. */
+#define PTRDIFF_T_SUFFIX 
+
+/* Define to 1 if readlink fails to recognize a trailing slash. */
+/* #undef READLINK_TRAILING_SLASH_BUG */
+
+/* Define to 1 if readlink sets errno instead of truncating a too-long link.
+   */
+/* #undef READLINK_TRUNCATE_BUG */
+
+/* Define if rename does not work when the destination file exists, as on
+   Cygwin 1.5 or Windows. */
+#define RENAME_DEST_EXISTS_BUG 1
+
+/* Define if rename fails to leave hard links alone, as on NetBSD 1.6 or
+   Cygwin 1.5. */
+/* #undef RENAME_HARD_LINK_BUG */
+
+/* Define if rename does not correctly handle slashes on the destination
+   argument, such as on Solaris 11 or NetBSD 1.6. */
+#define RENAME_TRAILING_SLASH_DEST_BUG 1
+
+/* Define if rename does not correctly handle slashes on the source argument,
+   such as on Solaris 9 or cygwin 1.5. */
+/* #undef RENAME_TRAILING_SLASH_SOURCE_BUG */
+
+/* Define to 1 if gnulib's dirfd() replacement is used. */
+/* #undef REPLACE_DIRFD */
+
+/* Define to 1 if stat needs help when passed a file name with a trailing
+   slash */
+/* #undef REPLACE_FUNC_STAT_FILE */
+
+/* Define if nl_langinfo exists but is overridden by gnulib. */
+/* #undef REPLACE_NL_LANGINFO */
+
+/* Define to 1 if strerror(0) does not return a message implying success. */
+/* #undef REPLACE_STRERROR_0 */
+
+/* Define to 1 if setlocale (LC_ALL, NULL) is multithread-safe. */
+#define SETLOCALE_NULL_ALL_MTSAFE 1
+
+/* Define to 1 if setlocale (category, NULL) is multithread-safe. */
+#define SETLOCALE_NULL_ONE_MTSAFE 1
+
+/* Define to l, ll, u, ul, ull, etc., as suitable for constants of type
+   'sig_atomic_t'. */
+#define SIG_ATOMIC_T_SUFFIX 
+
+/* Define to l, ll, u, ul, ull, etc., as suitable for constants of type
+   'size_t'. */
+#define SIZE_T_SUFFIX u
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at runtime.
+	STACK_DIRECTION > 0 => grows toward higher addresses
+	STACK_DIRECTION < 0 => grows toward lower addresses
+	STACK_DIRECTION = 0 => direction of growth unknown */
+/* #undef STACK_DIRECTION */
+
+/* Define to 1 if the 'S_IS*' macros in <sys/stat.h> do not work properly. */
+/* #undef STAT_MACROS_BROKEN */
+
+/* Define to 1 if all of the C90 standard headers exist (not just the ones
+   required in a freestanding environment). This macro is provided for
+   backward compatibility; new code need not use it. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if strerror_r returns char *. */
+/* #undef STRERROR_R_CHAR_P */
+
+/* Define to 1 if the type of the st_atim member of a struct stat is struct
+   timespec. */
+/* #undef TYPEOF_STRUCT_STAT_ST_ATIM_IS_STRUCT_TIMESPEC */
+
+/* Define to nonzero if you want access control list support. */
+#define USE_ACL 0
+
+/* Define if the combination of the ISO C and POSIX multithreading APIs can be
+   used. */
+/* #undef USE_ISOC_AND_POSIX_THREADS */
+
+/* Define if the ISO C multithreading library can be used. */
+/* #undef USE_ISOC_THREADS */
+
+/* Define if the POSIX multithreading library can be used. */
+/* #undef USE_POSIX_THREADS */
+
+/* Define if references to the POSIX multithreading library are satisfied by
+   libc. */
+/* #undef USE_POSIX_THREADS_FROM_LIBC */
+
+/* Define if references to the POSIX multithreading library should be made
+   weak. */
+/* #undef USE_POSIX_THREADS_WEAK */
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# define _ALL_SOURCE 1
+#endif
+/* Enable general extensions on macOS.  */
+#ifndef _DARWIN_C_SOURCE
+# define _DARWIN_C_SOURCE 1
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# define __EXTENSIONS__ 1
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
+#endif
+/* Enable X/Open compliant socket functions that do not require linking
+   with -lxnet on HP-UX 11.11.  */
+#ifndef _HPUX_ALT_XOPEN_SOCKET_API
+# define _HPUX_ALT_XOPEN_SOCKET_API 1
+#endif
+/* Identify the host operating system as Minix.
+   This macro does not affect the system headers' behavior.
+   A future release of Autoconf may stop defining this macro.  */
+#ifndef _MINIX
+/* # undef _MINIX */
+#endif
+/* Enable general extensions on NetBSD.
+   Enable NetBSD compatibility extensions on Minix.  */
+#ifndef _NETBSD_SOURCE
+# define _NETBSD_SOURCE 1
+#endif
+/* Enable OpenBSD compatibility extensions on NetBSD.
+   Oddly enough, this does nothing on OpenBSD.  */
+#ifndef _OPENBSD_SOURCE
+# define _OPENBSD_SOURCE 1
+#endif
+/* Define to 1 if needed for POSIX-compatible behavior.  */
+#ifndef _POSIX_SOURCE
+/* # undef _POSIX_SOURCE */
+#endif
+/* Define to 2 if needed for POSIX-compatible behavior.  */
+#ifndef _POSIX_1_SOURCE
+/* # undef _POSIX_1_SOURCE */
+#endif
+/* Enable POSIX-compatible threading on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# define _POSIX_PTHREAD_SEMANTICS 1
+#endif
+/* Enable extensions specified by ISO/IEC TS 18661-5:2014.  */
+#ifndef __STDC_WANT_IEC_60559_ATTRIBS_EXT__
+# define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1
+#endif
+/* Enable extensions specified by ISO/IEC TS 18661-1:2014.  */
+#ifndef __STDC_WANT_IEC_60559_BFP_EXT__
+# define __STDC_WANT_IEC_60559_BFP_EXT__ 1
+#endif
+/* Enable extensions specified by ISO/IEC TS 18661-2:2015.  */
+#ifndef __STDC_WANT_IEC_60559_DFP_EXT__
+# define __STDC_WANT_IEC_60559_DFP_EXT__ 1
+#endif
+/* Enable extensions specified by ISO/IEC TS 18661-4:2015.  */
+#ifndef __STDC_WANT_IEC_60559_FUNCS_EXT__
+# define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1
+#endif
+/* Enable extensions specified by ISO/IEC TS 18661-3:2015.  */
+#ifndef __STDC_WANT_IEC_60559_TYPES_EXT__
+# define __STDC_WANT_IEC_60559_TYPES_EXT__ 1
+#endif
+/* Enable extensions specified by ISO/IEC TR 24731-2:2010.  */
+#ifndef __STDC_WANT_LIB_EXT2__
+# define __STDC_WANT_LIB_EXT2__ 1
+#endif
+/* Enable extensions specified by ISO/IEC 24747:2009.  */
+#ifndef __STDC_WANT_MATH_SPEC_FUNCS__
+# define __STDC_WANT_MATH_SPEC_FUNCS__ 1
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# define _TANDEM_SOURCE 1
+#endif
+/* Enable X/Open extensions.  Define to 500 only if necessary
+   to make mbstate_t available.  */
+#ifndef _XOPEN_SOURCE
+/* # undef _XOPEN_SOURCE */
+#endif
+
+
+/* An alias of GNULIB_STDIO_SINGLE_THREAD. */
+#define USE_UNLOCKED_IO GNULIB_STDIO_SINGLE_THREAD
+
+/* Define if the native Windows multithreading API can be used. */
+/* #undef USE_WINDOWS_THREADS */
+
+/* Version number of package */
+#define VERSION "4.9"
+
+/* Define to 1 if unsetenv returns void instead of int. */
+/* #undef VOID_UNSETENV */
+
+/* Define to l, ll, u, ul, ull, etc., as suitable for constants of type
+   'wchar_t'. */
+#define WCHAR_T_SUFFIX 
+
+/* Define if the wcrtomb function does not work in the C locale. */
+/* #undef WCRTOMB_C_LOCALE_BUG */
+
+/* Define if the wcrtomb function has an incorrect return value. */
+/* #undef WCRTOMB_RETVAL_BUG */
+
+/* Define if WSAStartup is needed. */
+#define WINDOWS_SOCKETS 1
+
+/* Define to l, ll, u, ul, ull, etc., as suitable for constants of type
+   'wint_t'. */
+#define WINT_T_SUFFIX 
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #  undef WORDS_BIGENDIAN */
+# endif
+#endif
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef _FILE_OFFSET_BITS */
+
+/* True if the compiler says it groks GNU C version MAJOR.MINOR.  */
+#if defined __GNUC__ && defined __GNUC_MINOR__
+# define _GL_GNUC_PREREQ(major, minor) \
+    ((major) < __GNUC__ + ((minor) <= __GNUC_MINOR__))
+#else
+# define _GL_GNUC_PREREQ(major, minor) 0
+#endif
+
+
+/* Define to enable the declarations of ISO C 11 types and functions. */
+/* #undef _ISOC11_SOURCE */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef _LARGE_FILES */
+
+/* Define to 1 on Solaris. */
+/* #undef _LCONV_C99 */
+
+/* The _Noreturn keyword of C11.  */
+#ifndef _Noreturn
+# if (defined __cplusplus \
+      && ((201103 <= __cplusplus && !(__GNUC__ == 4 && __GNUC_MINOR__ == 7)) \
+          || (defined _MSC_VER && 1900 <= _MSC_VER)) \
+      && 0)
+    /* [[noreturn]] is not practically usable, because with it the syntax
+         extern _Noreturn void func (...);
+       would not be valid; such a declaration would only be valid with 'extern'
+       and '_Noreturn' swapped, or without the 'extern' keyword.  However, some
+       AIX system header files and several gnulib header files use precisely
+       this syntax with 'extern'.  */
+#  define _Noreturn [[noreturn]]
+# elif ((!defined __cplusplus || defined __clang__) \
+        && (201112 <= (defined __STDC_VERSION__ ? __STDC_VERSION__ : 0) \
+            || (!defined __STRICT_ANSI__ \
+                && (_GL_GNUC_PREREQ (4, 7) \
+                    || (defined __apple_build_version__ \
+                        ? 6000000 <= __apple_build_version__ \
+                        : 3 < __clang_major__ + (5 <= __clang_minor__))))))
+   /* _Noreturn works as-is.  */
+# elif _GL_GNUC_PREREQ (2, 8) || defined __clang__ || 0x5110 <= __SUNPRO_C
+#  define _Noreturn __attribute__ ((__noreturn__))
+# elif 1200 <= (defined _MSC_VER ? _MSC_VER : 0)
+#  define _Noreturn __declspec (noreturn)
+# else
+#  define _Noreturn
+# endif
+#endif
+
+
+/* Define to 1 in order to get the POSIX compatible declarations of socket
+   functions. */
+/* #undef _POSIX_PII_SOCKET */
+
+/* Define if you want <regex.h> to include <limits.h>, so that it consistently
+   overrides <limits.h>'s RE_DUP_MAX. */
+#define _REGEX_INCLUDE_LIMITS_H 1
+
+/* Define if you want regoff_t to be at least as wide POSIX requires. */
+#define _REGEX_LARGE_OFFSETS 1
+
+/* Number of bits in a timestamp, on hosts where this is settable. */
+/* #undef _TIME_BITS */
+
+/* For standard stat data types on VMS. */
+#define _USE_STD_STAT 1
+
+#if !defined __MINGW_USE_VC2005_COMPAT && defined __MINGW32__
+# define __MINGW_USE_VC2005_COMPAT 1 /* For 64-bit time_t.  */
+#endif
+
+/* Define to 1 if the system <stdint.h> predates C++11. */
+/* #undef __STDC_CONSTANT_MACROS */
+
+/* Define to 1 if the system <stdint.h> predates C++11. */
+/* #undef __STDC_LIMIT_MACROS */
+
+/* Define to 1 if C does not support variable-length arrays, and if the
+   compiler does not already define this. */
+#define __STDC_NO_VLA__ 1
+
+/* The _GL_ASYNC_SAFE marker should be attached to functions that are
+   signal handlers (for signals other than SIGABRT, SIGPIPE) or can be
+   invoked from such signal handlers.  Such functions have some restrictions:
+     * All functions that it calls should be marked _GL_ASYNC_SAFE as well,
+       or should be listed as async-signal-safe in POSIX
+       <https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04>
+       section 2.4.3.  Note that malloc(), sprintf(), and fwrite(), in
+       particular, are NOT async-signal-safe.
+     * All memory locations (variables and struct fields) that these functions
+       access must be marked 'volatile'.  This holds for both read and write
+       accesses.  Otherwise the compiler might optimize away stores to and
+       reads from such locations that occur in the program, depending on its
+       data flow analysis.  For example, when the program contains a loop
+       that is intended to inspect a variable set from within a signal handler
+           while (!signal_occurred)
+             ;
+       the compiler is allowed to transform this into an endless loop if the
+       variable 'signal_occurred' is not declared 'volatile'.
+   Additionally, recall that:
+     * A signal handler should not modify errno (except if it is a handler
+       for a fatal signal and ends by raising the same signal again, thus
+       provoking the termination of the process).  If it invokes a function
+       that may clobber errno, it needs to save and restore the value of
+       errno.  */
+#define _GL_ASYNC_SAFE
+
+
+/* Attributes.  */
+#if (defined __has_attribute \
+     && (!defined __clang_minor__ \
+         || (defined __apple_build_version__ \
+             ? 6000000 <= __apple_build_version__ \
+             : 3 < __clang_major__ + (5 <= __clang_minor__))))
+# define _GL_HAS_ATTRIBUTE(attr) __has_attribute (__##attr##__)
+#else
+# define _GL_HAS_ATTRIBUTE(attr) _GL_ATTR_##attr
+# define _GL_ATTR_alloc_size _GL_GNUC_PREREQ (4, 3)
+# define _GL_ATTR_always_inline _GL_GNUC_PREREQ (3, 2)
+# define _GL_ATTR_artificial _GL_GNUC_PREREQ (4, 3)
+# define _GL_ATTR_cold _GL_GNUC_PREREQ (4, 3)
+# define _GL_ATTR_const _GL_GNUC_PREREQ (2, 95)
+# define _GL_ATTR_deprecated _GL_GNUC_PREREQ (3, 1)
+# define _GL_ATTR_diagnose_if 0
+# define _GL_ATTR_error _GL_GNUC_PREREQ (4, 3)
+# define _GL_ATTR_externally_visible _GL_GNUC_PREREQ (4, 1)
+# define _GL_ATTR_fallthrough _GL_GNUC_PREREQ (7, 0)
+# define _GL_ATTR_format _GL_GNUC_PREREQ (2, 7)
+# define _GL_ATTR_leaf _GL_GNUC_PREREQ (4, 6)
+# define _GL_ATTR_malloc _GL_GNUC_PREREQ (3, 0)
+# ifdef _ICC
+#  define _GL_ATTR_may_alias 0
+# else
+#  define _GL_ATTR_may_alias _GL_GNUC_PREREQ (3, 3)
+# endif
+# define _GL_ATTR_noinline _GL_GNUC_PREREQ (3, 1)
+# define _GL_ATTR_nonnull _GL_GNUC_PREREQ (3, 3)
+# define _GL_ATTR_nonstring _GL_GNUC_PREREQ (8, 0)
+# define _GL_ATTR_nothrow _GL_GNUC_PREREQ (3, 3)
+# define _GL_ATTR_packed _GL_GNUC_PREREQ (2, 7)
+# define _GL_ATTR_pure _GL_GNUC_PREREQ (2, 96)
+# define _GL_ATTR_returns_nonnull _GL_GNUC_PREREQ (4, 9)
+# define _GL_ATTR_sentinel _GL_GNUC_PREREQ (4, 0)
+# define _GL_ATTR_unused _GL_GNUC_PREREQ (2, 7)
+# define _GL_ATTR_warn_unused_result _GL_GNUC_PREREQ (3, 4)
+#endif
+
+#ifdef __has_c_attribute
+# if ((defined __STDC_VERSION__ ? __STDC_VERSION__ : 0) <= 201710 \
+      && _GL_GNUC_PREREQ (4, 6))
+#  pragma GCC diagnostic ignored "-Wpedantic"
+# endif
+# define _GL_HAS_C_ATTRIBUTE(attr) __has_c_attribute (__##attr##__)
+#else
+# define _GL_HAS_C_ATTRIBUTE(attr) 0
+#endif
+
+
+/* _GL_ATTRIBUTE_ALLOC_SIZE ((N)) declares that the Nth argument of the function
+   is the size of the returned memory block.
+   _GL_ATTRIBUTE_ALLOC_SIZE ((M, N)) declares that the Mth argument multiplied
+   by the Nth argument of the function is the size of the returned memory block.
+ */
+/* Applies to: function, pointer to function, function types.  */
+#if _GL_HAS_ATTRIBUTE (alloc_size)
+# define _GL_ATTRIBUTE_ALLOC_SIZE(args) __attribute__ ((__alloc_size__ args))
+#else
+# define _GL_ATTRIBUTE_ALLOC_SIZE(args)
+#endif
+
+/* _GL_ATTRIBUTE_ALWAYS_INLINE tells that the compiler should always inline the
+   function and report an error if it cannot do so.  */
+/* Applies to: function.  */
+#if _GL_HAS_ATTRIBUTE (always_inline)
+# define _GL_ATTRIBUTE_ALWAYS_INLINE __attribute__ ((__always_inline__))
+#else
+# define _GL_ATTRIBUTE_ALWAYS_INLINE
+#endif
+
+/* _GL_ATTRIBUTE_ARTIFICIAL declares that the function is not important to show
+    in stack traces when debugging.  The compiler should omit the function from
+    stack traces.  */
+/* Applies to: function.  */
+#if _GL_HAS_ATTRIBUTE (artificial)
+# define _GL_ATTRIBUTE_ARTIFICIAL __attribute__ ((__artificial__))
+#else
+# define _GL_ATTRIBUTE_ARTIFICIAL
+#endif
+
+/* _GL_ATTRIBUTE_COLD declares that the function is rarely executed.  */
+/* Applies to: functions.  */
+/* Avoid __attribute__ ((cold)) on MinGW; see thread starting at
+   <https://lists.gnu.org/r/emacs-devel/2019-04/msg01152.html>.
+   Also, Oracle Studio 12.6 requires 'cold' not '__cold__'.  */
+#if _GL_HAS_ATTRIBUTE (cold) && !defined __MINGW32__
+# ifndef __SUNPRO_C
+#  define _GL_ATTRIBUTE_COLD __attribute__ ((__cold__))
+# else
+#  define _GL_ATTRIBUTE_COLD __attribute__ ((cold))
+# endif
+#else
+# define _GL_ATTRIBUTE_COLD
+#endif
+
+/* _GL_ATTRIBUTE_CONST declares that it is OK for a compiler to omit duplicate
+   calls to the function with the same arguments.
+   This attribute is safe for a function that neither depends on nor affects
+   observable state, and always returns exactly once - e.g., does not loop
+   forever, and does not call longjmp.
+   (This attribute is stricter than _GL_ATTRIBUTE_PURE.)  */
+/* Applies to: functions.  */
+#if _GL_HAS_ATTRIBUTE (const)
+# define _GL_ATTRIBUTE_CONST __attribute__ ((__const__))
+#else
+# define _GL_ATTRIBUTE_CONST
+#endif
+
+/* _GL_ATTRIBUTE_DEALLOC (F, I) declares that the function returns pointers
+   that can be freed by passing them as the Ith argument to the
+   function F.
+   _GL_ATTRIBUTE_DEALLOC_FREE declares that the function returns pointers that
+   can be freed via 'free'; it can be used only after declaring 'free'.  */
+/* Applies to: functions.  Cannot be used on inline functions.  */
+#if _GL_GNUC_PREREQ (11, 0)
+# define _GL_ATTRIBUTE_DEALLOC(f, i) __attribute__ ((__malloc__ (f, i)))
+#else
+# define _GL_ATTRIBUTE_DEALLOC(f, i)
+#endif
+/* If gnulib's <string.h> or <wchar.h> has already defined this macro, continue
+   to use this earlier definition, since <stdlib.h> may not have been included
+   yet.  */
+#ifndef _GL_ATTRIBUTE_DEALLOC_FREE
+# define _GL_ATTRIBUTE_DEALLOC_FREE _GL_ATTRIBUTE_DEALLOC (free, 1)
+#endif
+
+/* _GL_ATTRIBUTE_DEPRECATED: Declares that an entity is deprecated.
+   The compiler may warn if the entity is used.  */
+/* Applies to:
+     - function, variable,
+     - struct, union, struct/union member,
+     - enumeration, enumeration item,
+     - typedef,
+   in C++ also: namespace, class, template specialization.  */
+#if _GL_HAS_C_ATTRIBUTE (deprecated)
+# define _GL_ATTRIBUTE_DEPRECATED [[__deprecated__]]
+#elif _GL_HAS_ATTRIBUTE (deprecated)
+# define _GL_ATTRIBUTE_DEPRECATED __attribute__ ((__deprecated__))
+#else
+# define _GL_ATTRIBUTE_DEPRECATED
+#endif
+
+/* _GL_ATTRIBUTE_ERROR(msg) requests an error if a function is called and
+   the function call is not optimized away.
+   _GL_ATTRIBUTE_WARNING(msg) requests a warning if a function is called and
+   the function call is not optimized away.  */
+/* Applies to: functions.  */
+#if _GL_HAS_ATTRIBUTE (error)
+# define _GL_ATTRIBUTE_ERROR(msg) __attribute__ ((__error__ (msg)))
+# define _GL_ATTRIBUTE_WARNING(msg) __attribute__ ((__warning__ (msg)))
+#elif _GL_HAS_ATTRIBUTE (diagnose_if)
+# define _GL_ATTRIBUTE_ERROR(msg) __attribute__ ((__diagnose_if__ (1, msg, "error")))
+# define _GL_ATTRIBUTE_WARNING(msg) __attribute__ ((__diagnose_if__ (1, msg, "warning")))
+#else
+# define _GL_ATTRIBUTE_ERROR(msg)
+# define _GL_ATTRIBUTE_WARNING(msg)
+#endif
+
+/* _GL_ATTRIBUTE_EXTERNALLY_VISIBLE declares that the entity should remain
+   visible to debuggers etc., even with '-fwhole-program'.  */
+/* Applies to: functions, variables.  */
+#if _GL_HAS_ATTRIBUTE (externally_visible)
+# define _GL_ATTRIBUTE_EXTERNALLY_VISIBLE __attribute__ ((externally_visible))
+#else
+# define _GL_ATTRIBUTE_EXTERNALLY_VISIBLE
+#endif
+
+/* _GL_ATTRIBUTE_FALLTHROUGH declares that it is not a programming mistake if
+   the control flow falls through to the immediately following 'case' or
+   'default' label.  The compiler should not warn in this case.  */
+/* Applies to: Empty statement (;), inside a 'switch' statement.  */
+/* Always expands to something.  */
+#if _GL_HAS_C_ATTRIBUTE (fallthrough)
+# define _GL_ATTRIBUTE_FALLTHROUGH [[__fallthrough__]]
+#elif _GL_HAS_ATTRIBUTE (fallthrough)
+# define _GL_ATTRIBUTE_FALLTHROUGH __attribute__ ((__fallthrough__))
+#else
+# define _GL_ATTRIBUTE_FALLTHROUGH ((void) 0)
+#endif
+
+/* _GL_ATTRIBUTE_FORMAT ((ARCHETYPE, STRING-INDEX, FIRST-TO-CHECK))
+   declares that the STRING-INDEXth function argument is a format string of
+   style ARCHETYPE, which is one of:
+     printf, gnu_printf
+     scanf, gnu_scanf,
+     strftime, gnu_strftime,
+     strfmon,
+   or the same thing prefixed and suffixed with '__'.
+   If FIRST-TO-CHECK is not 0, arguments starting at FIRST-TO_CHECK
+   are suitable for the format string.  */
+/* Applies to: functions.  */
+#if _GL_HAS_ATTRIBUTE (format)
+# define _GL_ATTRIBUTE_FORMAT(spec) __attribute__ ((__format__ spec))
+#else
+# define _GL_ATTRIBUTE_FORMAT(spec)
+#endif
+
+/* _GL_ATTRIBUTE_LEAF declares that if the function is called from some other
+   compilation unit, it executes code from that unit only by return or by
+   exception handling.  This declaration lets the compiler optimize that unit
+   more aggressively.  */
+/* Applies to: functions.  */
+#if _GL_HAS_ATTRIBUTE (leaf)
+# define _GL_ATTRIBUTE_LEAF __attribute__ ((__leaf__))
+#else
+# define _GL_ATTRIBUTE_LEAF
+#endif
+
+/* _GL_ATTRIBUTE_MALLOC declares that the function returns a pointer to freshly
+   allocated memory.  */
+/* Applies to: functions.  */
+#if _GL_HAS_ATTRIBUTE (malloc)
+# define _GL_ATTRIBUTE_MALLOC __attribute__ ((__malloc__))
+#else
+# define _GL_ATTRIBUTE_MALLOC
+#endif
+
+/* _GL_ATTRIBUTE_MAY_ALIAS declares that pointers to the type may point to the
+   same storage as pointers to other types.  Thus this declaration disables
+   strict aliasing optimization.  */
+/* Applies to: types.  */
+/* Oracle Studio 12.6 mishandles may_alias despite __has_attribute OK.  */
+#if _GL_HAS_ATTRIBUTE (may_alias) && !defined __SUNPRO_C
+# define _GL_ATTRIBUTE_MAY_ALIAS __attribute__ ((__may_alias__))
+#else
+# define _GL_ATTRIBUTE_MAY_ALIAS
+#endif
+
+/* _GL_ATTRIBUTE_MAYBE_UNUSED declares that it is not a programming mistake if
+   the entity is not used.  The compiler should not warn if the entity is not
+   used.  */
+/* Applies to:
+     - function, variable,
+     - struct, union, struct/union member,
+     - enumeration, enumeration item,
+     - typedef,
+   in C++ also: class.  */
+/* In C++ and C2x, this is spelled [[__maybe_unused__]].
+   GCC's syntax is __attribute__ ((__unused__)).
+   clang supports both syntaxes.  */
+#if _GL_HAS_C_ATTRIBUTE (maybe_unused)
+# define _GL_ATTRIBUTE_MAYBE_UNUSED [[__maybe_unused__]]
+#else
+# define _GL_ATTRIBUTE_MAYBE_UNUSED _GL_ATTRIBUTE_UNUSED
+#endif
+/* Alternative spelling of this macro, for convenience and for
+   compatibility with glibc/include/libc-symbols.h.  */
+#define _GL_UNUSED _GL_ATTRIBUTE_MAYBE_UNUSED
+/* Earlier spellings of this macro.  */
+#define _UNUSED_PARAMETER_ _GL_ATTRIBUTE_MAYBE_UNUSED
+
+/* _GL_ATTRIBUTE_NODISCARD declares that the caller of the function should not
+   discard the return value.  The compiler may warn if the caller does not use
+   the return value, unless the caller uses something like ignore_value.  */
+/* Applies to: function, enumeration, class.  */
+#if _GL_HAS_C_ATTRIBUTE (nodiscard)
+# define _GL_ATTRIBUTE_NODISCARD [[__nodiscard__]]
+#elif _GL_HAS_ATTRIBUTE (warn_unused_result)
+# define _GL_ATTRIBUTE_NODISCARD __attribute__ ((__warn_unused_result__))
+#else
+# define _GL_ATTRIBUTE_NODISCARD
+#endif
+
+/* _GL_ATTRIBUTE_NOINLINE tells that the compiler should not inline the
+   function.  */
+/* Applies to: functions.  */
+#if _GL_HAS_ATTRIBUTE (noinline)
+# define _GL_ATTRIBUTE_NOINLINE __attribute__ ((__noinline__))
+#else
+# define _GL_ATTRIBUTE_NOINLINE
+#endif
+
+/* _GL_ATTRIBUTE_NONNULL ((N1, N2,...)) declares that the arguments N1, N2,...
+   must not be NULL.
+   _GL_ATTRIBUTE_NONNULL () declares that all pointer arguments must not be
+   null.  */
+/* Applies to: functions.  */
+#if _GL_HAS_ATTRIBUTE (nonnull)
+# define _GL_ATTRIBUTE_NONNULL(args) __attribute__ ((__nonnull__ args))
+#else
+# define _GL_ATTRIBUTE_NONNULL(args)
+#endif
+
+/* _GL_ATTRIBUTE_NONSTRING declares that the contents of a character array is
+   not meant to be NUL-terminated.  */
+/* Applies to: struct/union members and variables that are arrays of element
+   type '[[un]signed] char'.  */
+#if _GL_HAS_ATTRIBUTE (nonstring)
+# define _GL_ATTRIBUTE_NONSTRING __attribute__ ((__nonstring__))
+#else
+# define _GL_ATTRIBUTE_NONSTRING
+#endif
+
+/* There is no _GL_ATTRIBUTE_NORETURN; use _Noreturn instead.  */
+
+/* _GL_ATTRIBUTE_NOTHROW declares that the function does not throw exceptions.
+ */
+/* Applies to: functions.  */
+#if _GL_HAS_ATTRIBUTE (nothrow) && !defined __cplusplus
+# define _GL_ATTRIBUTE_NOTHROW __attribute__ ((__nothrow__))
+#else
+# define _GL_ATTRIBUTE_NOTHROW
+#endif
+
+/* _GL_ATTRIBUTE_PACKED declares:
+   For struct members: The member has the smallest possible alignment.
+   For struct, union, class: All members have the smallest possible alignment,
+   minimizing the memory required.  */
+/* Applies to: struct members, struct, union,
+   in C++ also: class.  */
+#if _GL_HAS_ATTRIBUTE (packed)
+# define _GL_ATTRIBUTE_PACKED __attribute__ ((__packed__))
+#else
+# define _GL_ATTRIBUTE_PACKED
+#endif
+
+/* _GL_ATTRIBUTE_PURE declares that It is OK for a compiler to omit duplicate
+   calls to the function with the same arguments if observable state is not
+   changed between calls.
+   This attribute is safe for a function that does not affect
+   observable state, and always returns exactly once.
+   (This attribute is looser than _GL_ATTRIBUTE_CONST.)  */
+/* Applies to: functions.  */
+#if _GL_HAS_ATTRIBUTE (pure)
+# define _GL_ATTRIBUTE_PURE __attribute__ ((__pure__))
+#else
+# define _GL_ATTRIBUTE_PURE
+#endif
+
+/* _GL_ATTRIBUTE_RETURNS_NONNULL declares that the function's return value is
+   a non-NULL pointer.  */
+/* Applies to: functions.  */
+#if _GL_HAS_ATTRIBUTE (returns_nonnull)
+# define _GL_ATTRIBUTE_RETURNS_NONNULL __attribute__ ((__returns_nonnull__))
+#else
+# define _GL_ATTRIBUTE_RETURNS_NONNULL
+#endif
+
+/* _GL_ATTRIBUTE_SENTINEL(pos) declares that the variadic function expects a
+   trailing NULL argument.
+   _GL_ATTRIBUTE_SENTINEL () - The last argument is NULL (requires C99).
+   _GL_ATTRIBUTE_SENTINEL ((N)) - The (N+1)st argument from the end is NULL.  */
+/* Applies to: functions.  */
+#if _GL_HAS_ATTRIBUTE (sentinel)
+# define _GL_ATTRIBUTE_SENTINEL(pos) __attribute__ ((__sentinel__ pos))
+#else
+# define _GL_ATTRIBUTE_SENTINEL(pos)
+#endif
+
+/* A helper macro.  Don't use it directly.  */
+#if _GL_HAS_ATTRIBUTE (unused)
+# define _GL_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
+#else
+# define _GL_ATTRIBUTE_UNUSED
+#endif
+
+
+/* _GL_UNUSED_LABEL; declares that it is not a programming mistake if the
+   immediately preceding label is not used.  The compiler should not warn
+   if the label is not used.  */
+/* Applies to: label (both in C and C++).  */
+/* Note that g++ < 4.5 does not support the '__attribute__ ((__unused__)) ;'
+   syntax.  But clang does.  */
+#if !(defined __cplusplus && !_GL_GNUC_PREREQ (4, 5)) || defined __clang__
+# define _GL_UNUSED_LABEL _GL_ATTRIBUTE_UNUSED
+#else
+# define _GL_UNUSED_LABEL
+#endif
+
+
+/* Define to empty if 'const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Always use our fgetfilecon wrapper. */
+/* #undef fgetfilecon */
+
+/* Always use our getfilecon wrapper. */
+/* #undef getfilecon */
+
+/* Define to 'int' if <sys/types.h> doesn't define. */
+#define gid_t int
+
+/* A replacement for va_copy, if needed.  */
+#define gl_va_copy(a,b) ((a) = (b))
+
+/* Define to '__inline__' or '__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+#define inline __inline
+#endif
+
+/* Work around a bug in Apple GCC 4.0.1 build 5465: In C99 mode, it supports
+   the ISO C 99 semantics of 'extern inline' (unlike the GNU C semantics of
+   earlier versions), but does not display it by setting __GNUC_STDC_INLINE__.
+   __APPLE__ && __MACH__ test for Mac OS X.
+   __APPLE_CC__ tests for the Apple compiler and its version.
+   __STDC_VERSION__ tests for the C99 mode.  */
+#if defined __APPLE__ && defined __MACH__ && __APPLE_CC__ >= 5465 && !defined __cplusplus && __STDC_VERSION__ >= 199901L && !defined __GNUC_STDC_INLINE__
+# define __GNUC_STDC_INLINE__ 1
+#endif
+
+/* Always use our lgetfilecon wrapper. */
+/* #undef lgetfilecon */
+
+/* Define to 1 if the compiler is checking for lint. */
+/* #undef lint */
+
+/* Define to a type if <wchar.h> does not define. */
+/* #undef mbstate_t */
+
+/* _GL_CMP (n1, n2) performs a three-valued comparison on n1 vs. n2, where
+   n1 and n2 are expressions without side effects, that evaluate to real
+   numbers (excluding NaN).
+   It returns
+     1  if n1 > n2
+     0  if n1 == n2
+     -1 if n1 < n2
+   The nave code   (n1 > n2 ? 1 : n1 < n2 ? -1 : 0)  produces a conditional
+   jump with nearly all GCC versions up to GCC 10.
+   This variant     (n1 < n2 ? -1 : n1 > n2)  produces a conditional with many
+   GCC versions up to GCC 9.
+   The better code  (n1 > n2) - (n1 < n2)  from Hacker's Delight  2-9
+   avoids conditional jumps in all GCC versions >= 3.4.  */
+#define _GL_CMP(n1, n2) (((n1) > (n2)) - ((n1) < (n2)))
+
+
+/* Define to 'int' if <sys/types.h> does not define. */
+#define mode_t int
+
+/* Define to the type of st_nlink in struct stat, or a supertype. */
+#define nlink_t int
+
+/* Define as a signed integer type capable of holding a process identifier. */
+#define pid_t int
+
+/* Define to rpl_re_comp if the replacement should be used. */
+#define re_comp rpl_re_comp
+
+/* Define to rpl_re_compile_fastmap if the replacement should be used. */
+#define re_compile_fastmap rpl_re_compile_fastmap
+
+/* Define to rpl_re_compile_pattern if the replacement should be used. */
+#define re_compile_pattern rpl_re_compile_pattern
+
+/* Define to rpl_re_exec if the replacement should be used. */
+#define re_exec rpl_re_exec
+
+/* Define to rpl_re_match if the replacement should be used. */
+#define re_match rpl_re_match
+
+/* Define to rpl_re_match_2 if the replacement should be used. */
+#define re_match_2 rpl_re_match_2
+
+/* Define to rpl_re_search if the replacement should be used. */
+#define re_search rpl_re_search
+
+/* Define to rpl_re_search_2 if the replacement should be used. */
+#define re_search_2 rpl_re_search_2
+
+/* Define to rpl_re_set_registers if the replacement should be used. */
+#define re_set_registers rpl_re_set_registers
+
+/* Define to rpl_re_set_syntax if the replacement should be used. */
+#define re_set_syntax rpl_re_set_syntax
+
+/* Define to rpl_re_syntax_options if the replacement should be used. */
+#define re_syntax_options rpl_re_syntax_options
+
+/* Define to rpl_regcomp if the replacement should be used. */
+#define regcomp rpl_regcomp
+
+/* Define to rpl_regerror if the replacement should be used. */
+#define regerror rpl_regerror
+
+/* Define to rpl_regexec if the replacement should be used. */
+#define regexec rpl_regexec
+
+/* Define to rpl_regfree if the replacement should be used. */
+#define regfree rpl_regfree
+
+/* Define to the equivalent of the C99 'restrict' keyword, or to
+   nothing if this is not supported.  Do not define if restrict is
+   supported only directly.  */
+#define restrict /**/
+/* Work around a bug in older versions of Sun C++, which did not
+   #define __restrict__ or support _Restrict or __restrict__
+   even though the corresponding Sun C compiler ended up with
+   "#define restrict _Restrict" or "#define restrict __restrict__"
+   in the previous line.  This workaround can be removed once
+   we assume Oracle Developer Studio 12.5 (2016) or later.  */
+#if defined __SUNPRO_CC && !defined __RESTRICT && !defined __restrict__
+# define _Restrict
+# define __restrict__
+#endif
+
+/* Define to 'unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* type to use in place of socklen_t if not defined */
+/* #undef socklen_t */
+
+/* Define as a signed type of the same size as size_t. */
+#define ssize_t int
+
+/* Define to 'int' if <sys/types.h> doesn't define. */
+#define uid_t int
+
+/* Define as a macro for copying va_list variables. */
+#define va_copy gl_va_copy
+
+#if !defined HAVE_C_ALIGNASOF && __cplusplus < 201103 && !defined alignof
+# if HAVE_STDALIGN_H
+#  include <stdalign.h>
+# else
+   /* Substitute.  Keep consistent with gnulib/lib/stdalign.in.h.  */
+#  ifndef _GL_STDALIGN_H
+#   define _GL_STDALIGN_H
+/* #   undef _Alignas */
+/* #   undef _Alignof */
+#   if (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112 \
+        || (defined __GNUC__ && __GNUC__ < 4 + (__GNUC_MINOR__ < 9) \
+            && !defined __clang__) \
+        || (defined __clang__ && __clang_major__ < 8))
+#    ifdef __cplusplus
+#     if (201103 <= __cplusplus || defined _MSC_VER)
+#      define _Alignof(type) alignof (type)
+#     else
+       template <class __t> struct __alignof_helper { char __a; __t __b; };
+#      define _Alignof(type) offsetof (__alignof_helper<type>, __b)
+#      define _GL_STDALIGN_NEEDS_STDDEF 1
+#     endif
+#    else
+#     define _Alignof(type) offsetof (struct { char __a; type __b; }, __b)
+#     define _GL_STDALIGN_NEEDS_STDDEF 1
+#    endif
+#   endif
+#   if ! (defined __cplusplus && (201103 <= __cplusplus || defined _MSC_VER))
+#    define alignof _Alignof
+#   endif
+#   define __alignof_is_defined 1
+#   if !defined __STDC_VERSION__ || __STDC_VERSION__ < 201112
+#    if defined __cplusplus && (201103 <= __cplusplus || defined _MSC_VER)
+#     define _Alignas(a) alignas (a)
+#    elif (!defined __attribute__ \
+           && ((defined __APPLE__ && defined __MACH__ \
+                ? 4 < __GNUC__ + (1 <= __GNUC_MINOR__) \
+                : __GNUC__ && !defined __ibmxl__) \
+               || (4 <= __clang_major__) \
+               || (__ia64 && (61200 <= __HP_cc || 61200 <= __HP_aCC)) \
+               || __ICC || 0x590 <= __SUNPRO_C || 0x0600 <= __xlC__))
+#     define _Alignas(a) __attribute__ ((__aligned__ (a)))
+#    elif 1300 <= _MSC_VER
+#     define _Alignas(a) __declspec (align (a))
+#    endif
+#   endif
+#   if ((defined _Alignas \
+         && !(defined __cplusplus && (201103 <= __cplusplus || defined _MSC_VER))) \
+        || (defined __STDC_VERSION__ && 201112 <= __STDC_VERSION__))
+#    define alignas _Alignas
+#   endif
+#   if (defined alignas \
+        || (defined __cplusplus && (201103 <= __cplusplus || defined _MSC_VER)))
+#    define __alignas_is_defined 1
+#   endif
+#   if _GL_STDALIGN_NEEDS_STDDEF
+#    include <stddef.h>
+#   endif
+#  endif /* _GL_STDALIGN_H */
+# endif
+#endif
+
+#ifndef HAVE_C_BOOL
+# if !defined __cplusplus && !defined __bool_true_false_are_defined
+#  if HAVE_STDBOOL_H
+#   include <stdbool.h>
+#  else
+#   if defined __SUNPRO_C
+#    error "<stdbool.h> is not usable with this configuration. To make it usable, add -D_STDC_C99= to $CC."
+#   else
+#    error "<stdbool.h> does not exist on this platform. Use gnulib module 'stdbool-c99' instead of gnulib module 'stdbool'."
+#   endif
+#  endif
+# endif
+# if !true
+#  define true (!false)
+# endif
+#endif
+
+#if (!defined HAVE_C_STATIC_ASSERT && !defined assert \
+     && (!defined __cplusplus \
+         || (__cpp_static_assert < 201411 \
+             && __GNUG__ < 6 && __clang_major__ < 6)))
+ #include <assert.h>
+ #undef/**/assert
+ /* Solaris 11.4 <assert.h> defines static_assert as a macro with 2 arguments.
+    We need it also to be invocable with a single argument.  */
+ #if defined __sun && (__STDC_VERSION__ - 0 >= 201112L) && !defined __cplusplus
+/*   #undef static_assert */
+  #define static_assert _Static_assert
+ #endif
+#endif
diff -Naur ../orig/sed-4.9/lib/alloca.h ./lib/alloca.h
--- ../orig/sed-4.9/lib/alloca.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/alloca.h	2022-12-01 17:12:54.809110800 +0300
@@ -0,0 +1,73 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Memory allocation on the stack.
+
+   Copyright (C) 1995, 1999, 2001-2004, 2006-2022 Free Software Foundation,
+   Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* Avoid using the symbol _ALLOCA_H here, as Bison assumes _ALLOCA_H
+   means there is a real alloca function.  */
+#ifndef _GL_ALLOCA_H
+#define _GL_ALLOCA_H
+
+/* alloca (N) returns a pointer to N bytes of memory
+   allocated on the stack, which will last until the function returns.
+   Use of alloca should be avoided:
+     - inside arguments of function calls - undefined behaviour,
+     - in inline functions - the allocation may actually last until the
+       calling function returns,
+     - for huge N (say, N >= 65536) - you never know how large (or small)
+       the stack is, and when the stack cannot fulfill the memory allocation
+       request, the program just crashes.
+ */
+
+#ifndef alloca
+  /* Some version of mingw have an <alloca.h> that causes trouble when
+     included after 'alloca' gets defined as a macro.  As a workaround,
+     include this <alloca.h> first and define 'alloca' as a macro afterwards
+     if needed.  */
+# if defined __GNUC__ && (defined _WIN32 && ! defined __CYGWIN__) && 0
+#  include_next <alloca.h>
+# endif
+#endif
+#ifndef alloca
+# if defined __GNUC__ || (__clang_major__ >= 4)
+#  define alloca __builtin_alloca
+# elif defined _AIX
+#  define alloca __alloca
+# elif defined _MSC_VER
+#  include <malloc.h>
+#  define alloca _alloca
+# elif defined __DECC && defined __VMS
+#  define alloca __ALLOCA
+# elif defined __TANDEM && defined _TNS_E_TARGET
+#  ifdef  __cplusplus
+extern "C"
+#  endif
+void *_alloca (unsigned short);
+#  pragma intrinsic (_alloca)
+#  define alloca _alloca
+# elif defined __MVS__
+#  include <stdlib.h>
+# else
+#  include <stddef.h>
+#  ifdef  __cplusplus
+extern "C"
+#  endif
+void *alloca (size_t);
+# endif
+#endif
+
+#endif /* _GL_ALLOCA_H */
diff -Naur ../orig/sed-4.9/lib/assert.h ./lib/assert.h
--- ../orig/sed-4.9/lib/assert.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/assert.h	2022-12-01 17:13:19.099986300 +0300
@@ -0,0 +1,282 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Substitute for and wrapper around <assert.h>
+   Copyright (C) 2011-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* Do not guard the include, since <assert.h> is supposed to define
+   the assert macro each time it is included.  */
+
+#if __GNUC__ >= 3
+
+#endif
+
+
+#include "C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\INCLUDE\assert.h"
+
+/* The definition of static_assert is copied here.  */
+/* Compile-time assert-like macros.
+
+   Copyright (C) 2005-2006, 2009-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* Written by Paul Eggert, Bruno Haible, and Jim Meyering.  */
+
+#ifndef _GL_STATIC_ASSERT_H
+#define _GL_STATIC_ASSERT_H
+
+
+/* Define _GL_HAVE__STATIC_ASSERT to 1 if _Static_assert (R, DIAGNOSTIC)
+   works as per C11.  This is supported by GCC 4.6.0+ and by clang 4+.
+
+   Define _GL_HAVE__STATIC_ASSERT1 to 1 if _Static_assert (R) works as
+   per C23.  This is supported by GCC 9.1+.
+
+   Support compilers claiming conformance to the relevant standard,
+   and also support GCC when not pedantic.  If we were willing to slow
+   'configure' down we could also use it with other compilers, but
+   since this affects only the quality of diagnostics, why bother?  */
+#ifndef __cplusplus
+# if (201112 <= __STDC_VERSION__ \
+      || (!defined __STRICT_ANSI__ \
+          && (4 < __GNUC__ + (6 <= __GNUC_MINOR__) || 5 <= __clang_major__)))
+#  define _GL_HAVE__STATIC_ASSERT 1
+# endif
+# if (202000 <= __STDC_VERSION__ \
+      || (!defined __STRICT_ANSI__ && 9 <= __GNUC__))
+#  define _GL_HAVE__STATIC_ASSERT1 1
+# endif
+#endif
+
+/* FreeBSD 9.1 <sys/cdefs.h>, included by <stddef.h> and lots of other
+   system headers, defines a conflicting _Static_assert that is no
+   better than ours; override it.  */
+#ifndef _GL_HAVE__STATIC_ASSERT
+# include <stddef.h>
+# undef _Static_assert
+#endif
+
+/* Each of these macros verifies that its argument R is nonzero.  To
+   be portable, R should be an integer constant expression.  Unlike
+   assert (R), there is no run-time overhead.
+
+   If _Static_assert works, verify (R) uses it directly.  Similarly,
+   _GL_STATIC_ASSERT_TRUE works by packaging a _Static_assert inside a struct
+   that is an operand of sizeof.
+
+   The code below uses several ideas for C++ compilers, and for C
+   compilers that do not support _Static_assert:
+
+   * The first step is ((R) ? 1 : -1).  Given an expression R, of
+     integral or boolean or floating-point type, this yields an
+     expression of integral type, whose value is later verified to be
+     constant and nonnegative.
+
+   * Next this expression W is wrapped in a type
+     struct _gl_static_assert_type {
+       unsigned int _gl_static_assert_error_if_negative: W;
+     }.
+     If W is negative, this yields a compile-time error.  No compiler can
+     deal with a bit-field of negative size.
+
+     One might think that an array size check would have the same
+     effect, that is, that the type struct { unsigned int dummy[W]; }
+     would work as well.  However, inside a function, some compilers
+     (such as C++ compilers and GNU C) allow local parameters and
+     variables inside array size expressions.  With these compilers,
+     an array size check would not properly diagnose this misuse of
+     the verify macro:
+
+       void function (int n) { verify (n < 0); }
+
+   * For the verify macro, the struct _gl_static_assert_type will need to
+     somehow be embedded into a declaration.  To be portable, this
+     declaration must declare an object, a constant, a function, or a
+     typedef name.  If the declared entity uses the type directly,
+     such as in
+
+       struct dummy {...};
+       typedef struct {...} dummy;
+       extern struct {...} *dummy;
+       extern void dummy (struct {...} *);
+       extern struct {...} *dummy (void);
+
+     two uses of the verify macro would yield colliding declarations
+     if the entity names are not disambiguated.  A workaround is to
+     attach the current line number to the entity name:
+
+       #define _GL_CONCAT0(x, y) x##y
+       #define _GL_CONCAT(x, y) _GL_CONCAT0 (x, y)
+       extern struct {...} * _GL_CONCAT (dummy, __LINE__);
+
+     But this has the problem that two invocations of verify from
+     within the same macro would collide, since the __LINE__ value
+     would be the same for both invocations.  (The GCC __COUNTER__
+     macro solves this problem, but is not portable.)
+
+     A solution is to use the sizeof operator.  It yields a number,
+     getting rid of the identity of the type.  Declarations like
+
+       extern int dummy [sizeof (struct {...})];
+       extern void dummy (int [sizeof (struct {...})]);
+       extern int (*dummy (void)) [sizeof (struct {...})];
+
+     can be repeated.
+
+   * Should the implementation use a named struct or an unnamed struct?
+     Which of the following alternatives can be used?
+
+       extern int dummy [sizeof (struct {...})];
+       extern int dummy [sizeof (struct _gl_static_assert_type {...})];
+       extern void dummy (int [sizeof (struct {...})]);
+       extern void dummy (int [sizeof (struct _gl_static_assert_type {...})]);
+       extern int (*dummy (void)) [sizeof (struct {...})];
+       extern int (*dummy (void)) [sizeof (struct _gl_static_assert_type {...})];
+
+     In the second and sixth case, the struct type is exported to the
+     outer scope; two such declarations therefore collide.  GCC warns
+     about the first, third, and fourth cases.  So the only remaining
+     possibility is the fifth case:
+
+       extern int (*dummy (void)) [sizeof (struct {...})];
+
+   * GCC warns about duplicate declarations of the dummy function if
+     -Wredundant-decls is used.  GCC 4.3 and later have a builtin
+     __COUNTER__ macro that can let us generate unique identifiers for
+     each dummy function, to suppress this warning.
+
+   * This implementation exploits the fact that older versions of GCC,
+     which do not support _Static_assert, also do not warn about the
+     last declaration mentioned above.
+
+   * GCC warns if -Wnested-externs is enabled and 'verify' is used
+     within a function body; but inside a function, you can always
+     arrange to use verify_expr instead.
+
+   * In C++, any struct definition inside sizeof is invalid.
+     Use a template type to work around the problem.  */
+
+/* Concatenate two preprocessor tokens.  */
+#define _GL_CONCAT(x, y) _GL_CONCAT0 (x, y)
+#define _GL_CONCAT0(x, y) x##y
+
+/* _GL_COUNTER is an integer, preferably one that changes each time we
+   use it.  Use __COUNTER__ if it works, falling back on __LINE__
+   otherwise.  __LINE__ isn't perfect, but it's better than a
+   constant.  */
+#if defined __COUNTER__ && __COUNTER__ != __COUNTER__
+# define _GL_COUNTER __COUNTER__
+#else
+# define _GL_COUNTER __LINE__
+#endif
+
+/* Generate a symbol with the given prefix, making it unique if
+   possible.  */
+#define _GL_GENSYM(prefix) _GL_CONCAT (prefix, _GL_COUNTER)
+
+/* Verify requirement R at compile-time, as an integer constant expression
+   that returns 1.  If R is false, fail at compile-time, preferably
+   with a diagnostic that includes the string-literal DIAGNOSTIC.  */
+
+#define _GL_STATIC_ASSERT_TRUE(R, DIAGNOSTIC) \
+   (!!sizeof (_GL_STATIC_ASSERT_TYPE (R, DIAGNOSTIC)))
+
+#ifdef __cplusplus
+# if !GNULIB_defined_struct__gl_static_assert_type
+template <int w>
+  struct _gl_static_assert_type {
+    unsigned int _gl_static_assert_error_if_negative: w;
+  };
+#  define GNULIB_defined_struct__gl_static_assert_type 1
+# endif
+# define _GL_STATIC_ASSERT_TYPE(R, DIAGNOSTIC) \
+    _gl_static_assert_type<(R) ? 1 : -1>
+#elif defined _GL_HAVE__STATIC_ASSERT
+# define _GL_STATIC_ASSERT_TYPE(R, DIAGNOSTIC) \
+    struct {                                   \
+      _Static_assert (R, DIAGNOSTIC);          \
+      int _gl_dummy;                          \
+    }
+#else
+# define _GL_STATIC_ASSERT_TYPE(R, DIAGNOSTIC) \
+    struct { unsigned int _gl_static_assert_error_if_negative: (R) ? 1 : -1; }
+#endif
+
+/* Verify requirement R at compile-time, as a declaration without a
+   trailing ';'.  If R is false, fail at compile-time.
+
+   This macro requires three or more arguments but uses at most the first
+   two, so that the _Static_assert macro optionally defined below supports
+   both the C11 two-argument syntax and the C23 one-argument syntax.
+
+   Unfortunately, unlike C11, this implementation must appear as an
+   ordinary declaration, and cannot appear inside struct { ... }.  */
+
+#if 202311 <= __STDC_VERSION__ || 200410 <= __cpp_static_assert
+# define _GL_STATIC_ASSERT(R, DIAGNOSTIC, ...) static_assert (R, DIAGNOSTIC)
+#elif defined _GL_HAVE__STATIC_ASSERT
+# define _GL_STATIC_ASSERT(R, DIAGNOSTIC, ...) _Static_assert (R, DIAGNOSTIC)
+#else
+# define _GL_STATIC_ASSERT(R, DIAGNOSTIC, ...)                                \
+    extern int (*_GL_GENSYM (_gl_static_assert_function) (void))	       \
+      [_GL_STATIC_ASSERT_TRUE (R, DIAGNOSTIC)]
+# if 4 < __GNUC__ + (6 <= __GNUC_MINOR__)
+#  pragma GCC diagnostic ignored "-Wnested-externs"
+# endif
+#endif
+
+/* _GL_STATIC_ASSERT_H is defined if this code is copied into assert.h.  */
+#ifdef _GL_STATIC_ASSERT_H
+# if !defined _GL_HAVE__STATIC_ASSERT1 && !defined _Static_assert
+#  define _Static_assert(R, ...) \
+     _GL_STATIC_ASSERT ((R), "static assertion failed", -)
+# endif
+# if (!defined static_assert \
+      && __STDC_VERSION__ < 202311 \
+      && (!defined __cplusplus \
+          || (__cpp_static_assert < 201411 \
+              && __GNUG__ < 6 && __clang_major__ < 6)))
+#  if defined __cplusplus && _MSC_VER >= 1900 && !defined __clang__
+/* MSVC 14 in C++ mode supports the two-arguments static_assert but not
+   the one-argument static_assert, and it does not support _Static_assert.
+   We have to play preprocessor tricks to distinguish the two cases.
+   Since the MSVC preprocessor is not ISO C compliant (cf.
+   <https://stackoverflow.com/questions/5134523/>), the solution is specific
+   to MSVC.  */
+#   define _GL_EXPAND(x) x
+#   define _GL_SA1(a1) static_assert ((a1), "static assertion failed")
+#   define _GL_SA2 static_assert
+#   define _GL_SA3 static_assert
+#   define _GL_SA_PICK(x1,x2,x3,x4,...) x4
+#   define static_assert(...) _GL_EXPAND(_GL_SA_PICK(__VA_ARGS__,_GL_SA3,_GL_SA2,_GL_SA1)) (__VA_ARGS__)
+#  else
+#   define static_assert _Static_assert /* C11 requires this #define. */
+#  endif
+# endif
+#endif
+
+
+#endif
diff -Naur ../orig/sed-4.9/lib/calloc.c ./lib/calloc.c
--- ../orig/sed-4.9/lib/calloc.c	2022-07-02 21:22:03.000000000 +0300
+++ ./lib/calloc.c	2022-12-01 17:13:49.426203600 +0300
@@ -35,6 +35,8 @@
 void *
 rpl_calloc (size_t n, size_t s)
 {
+  void *result;
+
   if (n == 0 || s == 0)
     n = s = 1;
 
@@ -44,7 +46,7 @@
       return NULL;
     }
 
-  void *result = calloc (n, s);
+  result = calloc (n, s);
 
 #if !HAVE_MALLOC_POSIX
   if (result == NULL)
diff -Naur ../orig/sed-4.9/lib/canonicalize-lgpl.c ./lib/canonicalize-lgpl.c
--- ../orig/sed-4.9/lib/canonicalize-lgpl.c	2022-11-06 22:05:32.000000000 +0300
+++ ./lib/canonicalize-lgpl.c	2022-12-01 17:13:49.431203900 +0300
@@ -195,6 +195,10 @@
   char const *start;
   char const *end;
   int num_links = 0;
+  char *rname;
+  bool end_in_extra_buffer = false;
+  bool failed = true;
+  idx_t prefix_len;
 
   if (name == NULL)
     {
@@ -214,13 +218,11 @@
       return NULL;
     }
 
-  char *rname = bufs->rname.data;
-  bool end_in_extra_buffer = false;
-  bool failed = true;
+  rname = bufs->rname.data;
 
   /* This is always zero for Posix hosts, but can be 2 for MS-Windows
      and MS-DOS X:/foo/bar file names.  */
-  idx_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);
+  prefix_len = FILE_SYSTEM_PREFIX_LEN (name);
 
   if (!IS_ABSOLUTE_FILE_NAME (name))
     {
@@ -255,6 +257,8 @@
 
   for ( ; *start; start = end)
     {
+      idx_t startlen;
+
       /* Skip sequence of multiple file name separators.  */
       while (ISSLASH (*start))
         ++start;
@@ -265,7 +269,7 @@
 
       /* Length of this file name component; it can be zero if a file
          name ends in '/'.  */
-      idx_t startlen = end - start;
+      startlen = end - start;
 
       if (startlen == 0)
         break;
@@ -284,6 +288,9 @@
         }
       else
         {
+          char *buf;
+          ssize_t n;
+
           if (!ISSLASH (dest[-1]))
             *dest++ = '/';
 
@@ -300,12 +307,10 @@
           dest = __mempcpy (dest, start, startlen);
           *dest = '\0';
 
-          char *buf;
-          ssize_t n;
           while (true)
             {
-              buf = bufs->link.data;
               idx_t bufsize = bufs->link.length;
+              buf = bufs->link.data;
               n = __readlink (rname, buf, bufsize - 1);
               if (n < bufsize - 1)
                 break;
@@ -314,6 +319,10 @@
             }
           if (0 <= n)
             {
+              char *extra_buf;
+              idx_t end_idx IF_LINT (= 0);
+              size_t len;
+
               if (++num_links > __eloop_threshold ())
                 {
                   __set_errno (ELOOP);
@@ -322,11 +331,10 @@
 
               buf[n] = '\0';
 
-              char *extra_buf = bufs->extra.data;
-              idx_t end_idx IF_LINT (= 0);
+              extra_buf = bufs->extra.data;
               if (end_in_extra_buffer)
                 end_idx = end - extra_buf;
-              size_t len = strlen (end);
+              len = strlen (end);
               if (INT_ADD_OVERFLOW (len, n))
                 {
                   __set_errno (ENOMEM);
@@ -429,10 +437,11 @@
 __realpath (const char *name, char *resolved)
 {
   struct realpath_bufs bufs;
+  char *result;
   scratch_buffer_init (&bufs.rname);
   scratch_buffer_init (&bufs.extra);
   scratch_buffer_init (&bufs.link);
-  char *result = realpath_stk (name, resolved, &bufs);
+  result = realpath_stk (name, resolved, &bufs);
   scratch_buffer_free (&bufs.link);
   scratch_buffer_free (&bufs.extra);
   scratch_buffer_free (&bufs.rname);
diff -Naur ../orig/sed-4.9/lib/ctype.h ./lib/ctype.h
--- ../orig/sed-4.9/lib/ctype.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/ctype.h	2022-12-01 17:14:06.131917000 +0300
@@ -0,0 +1,539 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A substitute for ISO C99 <ctype.h>, for platforms on which it is incomplete.
+
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible.  */
+
+/*
+ * ISO C 99 <ctype.h> for platforms on which it is incomplete.
+ * <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/ctype.h.html>
+ */
+
+#ifndef _GL_CTYPE_H
+
+#if __GNUC__ >= 3
+
+#endif
+
+
+/* Include the original <ctype.h>.  */
+/* The include_next requires a split double-inclusion guard.  */
+#include "C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\INCLUDE\ctype.h"
+
+#ifndef _GL_CTYPE_H
+#define _GL_CTYPE_H
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA (func, rettype, parameters);
+   is to be used when func is a Microsoft deprecated alias, on native Windows.
+   It declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to _func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_MDA (open, int, (const char *filename, int flags, ...));
+ */
+#define _GL_CXXALIAS_MDA(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_MDA (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#define _GL_CXXALIAS_MDA_CAST(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_CAST_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype_gcc, rettype_clang, parameters_and_attributes, "message")
+   is like _GL_WARN_ON_USE (function, "message"), except that in C++ mode the
+   function is declared with the given prototype, consisting of return type,
+   parameters, and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if !defined __cplusplus
+#  define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+     _GL_WARN_ON_USE (function, msg)
+# else
+#  if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes \
+  __attribute__ ((__warning__ (msg)))
+#  elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_clang function parameters_and_attributes \
+  __attribute__ ((__diagnose_if__ (1, msg, "warning")))
+#  elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes
+#  else /* Unsupported.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  endif
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+/* Return non-zero if c is a blank, i.e. a space or tab character.  */
+#if IN_SED_GNULIB_TESTS
+# if !0
+_GL_EXTERN_C int isblank (int c);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef isblank
+# if HAVE_RAW_DECL_ISBLANK
+_GL_WARN_ON_USE (isblank, "isblank is unportable - "
+                 "use gnulib module isblank for portability");
+# endif
+#endif
+static __inline int isblank(int c) {return ' ' == c || '\t' == c;}
+
+#endif /* _GL_CTYPE_H */
+#endif /* _GL_CTYPE_H */
diff -Naur ../orig/sed-4.9/lib/dfa.c ./lib/dfa.c
--- ../orig/sed-4.9/lib/dfa.c	2022-10-09 17:42:16.000000000 +0300
+++ ./lib/dfa.c	2022-12-01 17:13:49.442204500 +0300
@@ -762,14 +762,16 @@
 static void
 fillset (charclass *s)
 {
-  for (int i = 0; i < CHARCLASS_WORDS; i++)
+  int i;
+  for (i = 0; i < CHARCLASS_WORDS; i++)
     s->w[i] = CHARCLASS_WORD_MASK;
 }
 
 static void
 notset (charclass *s)
 {
-  for (int i = 0; i < CHARCLASS_WORDS; ++i)
+  int i;
+  for (i = 0; i < CHARCLASS_WORDS; ++i)
     s->w[i] = CHARCLASS_WORD_MASK & ~s->w[i];
 }
 
@@ -777,7 +779,8 @@
 equal (charclass const *s1, charclass const *s2)
 {
   charclass_word w = 0;
-  for (int i = 0; i < CHARCLASS_WORDS; i++)
+  int i;
+  for (i = 0; i < CHARCLASS_WORDS; i++)
     w |= s1->w[i] ^ s2->w[i];
   return w == 0;
 }
@@ -786,7 +789,8 @@
 emptyset (charclass const *s)
 {
   charclass_word w = 0;
-  for (int i = 0; i < CHARCLASS_WORDS; i++)
+  int i;
+  for (i = 0; i < CHARCLASS_WORDS; i++)
     w |= s->w[i];
   return w == 0;
 }
@@ -863,7 +867,8 @@
 setbit_case_fold_c (int b, charclass *c)
 {
   int ub = toupper (b);
-  for (int i = 0; i < NOTCHAR; i++)
+  int i;
+  for (i = 0; i < NOTCHAR; i++)
     if (toupper (i) == ub)
       setbit (i, c);
 }
@@ -927,7 +932,8 @@
 static const struct dfa_ctype *_GL_ATTRIBUTE_PURE
 find_pred (const char *str)
 {
-  for (int i = 0; prednames[i].name; i++)
+  int i;
+  for (i = 0; prednames[i].name; i++)
     if (str_eq (str, prednames[i].name))
       return &prednames[i];
   return NULL;
@@ -947,21 +953,21 @@
      Bit 1 = last character is a colon.
      Bit 2 = includes any other character but a colon.
      Bit 3 = includes ranges, char/equiv classes or collation elements.  */
-  int colon_warning_state;
+  int colon_warning_state, c, c1;
+  bool invert;
+  wint_t wc, wc1;
 
-  dfa->lex.brack.nchars = 0;
   charclass ccl;
+  dfa->lex.brack.nchars = 0;
   zeroset (&ccl);
-  int c = bracket_fetch_wc (dfa);
-  bool invert = c == '^';
+  c = bracket_fetch_wc (dfa);
+  invert = c == '^';
   if (invert)
     {
       c = bracket_fetch_wc (dfa);
       known_bracket_exp = dfa->localeinfo.simple;
     }
-  wint_t wc = dfa->lex.wctok;
-  int c1;
-  wint_t wc1;
+  wc = dfa->lex.wctok;
   colon_warning_state = (c == ':');
   do
     {
@@ -1016,10 +1022,12 @@
 
                   if (dfa->localeinfo.multibyte && !pred->single_byte_only)
                     known_bracket_exp = false;
-                  else
-                    for (int c2 = 0; c2 < NOTCHAR; ++c2)
+                  else {
+                    int c2;
+                    for (c2 = 0; c2 < NOTCHAR; ++c2)
                       if (pred->func (c2))
                         setbit (c2, &ccl);
+                  }
                 }
               else
                 known_bracket_exp = false;
@@ -1090,7 +1098,8 @@
                   if (dfa->localeinfo.simple
                       || (c_isdigit (c) & c_isdigit (c2)))
                     {
-                      for (int ci = c; ci <= c2; ci++)
+                      int ci;
+                      for (ci = c; ci <= c2; ci++)
                         if (dfa->syntax.case_fold && isalpha (ci))
                           setbit_case_fold_c (ci, &ccl);
                         else
@@ -1123,8 +1132,9 @@
           int n = (dfa->syntax.case_fold
                    ? case_folded_counterparts (wc, folded + 1) + 1
                    : 1);
+          int i;
           folded[0] = wc;
-          for (int i = 0; i < n; i++)
+          for (i = 0; i < n; i++)
             if (!setbit_wc (folded[i], &ccl))
               {
                 dfa->lex.brack.chars
@@ -1194,11 +1204,13 @@
      On the plus side, this avoids having a duplicate of the
      main switch inside the backslash case.  On the minus side,
      it means that just about every case tests the backslash flag.  */
-  for (int i = 0; i < 2; ++i)
+  int i;
+  for (i = 0; i < 2; ++i)
     {
+      int c;
       if (! dfa->lex.left)
         return dfa->lex.lasttok = END;
-      int c = fetch_wc (dfa);
+      c = fetch_wc (dfa);
 
       switch (c)
         {
@@ -1361,6 +1373,7 @@
           {
             char const *p = dfa->lex.ptr;
             char const *lim = p + dfa->lex.left;
+            bool invalid_content;
             dfa->lex.minrep = dfa->lex.maxrep = -1;
             for (; p != lim && c_isdigit (*p); p++)
               dfa->lex.minrep = (dfa->lex.minrep < 0
@@ -1383,7 +1396,7 @@
                                   dfa->lex.maxrep * 10 + *p - '0'));
                   }
               }
-            bool invalid_content
+            invalid_content
               = ! ((! backslash || (p != lim && *p++ == '\\'))
                    && p != lim && *p++ == '}'
                    && 0 <= dfa->lex.minrep
@@ -1453,10 +1466,12 @@
                 clrbit ('\n', &ccl);
               if (dfa->syntax.syntax_bits & RE_DOT_NOT_NULL)
                 clrbit ('\0', &ccl);
-              if (dfa->localeinfo.multibyte)
-                for (int c2 = 0; c2 < NOTCHAR; c2++)
+              if (dfa->localeinfo.multibyte) {
+                int c2;
+                for (c2 = 0; c2 < NOTCHAR; c2++)
                   if (dfa->localeinfo.sbctowc[c2] == WEOF)
                     clrbit (c2, &ccl);
+              }
               dfa->canychar = charclass_index (dfa, &ccl);
             }
           dfa->lex.laststart = false;
@@ -1473,9 +1488,10 @@
 
           if (!dfa->localeinfo.multibyte)
             {
+              int c2;
               charclass ccl;
               zeroset (&ccl);
-              for (int c2 = 0; c2 < NOTCHAR; ++c2)
+              for (c2 = 0; c2 < NOTCHAR; ++c2)
                 if (isspace (c2))
                   setbit (c2, &ccl);
               if (c == 'S')
@@ -1509,9 +1525,10 @@
 
           if (!dfa->localeinfo.multibyte)
             {
+              int c2;
               charclass ccl;
               zeroset (&ccl);
-              for (int c2 = 0; c2 < NOTCHAR; ++c2)
+              for (c2 = 0; c2 < NOTCHAR; ++c2)
                 if (dfa->syntax.sbit[c2] == CTX_LETTER)
                   setbit (c2, &ccl);
               if (c == 'W')
@@ -1557,6 +1574,9 @@
                 msg = _("stray \\ before white space");
               else
                 {
+#ifdef _WIN32
+#define snprintf _snprintf
+#endif
                   int n = snprintf (msgbuf, sizeof msgbuf,
                                     _("stray \\ before %lc"), dfa->lex.wctok);
                   msg = 0 <= n && n < sizeof msgbuf ? msgbuf : _("stray \\");
@@ -1657,7 +1677,8 @@
 
       /* Extract wide characters into alternations for better performance.
          This does not require UTF-8.  */
-      for (idx_t i = 0; i < dfa->lex.brack.nchars; i++)
+      idx_t i;
+      for (i = 0; i < dfa->lex.brack.nchars; i++)
         {
           addtok_wc (dfa, dfa->lex.brack.chars[i]);
           if (need_or)
@@ -1693,7 +1714,7 @@
   unsigned char buf[MB_LEN_MAX];
   mbstate_t s = { 0 };
   size_t stored_bytes = wcrtomb ((char *) buf, wc, &s);
-  int buflen;
+  int buflen, i;
 
   if (stored_bytes != (size_t) -1)
     buflen = stored_bytes;
@@ -1706,7 +1727,7 @@
     }
 
   addtok_mb (dfa, buf[0], buflen == 1 ? 3 : 1);
-  for (int i = 1; i < buflen; i++)
+  for (i = 1; i < buflen; i++)
     {
       addtok_mb (dfa, buf[i], i == buflen - 1 ? 2 : 0);
       addtok (dfa, CAT);
@@ -1782,6 +1803,7 @@
   /* Define the character classes that are needed below.  */
   if (dfa->utf8_anychar_classes[0] == 0)
     {
+      int i;
       charclass c = utf8_classes[0];
       if (! (dfa->syntax.syntax_bits & RE_DOT_NEWLINE))
         clrbit ('\n', &c);
@@ -1789,7 +1811,7 @@
         clrbit ('\0', &c);
       dfa->utf8_anychar_classes[0] = CSET + charclass_index (dfa, &c);
 
-      for (int i = 1; i < sizeof utf8_classes / sizeof *utf8_classes; i++)
+      for (i = 1; i < sizeof utf8_classes / sizeof *utf8_classes; i++)
         dfa->utf8_anychar_classes[i]
           = CSET + charclass_index (dfa, &utf8_classes[i]);
     }
@@ -1818,12 +1840,15 @@
   addtok (dfa, CAT);
   addtok (dfa, OR);
   addtok (dfa, dfa->utf8_anychar_classes[K]);
-  for (int i = 0; i < 3; i++)
+  {
+    int i;
+    for (i = 0; i < 3; i++)
     {
       addtok (dfa, dfa->utf8_anychar_classes[C]);
       addtok (dfa, CAT);
       addtok (dfa, OR);
     }
+  }
 }
 
 /* The grammar understood by the parser is as follows.
@@ -1898,8 +1923,8 @@
           if (dfa->syntax.case_fold)
             {
               wchar_t folded[CASE_FOLDED_BUFSIZE];
-              int n = case_folded_counterparts (dfa->lex.wctok, folded);
-              for (int i = 0; i < n; i++)
+              int i, n = case_folded_counterparts (dfa->lex.wctok, folded);
+              for (i = 0; i < n; i++)
                 {
                   addtok_wc (dfa, folded[i]);
                   addtok (dfa, OR);
@@ -1946,12 +1971,13 @@
 static void
 copytoks (struct dfa *dfa, idx_t tindex, idx_t ntokens)
 {
+  idx_t i;
   if (dfa->localeinfo.multibyte)
-    for (idx_t i = 0; i < ntokens; i++)
+    for (i = 0; i < ntokens; i++)
       addtok_mb (dfa, dfa->tokens[tindex + i],
                  dfa->multibyte_prop[tindex + i]);
   else
-    for (idx_t i = 0; i < ntokens; i++)
+    for (i = 0; i < ntokens; i++)
       addtok_mb (dfa, dfa->tokens[tindex + i], 3);
 }
 
@@ -1963,13 +1989,13 @@
          || dfa->parse.tok == PLUS || dfa->parse.tok == REPMN)
     if (dfa->parse.tok == REPMN && (dfa->lex.minrep || dfa->lex.maxrep))
       {
+        int i;
         idx_t ntokens = nsubtoks (dfa, dfa->tindex);
         idx_t tindex = dfa->tindex - ntokens;
         if (dfa->lex.maxrep < 0)
           addtok (dfa, PLUS);
         if (dfa->lex.minrep == 0)
           addtok (dfa, QMARK);
-        int i;
         for (i = 1; i < dfa->lex.minrep; i++)
           {
             copytoks (dfa, tindex, ntokens);
@@ -2086,7 +2112,7 @@
 insert (position p, position_set *s)
 {
   idx_t count = s->nelem;
-  idx_t lo = 0, hi = count;
+  idx_t lo = 0, hi = count, i;
   while (lo < hi)
     {
       idx_t mid = (lo + hi) >> 1;
@@ -2102,7 +2128,7 @@
     }
 
   s->elems = maybe_realloc (s->elems, count, &s->alloc, -1, sizeof *s->elems);
-  for (idx_t i = count; i > lo; i--)
+  for (i = count; i > lo; i--)
     s->elems[i] = s->elems[i - 1];
   s->elems[lo] = p;
   ++s->nelem;
@@ -2169,7 +2195,8 @@
 {
   if (src->nelem < 4)
     {
-      for (idx_t i = 0; i < src->nelem; i++)
+      idx_t i;
+      for (i = 0; i < src->nelem; i++)
         insert (src->elems[i], dst);
     }
    else
@@ -2228,7 +2255,7 @@
 {
   size_t hash = 0;
   int constraint = 0;
-  state_num i;
+  state_num i, j;
 
   for (i = 0; i < s->nelem; ++i)
     {
@@ -2242,7 +2269,6 @@
       if (hash != d->states[i].hash || s->nelem != d->states[i].elems.nelem
           || context != d->states[i].context)
         continue;
-      state_num j;
       for (j = 0; j < s->nelem; ++j)
         if (s->elems[j].constraint != d->states[i].elems.elems[j].constraint
             || s->elems[j].index != d->states[i].elems.elems[j].index)
@@ -2253,7 +2279,7 @@
 
 #ifdef DEBUG
   fprintf (stderr, "new state %td\n nextpos:", i);
-  for (state_num j = 0; j < s->nelem; j++)
+  for (j = 0; j < s->nelem; j++)
     {
       fprintf (stderr, " %td:", s->elems[j].index);
       prtok (d->tokens[s->elems[j].index]);
@@ -2273,7 +2299,7 @@
   fprintf (stderr, "\n");
 #endif
 
-  for (state_num j = 0; j < s->nelem; j++)
+  for (j = 0; j < s->nelem; j++)
     {
       int c = d->constraints[s->elems[j].index];
 
@@ -2313,9 +2339,10 @@
 static void
 epsclosure (struct dfa const *d, position_set *backward)
 {
+  idx_t i, j;
   position_set tmp;
   alloc_position_set (&tmp, d->nleaves);
-  for (idx_t i = 0; i < d->tindex; i++)
+  for (i = 0; i < d->tindex; i++)
     if (0 < d->follows[i].nelem)
       {
         unsigned int constraint;
@@ -2349,10 +2376,10 @@
 
         delete (i, &d->follows[i]);
 
-        for (idx_t j = 0; j < backward[i].nelem; j++)
+        for (j = 0; j < backward[i].nelem; j++)
           replace (&d->follows[backward[i].elems[j].index], i, &d->follows[i],
                    constraint, &tmp);
-        for (idx_t j = 0; j < d->follows[i].nelem; j++)
+        for (j = 0; j < d->follows[i].nelem; j++)
           replace (&backward[d->follows[i].elems[j].index], i, &backward[i],
                    NO_CONSTRAINT, &tmp);
       }
@@ -2365,9 +2392,9 @@
 static int
 charclass_context (struct dfa const *dfa, charclass const *c)
 {
-  int context = 0;
+  int context = 0, j;
 
-  for (int j = 0; j < CHARCLASS_WORDS; j++)
+  for (j = 0; j < CHARCLASS_WORDS; j++)
     {
       if (c->w[j] & dfa->syntax.newline.w[j])
         context |= CTX_NEWLINE;
@@ -2390,8 +2417,9 @@
 state_separate_contexts (struct dfa *d, position_set const *s)
 {
   int separate_contexts = 0;
+  idx_t j;
 
-  for (idx_t j = 0; j < s->nelem; j++)
+  for (j = 0; j < s->nelem; j++)
     separate_contexts |= d->separates[s->elems[j].index];
 
   return separate_contexts;
@@ -2422,9 +2450,9 @@
                  position_set *merged)
 {
   position_set *follows = d->follows;
-  idx_t nelem = 0;
+  idx_t nelem = 0, i;
 
-  for (idx_t i = 0; i < follows[tindex].nelem; i++)
+  for (i = 0; i < follows[tindex].nelem; i++)
     {
       idx_t sindex = follows[tindex].elems[i].index;
 
@@ -2491,12 +2519,13 @@
 static void
 reorder_tokens (struct dfa *d)
 {
-  idx_t nleaves = 0;
+  idx_t nleaves = 0, i, j;
   ptrdiff_t *map = xnmalloc (d->tindex, sizeof *map);
   map[0] = nleaves++;
-  for (idx_t i = 1; i < d->tindex; i++)
+  for (i = 1; i < d->tindex; i++)
     map[i] = -1;
 
+  {
   token *tokens = xnmalloc (d->nleaves, sizeof *tokens);
   position_set *follows = xnmalloc (d->nleaves, sizeof *follows);
   int *constraints = xnmalloc (d->nleaves, sizeof *constraints);
@@ -2504,7 +2533,7 @@
                           ? xnmalloc (d->nleaves, sizeof *multibyte_prop)
                           : NULL);
 
-  for (idx_t i = 0; i < d->tindex; i++)
+  for (i = 0; i < d->tindex; i++)
     {
       if (map[i] < 0)
         {
@@ -2521,7 +2550,7 @@
       if (multibyte_prop != NULL)
         multibyte_prop[map[i]] = d->multibyte_prop[i];
 
-      for (idx_t j = 0; j < d->follows[i].nelem; j++)
+      for (j = 0; j < d->follows[i].nelem; j++)
         {
           if (map[d->follows[i].elems[j].index] == -1)
             map[d->follows[i].elems[j].index] = nleaves++;
@@ -2533,7 +2562,7 @@
              sizeof *d->follows[i].elems, compare);
     }
 
-  for (idx_t i = 0; i < nleaves; i++)
+  for (i = 0; i < nleaves; i++)
     {
       d->tokens[i] = tokens[i];
       d->follows[i] = follows[i];
@@ -2549,6 +2578,7 @@
   free (follows);
   free (constraints);
   free (multibyte_prop);
+  }
   free (map);
 }
 
@@ -2556,10 +2586,11 @@
 dfaoptimize (struct dfa *d)
 {
   char *flags = xizalloc (d->tindex);
+  idx_t i, j;
 
-  for (idx_t i = 0; i < d->tindex; i++)
+  for (i = 0; i < d->tindex; i++)
     {
-      for (idx_t j = 0; j < d->follows[i].nelem; j++)
+      for (j = 0; j < d->follows[i].nelem; j++)
         {
           if (d->follows[i].elems[j].index == i)
             flags[d->follows[i].elems[j].index] |= OPT_REPEAT;
@@ -2574,19 +2605,21 @@
 
   flags[0] |= OPT_QUEUED;
 
+  {
   position_set merged0;
   position_set *merged = &merged0;
   alloc_position_set (merged, d->nleaves);
 
   d->constraints = xicalloc (d->tindex, sizeof *d->constraints);
 
-  for (idx_t i = 0; i < d->tindex; i++)
+  for (i = 0; i < d->tindex; i++)
     if (flags[i] & OPT_QUEUED)
       merge_nfa_state (d, i, flags, merged);
 
   reorder_tokens (d);
 
   free (merged->elems);
+  }
   free (flags);
 }
 
@@ -2665,13 +2698,15 @@
   } *stkalloc = xnmalloc (d->depth, sizeof *stkalloc), *stk = stkalloc;
 
   position_set merged;          /* Result of merging sets.  */
+  idx_t tindex, i, j;
+  position_set *backward;
 
   addtok (d, CAT);
-  idx_t tindex = d->tindex;
+  tindex = d->tindex;
 
 #ifdef DEBUG
   fprintf (stderr, "dfaanalyze:\n");
-  for (idx_t i = 0; i < tindex; i++)
+  for (i = 0; i < tindex; i++)
     {
       fprintf (stderr, " %td:", i);
       prtok (d->tokens[i]);
@@ -2682,10 +2717,10 @@
   d->searchflag = searchflag;
   alloc_position_set (&merged, d->nleaves);
   d->follows = xicalloc (tindex, sizeof *d->follows);
-  position_set *backward
+  backward
     = d->epsilon ? xicalloc (tindex, sizeof *backward) : NULL;
 
-  for (idx_t i = 0; i < tindex; i++)
+  for (i = 0; i < tindex; i++)
     {
       switch (d->tokens[i])
         {
@@ -2704,9 +2739,10 @@
              set of every element in the firstpos.  */
           if (d->epsilon)
             {
+              position *p;
               tmp.elems = lastpos - stk[-1].nlastpos;
               tmp.nelem = stk[-1].nlastpos;
-              for (position *p = firstpos - stk[-1].nfirstpos;
+              for (p = firstpos - stk[-1].nfirstpos;
                    p < firstpos; p++)
                 merge2 (&backward[p->index], &tmp, &merged);
             }
@@ -2714,9 +2750,10 @@
           /* Every element in the firstpos of the argument is in the follow
              of every element in the lastpos.  */
           {
+            position *p;
             tmp.elems = firstpos - stk[-1].nfirstpos;
             tmp.nelem = stk[-1].nfirstpos;
-            for (position *p = lastpos - stk[-1].nlastpos; p < lastpos; p++)
+            for (p = lastpos - stk[-1].nlastpos; p < lastpos; p++)
               merge2 (&d->follows[p->index], &tmp, &merged);
           }
           FALLTHROUGH;
@@ -2732,9 +2769,10 @@
              second argument.  */
           if (backward)
             {
+              position *p;
               tmp.nelem = stk[-2].nlastpos;
               tmp.elems = lastpos - stk[-1].nlastpos - stk[-2].nlastpos;
-              for (position *p = firstpos - stk[-1].nfirstpos;
+              for (p = firstpos - stk[-1].nfirstpos;
                    p < firstpos; p++)
                 merge2 (&backward[p->index], &tmp, &merged);
             }
@@ -2742,10 +2780,11 @@
           /* Every element in the firstpos of the second argument is in the
              follow of every element in the lastpos of the first argument.  */
           {
+            position *plim, *p;
             tmp.nelem = stk[-1].nfirstpos;
             tmp.elems = firstpos - stk[-1].nfirstpos;
-            for (position *plim = lastpos - stk[-1].nlastpos,
-                   *p = plim - stk[-2].nlastpos;
+            for (plim = lastpos - stk[-1].nlastpos,
+                   p = plim - stk[-2].nlastpos;
                  p < plim; p++)
               merge2 (&d->follows[p->index], &tmp, &merged);
           }
@@ -2764,7 +2803,7 @@
           else
             {
               position *p = lastpos - stk[-1].nlastpos - stk[-2].nlastpos;
-              for (idx_t j = 0; j < stk[-1].nlastpos; j++)
+              for (j = 0; j < stk[-1].nlastpos; j++)
                 p[j] = p[j + stk[-2].nlastpos];
               lastpos -= stk[-2].nlastpos;
               stk[-2].nlastpos = stk[-1].nlastpos;
@@ -2813,13 +2852,13 @@
       fprintf (stderr,
                stk[-1].nullable ? " nullable: yes\n" : " nullable: no\n");
       fprintf (stderr, " firstpos:");
-      for (idx_t j = 0; j < stk[-1].nfirstpos; j++)
+      for (j = 0; j < stk[-1].nfirstpos; j++)
         {
           fprintf (stderr, " %td:", firstpos[j - stk[-1].nfirstpos].index);
           prtok (d->tokens[firstpos[j - stk[-1].nfirstpos].index]);
         }
       fprintf (stderr, "\n lastpos:");
-      for (idx_t j = 0; j < stk[-1].nlastpos; j++)
+      for (j = 0; j < stk[-1].nlastpos; j++)
         {
           fprintf (stderr, " %td:", lastpos[j - stk[-1].nlastpos].index);
           prtok (d->tokens[lastpos[j - stk[-1].nlastpos].index]);
@@ -2834,7 +2873,7 @@
          replace it with its epsilon closure.  */
       epsclosure (d, backward);
 
-      for (idx_t i = 0; i < tindex; i++)
+      for (i = 0; i < tindex; i++)
         free (backward[i].elems);
       free (backward);
     }
@@ -2842,7 +2881,7 @@
   dfaoptimize (d);
 
 #ifdef DEBUG
-  for (idx_t i = 0; i < tindex; i++)
+  for (i = 0; i < tindex; i++)
     if (d->tokens[i] == BEG || d->tokens[i] < NOTCHAR
         || d->tokens[i] == BACKREF || d->tokens[i] == ANYCHAR
         || d->tokens[i] == MBCSET || d->tokens[i] >= CSET)
@@ -2850,7 +2889,7 @@
         fprintf (stderr, "follows(%td:", i);
         prtok (d->tokens[i]);
         fprintf (stderr, "):");
-        for (idx_t j = 0; j < d->follows[i].nelem; j++)
+        for (j = 0; j < d->follows[i].nelem; j++)
           {
             fprintf (stderr, " %td:", d->follows[i].elems[j].index);
             prtok (d->tokens[d->follows[i].elems[j].index]);
@@ -2868,14 +2907,14 @@
 
   d->separates = xicalloc (tindex, sizeof *d->separates);
 
-  for (idx_t i = 0; i < tindex; i++)
+  for (i = 0; i < tindex; i++)
     {
       if (prev_newline_dependent (d->constraints[i]))
         d->separates[i] |= CTX_NEWLINE;
       if (prev_letter_dependent (d->constraints[i]))
         d->separates[i] |= CTX_LETTER;
 
-      for (idx_t j = 0; j < d->follows[i].nelem; j++)
+      for (j = 0; j < d->follows[i].nelem; j++)
         {
           if (prev_newline_dependent (d->follows[i].elems[j].constraint))
             d->separates[i] |= CTX_NEWLINE;
@@ -2884,6 +2923,7 @@
         }
     }
 
+  {
   /* Context wanted by some position.  */
   int separate_contexts = state_separate_contexts (d, &tmp);
 
@@ -2896,6 +2936,7 @@
     d->min_trcount = state_index (d, &tmp, CTX_LETTER);
   d->min_trcount++;
   d->trcount = 0;
+  }
 
   free (posalloc);
   free (stkalloc);
@@ -2912,11 +2953,12 @@
     {
       state_num **realtrans = d->trans ? d->trans - 2 : NULL;
       idx_t newalloc1 = realtrans ? d->tralloc + 2 : 0;
+      idx_t newalloc;
       realtrans = xpalloc (realtrans, &newalloc1, d->sindex - oldalloc,
                            -1, sizeof *realtrans);
       realtrans[0] = realtrans[1] = NULL;
       d->trans = realtrans + 2;
-      idx_t newalloc = d->tralloc = newalloc1 - 2;
+      newalloc = d->tralloc = newalloc1 - 2;
       d->fails = xreallocarray (d->fails, newalloc, sizeof *d->fails);
       d->success = xreallocarray (d->success, newalloc, sizeof *d->success);
       d->newlines = xreallocarray (d->newlines, newalloc, sizeof *d->newlines);
@@ -2974,6 +3016,7 @@
 static state_num
 build_state (state_num s, struct dfa *d, unsigned char uc)
 {
+  idx_t i, j, k;
   position_set follows;         /* Union of the follows for each
                                    position of the current state.  */
   position_set group;           /* Positions that match the input char.  */
@@ -2981,6 +3024,7 @@
   state_num state;              /* New state.  */
   state_num state_newline;      /* New state on a newline transition.  */
   state_num state_letter;       /* New state on a letter transition.  */
+  charclass label;
 
 #ifdef DEBUG
   fprintf (stderr, "build state %td\n", s);
@@ -2992,17 +3036,19 @@
 
   if (!trans)
     {
+      int x;
       /* MAX_TRCOUNT is an arbitrary upper limit on the number of
          transition tables that can exist at once, other than for
          initial states.  Often-used transition tables are quickly
          rebuilt, whereas rarely-used ones are cleared away.  */
       if (MAX_TRCOUNT <= d->trcount)
         {
-          for (state_num i = d->min_trcount; i < d->tralloc; i++)
+          state_num n;
+          for (n = d->min_trcount; n < d->tralloc; n++)
             {
-              free (d->trans[i]);
-              free (d->fails[i]);
-              d->trans[i] = d->fails[i] = NULL;
+              free (d->trans[n]);
+              free (d->fails[n]);
+              d->trans[n] = d->fails[n] = NULL;
             }
           d->trcount = 0;
         }
@@ -3012,8 +3058,8 @@
 
       /* Fill transition table with a default value which means that the
          transited state has not been calculated yet.  */
-      for (int i = 0; i < NOTCHAR; i++)
-        trans[i] = -2;
+      for (x = 0; x < NOTCHAR; x++)
+        trans[x] = -2;
     }
 
   /* Set up the success bits for this state.  */
@@ -3029,8 +3075,8 @@
 
   /* Find the union of the follows of the positions of the group.
      This is a hideously inefficient loop.  Fix it someday.  */
-  for (idx_t j = 0; j < d->states[s].elems.nelem; j++)
-    for (idx_t k = 0;
+  for (j = 0; j < d->states[s].elems.nelem; j++)
+    for (k = 0;
          k < d->follows[d->states[s].elems.elems[j].index].nelem; ++k)
       insert (d->follows[d->states[s].elems.elems[j].index].elems[k],
               &follows);
@@ -3039,10 +3085,9 @@
   alloc_position_set (&group, d->nleaves);
 
   /* The group's label.  */
-  charclass label;
   fillset (&label);
 
-  for (idx_t i = 0; i < follows.nelem; i++)
+  for (i = 0; i < follows.nelem; i++)
     {
       charclass matches;            /* Set of matching characters.  */
       position pos = follows.elems[i];
@@ -3087,18 +3132,19 @@
          they fail in the current context.  */
       if (pos.constraint != NO_CONSTRAINT)
         {
+          int x;
           if (!succeeds_in_context (pos.constraint,
                                     d->states[s].context, CTX_NEWLINE))
-            for (int j = 0; j < CHARCLASS_WORDS; j++)
-              matches.w[j] &= ~d->syntax.newline.w[j];
+            for (x = 0; x < CHARCLASS_WORDS; x++)
+              matches.w[x] &= ~d->syntax.newline.w[x];
           if (!succeeds_in_context (pos.constraint,
                                     d->states[s].context, CTX_LETTER))
-            for (int j = 0; j < CHARCLASS_WORDS; ++j)
-              matches.w[j] &= ~d->syntax.letters.w[j];
+            for (x = 0; x < CHARCLASS_WORDS; ++x)
+              matches.w[x] &= ~d->syntax.letters.w[x];
           if (!succeeds_in_context (pos.constraint,
                                     d->states[s].context, CTX_NONE))
-            for (int j = 0; j < CHARCLASS_WORDS; ++j)
-              matches.w[j] &= d->syntax.letters.w[j] | d->syntax.newline.w[j];
+            for (x = 0; x < CHARCLASS_WORDS; ++x)
+              matches.w[x] &= d->syntax.letters.w[x] | d->syntax.newline.w[x];
 
           /* If there are no characters left, there's no point in going on.  */
           if (emptyset (&matches))
@@ -3115,22 +3161,27 @@
       fprintf (stderr, " nextpos %td:", pos.index);
       prtok (d->tokens[pos.index]);
       fprintf (stderr, " of");
-      for (unsigned j = 0; j < NOTCHAR; j++)
-        if (tstbit (j, &matches))
-          fprintf (stderr, " 0x%02x", j);
+      {
+      unsigned x;
+      for (x = 0; x < NOTCHAR; x++)
+        if (tstbit (x, &matches))
+          fprintf (stderr, " 0x%02x", x);
+      }
       fprintf (stderr, "\n");
 #endif
 
       if (matched)
         {
-          for (int k = 0; k < CHARCLASS_WORDS; ++k)
-            label.w[k] &= matches.w[k];
+          int x;
+          for (x = 0; x < CHARCLASS_WORDS; ++x)
+            label.w[x] &= matches.w[x];
           append (pos, &group);
         }
       else
         {
-          for (int k = 0; k < CHARCLASS_WORDS; ++k)
-            label.w[k] &= ~matches.w[k];
+          int x;
+          for (x = 0; x < CHARCLASS_WORDS; ++x)
+            label.w[x] &= ~matches.w[x];
         }
     }
 
@@ -3138,6 +3189,8 @@
 
   if (group.nelem > 0)
     {
+      int possible_contexts;
+      int separate_contexts;
       /* If we are building a searching matcher, throw in the positions
          of state 0 as well, if possible.  */
       if (d->searchflag)
@@ -3163,7 +3216,7 @@
           if (!mergeit)
             {
               mergeit = true;
-              for (idx_t j = 0; mergeit && j < group.nelem; j++)
+              for (j = 0; mergeit && j < group.nelem; j++)
                 mergeit &= d->multibyte_prop[group.elems[j].index];
             }
           if (mergeit)
@@ -3173,8 +3226,8 @@
       /* Find out if the new state will want any context information,
          by calculating possible contexts that the group can match,
          and separate contexts that the new state wants to know.  */
-      int possible_contexts = charclass_context (d, &label);
-      int separate_contexts = state_separate_contexts (d, &group);
+      possible_contexts = charclass_context (d, &label);
+      separate_contexts = state_separate_contexts (d, &group);
 
       /* Find the state(s) corresponding to the union of the follows.  */
       if (possible_contexts & ~separate_contexts)
@@ -3211,29 +3264,35 @@
     }
 
   /* Set the transitions for each character in the label.  */
-  for (int i = 0; i < NOTCHAR; i++)
-    if (tstbit (i, &label))
-      switch (d->syntax.sbit[i])
+  {
+  int x;
+  for (x = 0; x < NOTCHAR; x++)
+    if (tstbit (x, &label))
+      switch (d->syntax.sbit[x])
         {
         case CTX_NEWLINE:
-          trans[i] = state_newline;
+          trans[x] = state_newline;
           break;
         case CTX_LETTER:
-          trans[i] = state_letter;
+          trans[x] = state_letter;
           break;
         default:
-          trans[i] = state;
+          trans[x] = state;
           break;
         }
+  }
 
 #ifdef DEBUG
   fprintf (stderr, "trans table %td", s);
-  for (int i = 0; i < NOTCHAR; ++i)
+  {
+  int x;
+  for (int x = 0; x < NOTCHAR; ++x)
     {
-      if (!(i & 0xf))
+      if (!(x & 0xf))
         fprintf (stderr, "\n");
-      fprintf (stderr, " %2td", trans[i]);
+      fprintf (stderr, " %2td", trans[x]);
     }
+  }
   fprintf (stderr, "\n");
 #endif
 
@@ -3296,13 +3355,14 @@
 
   int mbclen = mbs_to_wchar (&wc, (char const *) *pp, end - *pp, d);
 
+  state_num s1 = s;
+  int mbci;
+
   /* This state has some operators which can match a multibyte character.  */
   d->mb_follows.nelem = 0;
 
   /* Calculate the state which can be reached from the state 's' by
      consuming 'mbclen' single bytes from the buffer.  */
-  state_num s1 = s;
-  int mbci;
   for (mbci = 0; mbci < mbclen && (mbci == 0 || d->min_trcount <= s); mbci++)
     s = transit_state_singlebyte (d, s, pp);
   *pp += mbclen - mbci;
@@ -3320,14 +3380,14 @@
     {
       if (MAX_TRCOUNT <= d->mb_trcount)
         {
-          state_num s3;
+          state_num s3, i;
           for (s3 = -1; s3 < d->tralloc; s3++)
             {
               free (d->mb_trans[s3]);
               d->mb_trans[s3] = NULL;
             }
 
-          for (state_num i = 0; i < d->sindex; i++)
+          for (i = 0; i < d->sindex; i++)
             d->states[i].mb_trindex = -1;
           d->mb_trcount = 0;
         }
@@ -3336,10 +3396,11 @@
 
   if (! d->mb_trans[s])
     {
+      int i;
       enum { TRANSPTR_SIZE = sizeof *d->mb_trans[s] };
       enum { TRANSALLOC_SIZE = MAX_TRCOUNT * TRANSPTR_SIZE };
       d->mb_trans[s] = xmalloc (TRANSALLOC_SIZE);
-      for (int i = 0; i < MAX_TRCOUNT; i++)
+      for (i = 0; i < MAX_TRCOUNT; i++)
         d->mb_trans[s][i] = -1;
     }
   else if (d->mb_trans[s][d->states[s1].mb_trindex] >= 0)
@@ -3350,6 +3411,7 @@
   else
     merge (&d->states[s1].mbps, &d->states[s].elems, &d->mb_follows);
 
+  {
   int separate_contexts = state_separate_contexts (d, &d->mb_follows);
   state_num s2 = state_index (d, &d->mb_follows, separate_contexts ^ CTX_ANY);
   realloc_trans_if_necessary (d);
@@ -3357,6 +3419,7 @@
   d->mb_trans[s][d->states[s1].mb_trindex] = s2;
 
   return s2;
+  }
 }
 
 /* The initial state may encounter a byte which is not a single byte character
@@ -3415,7 +3478,8 @@
 {
   if (MAX_TRCOUNT <= d->sindex)
     {
-      for (state_num s = d->min_trcount; s < d->sindex; s++)
+      state_num s;
+      for (s = d->min_trcount; s < d->sindex; s++)
         {
           free (d->states[s].elems.elems);
           free (d->states[s].mbps.elems);
@@ -3424,7 +3488,7 @@
 
       if (d->trans)
         {
-          for (state_num s = 0; s < d->tralloc; s++)
+          for (s = 0; s < d->tralloc; s++)
             {
               free (d->trans[s]);
               free (d->fails[s]);
@@ -3435,12 +3499,12 @@
 
       if (d->localeinfo.multibyte && d->mb_trans)
         {
-          for (state_num s = -1; s < d->tralloc; s++)
+          for (s = -1; s < d->tralloc; s++)
             {
               free (d->mb_trans[s]);
               d->mb_trans[s] = NULL;
             }
-          for (state_num s = 0; s < d->min_trcount; s++)
+          for (s = 0; s < d->min_trcount; s++)
             d->states[s].mb_trindex = -1;
           d->mb_trcount = 0;
         }
@@ -3449,12 +3513,14 @@
   if (!d->tralloc)
     realloc_trans_if_necessary (d);
 
+  {
   /* Current state.  */
   state_num s = 0, s1 = 0;
 
   /* Current input character.  */
   unsigned char const *p = (unsigned char const *) begin;
   unsigned char const *mbp = p;
+  idx_t nlcount = 0;
 
   /* Copy of d->trans so it can be optimized into a register.  */
   state_num **trans = d->trans;
@@ -3469,7 +3535,6 @@
         alloc_position_set (&d->mb_follows, d->nleaves);
     }
 
-  idx_t nlcount = 0;
   for (;;)
     {
       state_num *t;
@@ -3587,6 +3652,7 @@
     *count += nlcount;
   *end = saved_end;
   return (char *) p;
+  }
 }
 
 /* Specialized versions of dfaexec for multibyte and single-byte cases.
@@ -3659,7 +3725,8 @@
 bool
 dfasupported (struct dfa const *d)
 {
-  for (idx_t i = 0; i < d->tindex; i++)
+  idx_t i;
+  for (i = 0; i < d->tindex; i++)
     {
       switch (d->tokens[i])
         {
@@ -3686,8 +3753,10 @@
   if (!d->localeinfo.using_utf8)
     return;
 
+  {
   bool have_backref = false;
-  for (idx_t i = 0; i < d->tindex; i++)
+  idx_t i;
+  for (i = 0; i < d->tindex; i++)
     {
       switch (d->tokens[i])
         {
@@ -3712,6 +3781,7 @@
       free (d->superset);
       d->superset = NULL;
     }
+  }
 
   free_mbdata (d);
   d->localeinfo.multibyte = false;
@@ -3723,6 +3793,9 @@
 dfassbuild (struct dfa *d)
 {
   struct dfa *sup = dfaalloc ();
+  bool have_achar = false;
+  bool have_nchar = false;
+  idx_t i, j;
 
   *sup = *d;
   sup->localeinfo.multibyte = false;
@@ -3750,10 +3823,7 @@
   sup->tokens = xnmalloc (d->tindex, 2 * sizeof *sup->tokens);
   sup->talloc = d->tindex * 2;
 
-  bool have_achar = false;
-  bool have_nchar = false;
-  idx_t j;
-  for (idx_t i = j = 0; i < d->tindex; i++)
+  for (i = j = 0; i < d->tindex; i++)
     {
       switch (d->tokens[i])
         {
@@ -3834,6 +3904,7 @@
 void
 dfafree (struct dfa *d)
 {
+  idx_t i;
   free (d->charclasses);
   free (d->tokens);
 
@@ -3843,7 +3914,7 @@
   free (d->constraints);
   free (d->separates);
 
-  for (idx_t i = 0; i < d->sindex; i++)
+  for (i = 0; i < d->sindex; i++)
     {
       free (d->states[i].elems.elems);
       free (d->states[i].mbps.elems);
@@ -3852,14 +3923,14 @@
 
   if (d->follows)
     {
-      for (idx_t i = 0; i < d->tindex; i++)
+      for (i = 0; i < d->tindex; i++)
         free (d->follows[i].elems);
       free (d->follows);
     }
 
   if (d->trans)
     {
-      for (idx_t i = 0; i < d->tralloc; i++)
+      for (i = 0; i < d->tralloc; i++)
         {
           free (d->trans[i]);
           free (d->fails[i]);
@@ -3966,10 +4037,12 @@
   idx_t newsize = strlen (new);
   if (newsize == 0)
     return old;
+  {
   idx_t oldsize = strlen (old);
   char *result = xirealloc (old, oldsize + newsize + 1);
   memcpy (result + oldsize, new, newsize + 1);
   return result;
+  }
 }
 
 static void
@@ -3983,7 +4056,7 @@
 enlistnew (char **cpp, char *new)
 {
   /* Is there already something in the list that's new (or longer)?  */
-  idx_t i;
+  idx_t i, j;
   for (i = 0; cpp[i] != NULL; i++)
     if (strstr (cpp[i], new) != NULL)
       {
@@ -3991,7 +4064,7 @@
         return cpp;
       }
   /* Eliminate any obsoleted strings.  */
-  for (idx_t j = 0; cpp[j] != NULL; )
+  for (j = 0; cpp[j] != NULL; )
     if (strstr (new, cpp[j]) == NULL)
       ++j;
     else
@@ -4021,8 +4094,9 @@
 comsubs (char *left, char const *right)
 {
   char **cpp = xzalloc (sizeof *cpp);
+  char *lcp;
 
-  for (char *lcp = left; *lcp != '\0'; lcp++)
+  for (lcp = left; *lcp != '\0'; lcp++)
     {
       idx_t len = 0;
       char *rcp = strchr (right, *lcp);
@@ -4055,10 +4129,11 @@
 inboth (char **left, char **right)
 {
   char **both = xzalloc (sizeof *both);
+  idx_t lnum, rnum;
 
-  for (idx_t lnum = 0; left[lnum] != NULL; lnum++)
+  for (lnum = 0; left[lnum] != NULL; lnum++)
     {
-      for (idx_t rnum = 0; right[rnum] != NULL; rnum++)
+      for (rnum = 0; right[rnum] != NULL; rnum++)
         {
           char **temp = comsubs (left[lnum], right[rnum]);
           both = addlists (both, temp);
@@ -4128,8 +4203,9 @@
   bool need_begline = false;
   bool need_endline = false;
   bool case_fold_unibyte = d->syntax.case_fold & !d->localeinfo.multibyte;
+  idx_t ri;
 
-  for (idx_t ri = 1; ri + 1 < d->tindex; ri++)
+  for (ri = 1; ri + 1 < d->tindex; ri++)
     {
       token t = d->tokens[ri];
       switch (t)
@@ -4168,11 +4244,11 @@
         case OR:
           {
             char **new;
-            must *rmp = mp;
+            idx_t i, j, ln, rn, n;
+            must *rmp = mp, *lmp;
             assume_nonnull (rmp);
-            must *lmp = mp = mp->prev;
+            lmp = mp = mp->prev;
             assume_nonnull (lmp);
-            idx_t j, ln, rn, n;
 
             /* Guaranteed to be.  Unlikely, but ...  */
             if (str_eq (lmp->is, rmp->is))
@@ -4187,7 +4263,7 @@
                 lmp->endline = false;
               }
             /* Left side--easy */
-            idx_t i = 0;
+            i = 0;
             while (lmp->left[i] != '\0' && lmp->left[i] == rmp->left[i])
               ++i;
             lmp->left[i] = '\0';
@@ -4216,10 +4292,11 @@
           mp->is[0] = '\0';
           break;
 
-        case END:
+        case END: {
+          idx_t i;
           assume_nonnull (mp);
           assert (!mp->prev);
-          for (idx_t i = 0; mp->in[i] != NULL; i++)
+          for (i = 0; mp->in[i] != NULL; i++)
             if (strlen (mp->in[i]) > strlen (result))
               result = mp->in[i];
           if (str_eq (result, mp->is))
@@ -4231,12 +4308,13 @@
               endline = mp->endline;
             }
           goto done;
+        }
 
         case CAT:
           {
-            must *rmp = mp;
+            must *rmp = mp, *lmp;
             assume_nonnull (rmp);
-            must *lmp = mp = mp->prev;
+            lmp = mp = mp->prev;
             assume_nonnull (lmp);
 
             /* In.  Everything in left, plus everything in
@@ -4310,6 +4388,7 @@
                 }
             }
 
+          {
           idx_t rj = ri + 2;
           if (d->tokens[ri + 1] == CAT)
             {
@@ -4325,6 +4404,7 @@
           mp->is[0] = mp->left[0] = mp->right[0]
             = case_fold_unibyte ? toupper (t) : t;
 
+          {
           idx_t i;
           for (i = 1; ri + 2 < rj; i++)
             {
@@ -4335,11 +4415,14 @@
             }
           mp->is[i] = mp->left[i] = mp->right[i] = '\0';
           mp->in = enlist (mp->in, mp->is, i);
+          }
+          }
           break;
         }
     }
  done:;
 
+  {
   struct dfamust *dm = NULL;
   if (*result)
     {
@@ -4358,6 +4441,7 @@
     }
 
   return dm;
+  }
 }
 
 void
@@ -4377,6 +4461,7 @@
 dfasyntax (struct dfa *dfa, struct localeinfo const *linfo,
            reg_syntax_t bits, int dfaopts)
 {
+  int i;
   memset (dfa, 0, offsetof (struct dfa, dfaexec));
   dfa->dfaexec = linfo->multibyte ? dfaexec_mb : dfaexec_sb;
   dfa->localeinfo = *linfo;
@@ -4390,7 +4475,7 @@
   dfa->syntax.syntax_bits = bits;
   dfa->syntax.dfaopts = dfaopts;
 
-  for (int i = CHAR_MIN; i <= CHAR_MAX; ++i)
+  for (i = CHAR_MIN; i <= CHAR_MAX; ++i)
     {
       unsigned char uc = i;
 
diff -Naur ../orig/sed-4.9/lib/errno.h ./lib/errno.h
--- ../orig/sed-4.9/lib/errno.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/errno.h	2022-12-01 17:13:19.109986300 +0300
@@ -0,0 +1,280 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A POSIX-like <errno.h>.
+
+   Copyright (C) 2008-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_ERRNO_H
+
+#if __GNUC__ >= 3
+
+#endif
+
+
+/* The include_next requires a split double-inclusion guard.  */
+#include "C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\INCLUDE\errno.h"
+
+#ifndef _GL_ERRNO_H
+#define _GL_ERRNO_H
+
+
+/* On native Windows platforms, many macros are not defined.  */
+# if defined _WIN32 && ! defined __CYGWIN__
+
+/* These are the same values as defined by MSVC 10, for interoperability.  */
+
+#  ifndef ENOMSG
+#   define ENOMSG    122
+#   define GNULIB_defined_ENOMSG 1
+#  endif
+
+#  ifndef EIDRM
+#   define EIDRM     111
+#   define GNULIB_defined_EIDRM 1
+#  endif
+
+#  ifndef ENOLINK
+#   define ENOLINK   121
+#   define GNULIB_defined_ENOLINK 1
+#  endif
+
+#  ifndef EPROTO
+#   define EPROTO    134
+#   define GNULIB_defined_EPROTO 1
+#  endif
+
+#  ifndef EBADMSG
+#   define EBADMSG   104
+#   define GNULIB_defined_EBADMSG 1
+#  endif
+
+#  ifndef EOVERFLOW
+#   define EOVERFLOW 132
+#   define GNULIB_defined_EOVERFLOW 1
+#  endif
+
+#  ifndef ENOTSUP
+#   define ENOTSUP   129
+#   define GNULIB_defined_ENOTSUP 1
+#  endif
+
+#  ifndef ENETRESET
+#   define ENETRESET 117
+#   define GNULIB_defined_ENETRESET 1
+#  endif
+
+#  ifndef ECONNABORTED
+#   define ECONNABORTED 106
+#   define GNULIB_defined_ECONNABORTED 1
+#  endif
+
+#  ifndef ECANCELED
+#   define ECANCELED 105
+#   define GNULIB_defined_ECANCELED 1
+#  endif
+
+#  ifndef EOWNERDEAD
+#   define EOWNERDEAD 133
+#   define GNULIB_defined_EOWNERDEAD 1
+#  endif
+
+#  ifndef ENOTRECOVERABLE
+#   define ENOTRECOVERABLE 127
+#   define GNULIB_defined_ENOTRECOVERABLE 1
+#  endif
+
+#  ifndef EINPROGRESS
+#   define EINPROGRESS     112
+#   define EALREADY        103
+#   define ENOTSOCK        128
+#   define EDESTADDRREQ    109
+#   define EMSGSIZE        115
+#   define EPROTOTYPE      136
+#   define ENOPROTOOPT     123
+#   define EPROTONOSUPPORT 135
+#   define EOPNOTSUPP      130
+#   define EAFNOSUPPORT    102
+#   define EADDRINUSE      100
+#   define EADDRNOTAVAIL   101
+#   define ENETDOWN        116
+#   define ENETUNREACH     118
+#   define ECONNRESET      108
+#   define ENOBUFS         119
+#   define EISCONN         113
+#   define ENOTCONN        126
+#   define ETIMEDOUT       138
+#   define ECONNREFUSED    107
+#   define ELOOP           114
+#   define EHOSTUNREACH    110
+#   define EWOULDBLOCK     140
+#   define GNULIB_defined_ESOCK 1
+#  endif
+
+#  ifndef ETXTBSY
+#   define ETXTBSY         139
+#   define ENODATA         120  /* not required by POSIX */
+#   define ENOSR           124  /* not required by POSIX */
+#   define ENOSTR          125  /* not required by POSIX */
+#   define ETIME           137  /* not required by POSIX */
+#   define EOTHER          131  /* not required by POSIX */
+#   define GNULIB_defined_ESTREAMS 1
+#  endif
+
+/* These are intentionally the same values as the WSA* error numbers, defined
+   in <winsock2.h>.  */
+#  define ESOCKTNOSUPPORT 10044  /* not required by POSIX */
+#  define EPFNOSUPPORT    10046  /* not required by POSIX */
+#  define ESHUTDOWN       10058  /* not required by POSIX */
+#  define ETOOMANYREFS    10059  /* not required by POSIX */
+#  define EHOSTDOWN       10064  /* not required by POSIX */
+#  define EPROCLIM        10067  /* not required by POSIX */
+#  define EUSERS          10068  /* not required by POSIX */
+#  define EDQUOT          10069
+#  define ESTALE          10070
+#  define EREMOTE         10071  /* not required by POSIX */
+#  define GNULIB_defined_EWINSOCK 1
+
+# endif
+
+
+/* On OSF/1 5.1, when _XOPEN_SOURCE_EXTENDED is not defined, the macros
+   EMULTIHOP, ENOLINK, EOVERFLOW are not defined.  */
+# if 0
+#  define EMULTIHOP 
+#  define GNULIB_defined_EMULTIHOP 1
+# endif
+# if 0
+#  define ENOLINK   
+#  define GNULIB_defined_ENOLINK 1
+# endif
+# if 0
+#  define EOVERFLOW 
+#  define GNULIB_defined_EOVERFLOW 1
+# endif
+
+
+/* On OpenBSD 4.0 and on native Windows, the macros ENOMSG, EIDRM, ENOLINK,
+   EPROTO, EMULTIHOP, EBADMSG, EOVERFLOW, ENOTSUP, ECANCELED are not defined.
+   Likewise, on NonStop Kernel, EDQUOT is not defined.
+   Define them here.  Values >= 2000 seem safe to use: Solaris ESTALE = 151,
+   HP-UX EWOULDBLOCK = 246, IRIX EDQUOT = 1133.
+
+   Note: When one of these systems defines some of these macros some day,
+   binaries will have to be recompiled so that they recognizes the new
+   errno values from the system.  */
+
+# ifndef ENOMSG
+#  define ENOMSG    2000
+#  define GNULIB_defined_ENOMSG 1
+# endif
+
+# ifndef EIDRM
+#  define EIDRM     2001
+#  define GNULIB_defined_EIDRM 1
+# endif
+
+# ifndef ENOLINK
+#  define ENOLINK   2002
+#  define GNULIB_defined_ENOLINK 1
+# endif
+
+# ifndef EPROTO
+#  define EPROTO    2003
+#  define GNULIB_defined_EPROTO 1
+# endif
+
+# ifndef EMULTIHOP
+#  define EMULTIHOP 2004
+#  define GNULIB_defined_EMULTIHOP 1
+# endif
+
+# ifndef EBADMSG
+#  define EBADMSG   2005
+#  define GNULIB_defined_EBADMSG 1
+# endif
+
+# ifndef EOVERFLOW
+#  define EOVERFLOW 2006
+#  define GNULIB_defined_EOVERFLOW 1
+# endif
+
+# ifndef ENOTSUP
+#  define ENOTSUP   2007
+#  define GNULIB_defined_ENOTSUP 1
+# endif
+
+# ifndef ENETRESET
+#  define ENETRESET 2011
+#  define GNULIB_defined_ENETRESET 1
+# endif
+
+# ifndef ECONNABORTED
+#  define ECONNABORTED 2012
+#  define GNULIB_defined_ECONNABORTED 1
+# endif
+
+# ifndef ESTALE
+#  define ESTALE    2009
+#  define GNULIB_defined_ESTALE 1
+# endif
+
+# ifndef EDQUOT
+#  define EDQUOT 2010
+#  define GNULIB_defined_EDQUOT 1
+# endif
+
+# ifndef ECANCELED
+#  define ECANCELED 2008
+#  define GNULIB_defined_ECANCELED 1
+# endif
+
+/* On many platforms, the macros EOWNERDEAD and ENOTRECOVERABLE are not
+   defined.  */
+
+# ifndef EOWNERDEAD
+#  if defined __sun
+    /* Use the same values as defined for Solaris >= 8, for
+       interoperability.  */
+#   define EOWNERDEAD      58
+#   define ENOTRECOVERABLE 59
+#  elif defined _WIN32 && ! defined __CYGWIN__
+    /* We have a conflict here: pthreads-win32 defines these values
+       differently than MSVC 10.  It's hairy to decide which one to use.  */
+#   if defined __MINGW32__ && !defined USE_WINDOWS_THREADS
+     /* Use the same values as defined by pthreads-win32, for
+        interoperability.  */
+#    define EOWNERDEAD      43
+#    define ENOTRECOVERABLE 44
+#   else
+     /* Use the same values as defined by MSVC 10, for
+        interoperability.  */
+#    define EOWNERDEAD      133
+#    define ENOTRECOVERABLE 127
+#   endif
+#  else
+#   define EOWNERDEAD      2013
+#   define ENOTRECOVERABLE 2014
+#  endif
+#  define GNULIB_defined_EOWNERDEAD 1
+#  define GNULIB_defined_ENOTRECOVERABLE 1
+# endif
+
+# ifndef EILSEQ
+#  define EILSEQ 2015
+#  define GNULIB_defined_EILSEQ 1
+# endif
+
+#endif /* _GL_ERRNO_H */
+#endif /* _GL_ERRNO_H */
diff -Naur ../orig/sed-4.9/lib/fcntl.h ./lib/fcntl.h
--- ../orig/sed-4.9/lib/fcntl.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/fcntl.h	2022-12-01 17:13:19.119986300 +0300
@@ -0,0 +1,952 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Like <fcntl.h>, but with non-working flags defined to 0.
+
+   Copyright (C) 2006-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* written by Paul Eggert */
+
+#if __GNUC__ >= 3
+
+#endif
+
+
+#if defined __need_system_fcntl_h
+/* Special invocation convention.  */
+
+/* Needed before <sys/stat.h>.
+   May also define off_t to a 64-bit type on native Windows.  */
+#include <sys/types.h>
+/* On some systems other than glibc, <sys/stat.h> is a prerequisite of
+   <fcntl.h>.  On glibc systems, we would like to avoid namespace pollution.
+   But on glibc systems, <fcntl.h> includes <sys/stat.h> inside an
+   extern "C" { ... } block, which leads to errors in C++ mode with the
+   overridden <sys/stat.h> from gnulib.  These errors are known to be gone
+   with g++ version >= 4.3.  */
+#if !(defined __GLIBC__ || defined __UCLIBC__) || (defined __cplusplus && defined GNULIB_NAMESPACE && (defined __ICC || !(__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))))
+# include <sys/stat.h>
+#endif
+#include "C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\INCLUDE\fcntl.h"
+
+/* Native Windows platforms declare open(), creat() in <io.h>.  */
+#if (0 || 1 || defined GNULIB_POSIXCHECK) \
+    && (defined _WIN32 && ! defined __CYGWIN__)
+# include <io.h>
+#endif
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_FCNTL_H
+
+/* Needed before <sys/stat.h>.
+   May also define off_t to a 64-bit type on native Windows.  */
+#include <sys/types.h>
+/* On some systems other than glibc, <sys/stat.h> is a prerequisite of
+   <fcntl.h>.  On glibc systems, we would like to avoid namespace pollution.
+   But on glibc systems, <fcntl.h> includes <sys/stat.h> inside an
+   extern "C" { ... } block, which leads to errors in C++ mode with the
+   overridden <sys/stat.h> from gnulib.  These errors are known to be gone
+   with g++ version >= 4.3.  */
+#if !(defined __GLIBC__ || defined __UCLIBC__) || (defined __cplusplus && defined GNULIB_NAMESPACE && (defined __ICC || !(__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))))
+# include <sys/stat.h>
+#endif
+/* The include_next requires a split double-inclusion guard.  */
+#include "C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\INCLUDE\fcntl.h"
+
+/* Native Windows platforms declare open(), creat() in <io.h>.  */
+#if (0 || 1 || defined GNULIB_POSIXCHECK) \
+    && (defined _WIN32 && ! defined __CYGWIN__)
+# include <io.h>
+#endif
+
+#ifndef _GL_FCNTL_H
+#define _GL_FCNTL_H
+
+#ifndef __GLIBC__ /* Avoid namespace pollution on glibc systems.  */
+# include <unistd.h>
+#endif
+
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA (func, rettype, parameters);
+   is to be used when func is a Microsoft deprecated alias, on native Windows.
+   It declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to _func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_MDA (open, int, (const char *filename, int flags, ...));
+ */
+#define _GL_CXXALIAS_MDA(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_MDA (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#define _GL_CXXALIAS_MDA_CAST(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_CAST_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || defined __clang__
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype_gcc, rettype_clang, parameters_and_attributes, "message")
+   is like _GL_WARN_ON_USE (function, "message"), except that in C++ mode the
+   function is declared with the given prototype, consisting of return type,
+   parameters, and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if !defined __cplusplus
+#  define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+     _GL_WARN_ON_USE (function, msg)
+# else
+#  if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes \
+  __attribute__ ((__warning__ (msg)))
+#  elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_clang function parameters_and_attributes \
+  __attribute__ ((__diagnose_if__ (1, msg, "warning")))
+#  elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes
+#  else /* Unsupported.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  endif
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+
+/* Declare overridden functions.  */
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef creat
+#   define creat rpl_creat
+#  endif
+_GL_FUNCDECL_RPL (creat, int, (const char *filename, mode_t mode)
+                             _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (creat, int, (const char *filename, mode_t mode));
+# elif defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef creat
+#   define creat _creat
+#  endif
+_GL_CXXALIAS_MDA (creat, int, (const char *filename, mode_t mode));
+# else
+_GL_CXXALIAS_SYS (creat, int, (const char *filename, mode_t mode));
+# endif
+_GL_CXXALIASWARN (creat);
+#elif defined GNULIB_POSIXCHECK
+# undef creat
+/* Assume creat is always declared.  */
+_GL_WARN_ON_USE (creat, "creat is not always POSIX compliant - "
+                 "use gnulib module creat for portability");
+#elif 1
+/* On native Windows, map 'creat' to '_creat', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::creat always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef creat
+#   define creat _creat
+#  endif
+/* Need to cast, because in mingw the last argument is 'int mode'.  */
+_GL_CXXALIAS_MDA_CAST (creat, int, (const char *filename, mode_t mode));
+# else
+_GL_CXXALIAS_SYS (creat, int, (const char *filename, mode_t mode));
+# endif
+_GL_CXXALIASWARN (creat);
+#endif
+
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fcntl
+#   define fcntl rpl_fcntl
+#  endif
+_GL_FUNCDECL_RPL (fcntl, int, (int fd, int action, ...));
+_GL_CXXALIAS_RPL (fcntl, int, (int fd, int action, ...));
+#  if !GNULIB_defined_rpl_fcntl
+#   define GNULIB_defined_rpl_fcntl 1
+#  endif
+# else
+#  if !0
+_GL_FUNCDECL_SYS (fcntl, int, (int fd, int action, ...));
+#   if !GNULIB_defined_fcntl
+#    define GNULIB_defined_fcntl 1
+#   endif
+#  endif
+_GL_CXXALIAS_SYS (fcntl, int, (int fd, int action, ...));
+# endif
+_GL_CXXALIASWARN (fcntl);
+#elif defined GNULIB_POSIXCHECK
+# undef fcntl
+# if HAVE_RAW_DECL_FCNTL
+_GL_WARN_ON_USE (fcntl, "fcntl is not always POSIX compliant - "
+                 "use gnulib module fcntl for portability");
+# endif
+#endif
+
+#if 1
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef open
+#   define open rpl_open
+#  endif
+_GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                             _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+# elif defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef open
+#   define open _open
+#  endif
+_GL_CXXALIAS_MDA (open, int, (const char *filename, int flags, ...));
+# else
+_GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+# endif
+/* On HP-UX 11, in C++ mode, open() is defined as an inline function with a
+   default argument.  _GL_CXXALIASWARN does not work in this case.  */
+# if !defined __hpux
+_GL_CXXALIASWARN (open);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef open
+/* Assume open is always declared.  */
+_GL_WARN_ON_USE (open, "open is not always POSIX compliant - "
+                 "use gnulib module open for portability");
+#elif 1
+/* On native Windows, map 'open' to '_open', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::open always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef open
+#   define open _open
+#  endif
+_GL_CXXALIAS_MDA (open, int, (const char *filename, int flags, ...));
+# else
+_GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+# endif
+# if !defined __hpux
+_GL_CXXALIASWARN (open);
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef openat
+#   define openat rpl_openat
+#  endif
+_GL_FUNCDECL_RPL (openat, int,
+                  (int fd, char const *file, int flags, /* mode_t mode */ ...)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (openat, int,
+                  (int fd, char const *file, int flags, /* mode_t mode */ ...));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (openat, int,
+                  (int fd, char const *file, int flags, /* mode_t mode */ ...)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (openat, int,
+                  (int fd, char const *file, int flags, /* mode_t mode */ ...));
+# endif
+_GL_CXXALIASWARN (openat);
+#elif defined GNULIB_POSIXCHECK
+# undef openat
+# if HAVE_RAW_DECL_OPENAT
+_GL_WARN_ON_USE (openat, "openat is not portable - "
+                 "use gnulib module openat for portability");
+# endif
+#endif
+
+
+/* Fix up the FD_* macros, only known to be missing on mingw.  */
+
+#ifndef FD_CLOEXEC
+# define FD_CLOEXEC 1
+#endif
+
+/* Fix up the supported F_* macros.  Intentionally leave other F_*
+   macros undefined.  Only known to be missing on mingw.  */
+
+#ifndef F_DUPFD_CLOEXEC
+# define F_DUPFD_CLOEXEC 0x40000000
+/* Witness variable: 1 if gnulib defined F_DUPFD_CLOEXEC, 0 otherwise.  */
+# define GNULIB_defined_F_DUPFD_CLOEXEC 1
+#else
+# define GNULIB_defined_F_DUPFD_CLOEXEC 0
+#endif
+
+#ifndef F_DUPFD
+# define F_DUPFD 1
+#endif
+
+#ifndef F_GETFD
+# define F_GETFD 2
+#endif
+
+/* Fix up the O_* macros.  */
+
+/* AIX 7.1 with XL C 12.1 defines O_CLOEXEC, O_NOFOLLOW, and O_TTY_INIT
+   to values outside 'int' range, so omit these misdefinitions.
+   But avoid namespace pollution on non-AIX systems.  */
+#ifdef _AIX
+# include <limits.h>
+# if defined O_CLOEXEC && ! (INT_MIN <= O_CLOEXEC && O_CLOEXEC <= INT_MAX)
+#  undef O_CLOEXEC
+# endif
+# if defined O_NOFOLLOW && ! (INT_MIN <= O_NOFOLLOW && O_NOFOLLOW <= INT_MAX)
+#  undef O_NOFOLLOW
+# endif
+# if defined O_TTY_INIT && ! (INT_MIN <= O_TTY_INIT && O_TTY_INIT <= INT_MAX)
+#  undef O_TTY_INIT
+# endif
+#endif
+
+#if !defined O_DIRECT && defined O_DIRECTIO
+/* Tru64 spells it 'O_DIRECTIO'.  */
+# define O_DIRECT O_DIRECTIO
+#endif
+
+#if !defined O_CLOEXEC && defined O_NOINHERIT
+/* Mingw spells it 'O_NOINHERIT'.  */
+# define O_CLOEXEC O_NOINHERIT
+#endif
+
+#ifndef O_CLOEXEC
+# define O_CLOEXEC 0x40000000 /* Try to not collide with system O_* flags.  */
+# define GNULIB_defined_O_CLOEXEC 1
+#else
+# define GNULIB_defined_O_CLOEXEC 0
+#endif
+
+#ifndef O_DIRECT
+# define O_DIRECT 0
+#endif
+
+#ifndef O_DIRECTORY
+# define O_DIRECTORY 0
+#endif
+
+#ifndef O_DSYNC
+# define O_DSYNC 0
+#endif
+
+#ifndef O_EXEC
+# define O_EXEC O_RDONLY /* This is often close enough in older systems.  */
+#endif
+
+#ifndef O_IGNORE_CTTY
+# define O_IGNORE_CTTY 0
+#endif
+
+#ifndef O_NDELAY
+# define O_NDELAY 0
+#endif
+
+#ifndef O_NOATIME
+# define O_NOATIME 0
+#endif
+
+#ifndef O_NONBLOCK
+# define O_NONBLOCK O_NDELAY
+#endif
+
+/* If the gnulib module 'nonblocking' is in use, guarantee a working non-zero
+   value of O_NONBLOCK.  Otherwise, O_NONBLOCK is defined (above) to O_NDELAY
+   or to 0 as fallback.  */
+#if 0
+# if O_NONBLOCK
+#  define GNULIB_defined_O_NONBLOCK 0
+# else
+#  define GNULIB_defined_O_NONBLOCK 1
+#  undef O_NONBLOCK
+#  define O_NONBLOCK 0x40000000
+# endif
+#endif
+
+#ifndef O_NOCTTY
+# define O_NOCTTY 0
+#endif
+
+#ifndef O_NOFOLLOW
+# define O_NOFOLLOW 0
+#endif
+
+#ifndef O_NOLINK
+# define O_NOLINK 0
+#endif
+
+#ifndef O_NOLINKS
+# define O_NOLINKS 0
+#endif
+
+#ifndef O_NOTRANS
+# define O_NOTRANS 0
+#endif
+
+#ifndef O_RSYNC
+# define O_RSYNC 0
+#endif
+
+#ifndef O_SEARCH
+# define O_SEARCH O_RDONLY /* This is often close enough in older systems.  */
+#endif
+
+#ifndef O_SYNC
+# define O_SYNC 0
+#endif
+
+#ifndef O_TTY_INIT
+# define O_TTY_INIT 0
+#endif
+
+#if ~O_ACCMODE & (O_RDONLY | O_WRONLY | O_RDWR | O_EXEC | O_SEARCH)
+# undef O_ACCMODE
+# define O_ACCMODE (O_RDONLY | O_WRONLY | O_RDWR | O_EXEC | O_SEARCH)
+#endif
+
+/* For systems that distinguish between text and binary I/O.
+   O_BINARY is usually declared in fcntl.h  */
+#if !defined O_BINARY && defined _O_BINARY
+  /* For MSC-compatible compilers.  */
+# define O_BINARY _O_BINARY
+# define O_TEXT _O_TEXT
+#endif
+
+#if defined __BEOS__ || defined __HAIKU__
+  /* BeOS 5 and Haiku have O_BINARY and O_TEXT, but they have no effect.  */
+# undef O_BINARY
+# undef O_TEXT
+#endif
+
+#ifndef O_BINARY
+# define O_BINARY 0
+# define O_TEXT 0
+#endif
+
+/* Fix up the AT_* macros.  */
+
+/* Work around a bug in Solaris 9 and 10: AT_FDCWD is positive.  Its
+   value exceeds INT_MAX, so its use as an int doesn't conform to the
+   C standard, and GCC and Sun C complain in some cases.  If the bug
+   is present, undef AT_FDCWD here, so it can be redefined below.  */
+#if 0 < AT_FDCWD && AT_FDCWD == 0xffd19553
+# undef AT_FDCWD
+#endif
+
+/* Use the same bit pattern as Solaris 9, but with the proper
+   signedness.  The bit pattern is important, in case this actually is
+   Solaris with the above workaround.  */
+#ifndef AT_FDCWD
+# define AT_FDCWD (-3041965)
+#endif
+
+/* Use the same values as Solaris 9.  This shouldn't matter, but
+   there's no real reason to differ.  */
+#ifndef AT_SYMLINK_NOFOLLOW
+# define AT_SYMLINK_NOFOLLOW 4096
+#endif
+
+#ifndef AT_REMOVEDIR
+# define AT_REMOVEDIR 1
+#endif
+
+/* Solaris 9 lacks these two, so just pick unique values.  */
+#ifndef AT_SYMLINK_FOLLOW
+# define AT_SYMLINK_FOLLOW 2
+#endif
+
+#ifndef AT_EACCESS
+# define AT_EACCESS 4
+#endif
+
+/* Ignore this flag if not supported.  */
+#ifndef AT_NO_AUTOMOUNT
+# define AT_NO_AUTOMOUNT 0
+#endif
+
+#endif /* _GL_FCNTL_H */
+#endif /* _GL_FCNTL_H */
+#endif
diff -Naur ../orig/sed-4.9/lib/getopt-cdefs.h ./lib/getopt-cdefs.h
--- ../orig/sed-4.9/lib/getopt-cdefs.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/getopt-cdefs.h	2022-12-01 17:13:29.280430700 +0300
@@ -0,0 +1,68 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* getopt-on-non-glibc compatibility macros.
+   Copyright (C) 1989-2020 Free Software Foundation, Inc.
+   This file is part of gnulib.
+   Unlike most of the getopt implementation, it is NOT shared
+   with the GNU C Library.
+
+   This file is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 3 of
+   the License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public
+   License along with gnulib; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GETOPT_CDEFS_H
+#define _GETOPT_CDEFS_H 1
+
+/* This header should not be used directly; include getopt.h or
+   unistd.h instead.  It does not have a protective #error, because
+   the guard macro for getopt.h in gnulib is not fixed.  */
+
+/* getopt-core.h and getopt-ext.h are shared with GNU libc, and expect
+   a number of the internal macros supplied to GNU libc's headers by
+   sys/cdefs.h.  Provide fallback definitions for all of them.  */
+#if 0
+# include <sys/cdefs.h>
+#endif
+
+#ifndef __BEGIN_DECLS
+# ifdef __cplusplus
+#  define __BEGIN_DECLS extern "C" {
+# else
+#  define __BEGIN_DECLS /* nothing */
+# endif
+#endif
+#ifndef __END_DECLS
+# ifdef __cplusplus
+#  define __END_DECLS }
+# else
+#  define __END_DECLS /* nothing */
+# endif
+#endif
+
+#ifndef __GNUC_PREREQ
+# if defined __GNUC__ && defined __GNUC_VERSION__
+# define __GNUC_PREREQ(maj, min) \
+        ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
+# else
+#  define __GNUC_PREREQ(maj, min) 0
+# endif
+#endif
+
+#ifndef __THROW
+# if defined __cplusplus && __GNUC_PREREQ (2,8)
+#  define __THROW       throw ()
+# else
+#  define __THROW
+# endif
+#endif
+
+#endif /* _GETOPT_CDEFS_H */
diff -Naur ../orig/sed-4.9/lib/getopt-core.h ./lib/getopt-core.h
--- ../orig/sed-4.9/lib/getopt-core.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/getopt-core.h	2022-12-01 17:13:29.290430800 +0300
@@ -0,0 +1,96 @@
+/* Declarations for getopt (basic, portable features only).
+   Copyright (C) 1989-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library and is also part of gnulib.
+   Patches to this file should be submitted to both projects.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 3 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GETOPT_CORE_H
+#define _GETOPT_CORE_H 1
+
+/* This header should not be used directly; include getopt.h or
+   unistd.h instead.  Unlike most bits headers, it does not have
+   a protective #error, because the guard macro for getopt.h in
+   gnulib is not fixed.  */
+
+__BEGIN_DECLS
+
+/* For communication from 'getopt' to the caller.
+   When 'getopt' finds an option that takes an argument,
+   the argument value is returned here.
+   Also, when 'ordering' is RETURN_IN_ORDER,
+   each non-option ARGV-element is returned here.  */
+
+extern char *optarg;
+
+/* Index in ARGV of the next element to be scanned.
+   This is used for communication to and from the caller
+   and for communication between successive calls to 'getopt'.
+
+   On entry to 'getopt', zero means this is the first call; initialize.
+
+   When 'getopt' returns -1, this is the index of the first of the
+   non-option elements that the caller should itself scan.
+
+   Otherwise, 'optind' communicates from one call to the next
+   how much of ARGV has been scanned so far.  */
+
+extern int optind;
+
+/* Callers store zero here to inhibit the error message 'getopt' prints
+   for unrecognized options.  */
+
+extern int opterr;
+
+/* Set to an option character which was unrecognized.  */
+
+extern int optopt;
+
+/* Get definitions and prototypes for functions to process the
+   arguments in ARGV (ARGC of them, minus the program name) for
+   options given in OPTS.
+
+   Return the option character from OPTS just read.  Return -1 when
+   there are no more options.  For unrecognized options, or options
+   missing arguments, 'optopt' is set to the option letter, and '?' is
+   returned.
+
+   The OPTS string is a list of characters which are recognized option
+   letters, optionally followed by colons, specifying that that letter
+   takes an argument, to be placed in 'optarg'.
+
+   If a letter in OPTS is followed by two colons, its argument is
+   optional.  This behavior is specific to the GNU 'getopt'.
+
+   The argument '--' causes premature termination of argument
+   scanning, explicitly telling 'getopt' that there are no more
+   options.
+
+   If OPTS begins with '-', then non-option arguments are treated as
+   arguments to the option '\1'.  This behavior is specific to the GNU
+   'getopt'.  If OPTS begins with '+', or POSIXLY_CORRECT is set in
+   the environment, then do not permute arguments.
+
+   For standards compliance, the 'argv' argument has the type
+   char *const *, but this is inaccurate; if argument permutation is
+   enabled, the argv array (not the strings it points to) must be
+   writable.  */
+
+extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
+       __THROW _GL_ARG_NONNULL ((2, 3));
+
+__END_DECLS
+
+#endif /* _GETOPT_CORE_H */
diff -Naur ../orig/sed-4.9/lib/getopt-ext.h ./lib/getopt-ext.h
--- ../orig/sed-4.9/lib/getopt-ext.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/getopt-ext.h	2022-12-01 17:13:29.290430800 +0300
@@ -0,0 +1,77 @@
+/* Declarations for getopt (GNU extensions).
+   Copyright (C) 1989-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library and is also part of gnulib.
+   Patches to this file should be submitted to both projects.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 3 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GETOPT_EXT_H
+#define _GETOPT_EXT_H 1
+
+/* This header should not be used directly; include getopt.h instead.
+   Unlike most bits headers, it does not have a protective #error,
+   because the guard macro for getopt.h in gnulib is not fixed.  */
+
+__BEGIN_DECLS
+
+/* Describe the long-named options requested by the application.
+   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector
+   of 'struct option' terminated by an element containing a name which is
+   zero.
+
+   The field 'has_arg' is:
+   no_argument		(or 0) if the option does not take an argument,
+   required_argument	(or 1) if the option requires an argument,
+   optional_argument 	(or 2) if the option takes an optional argument.
+
+   If the field 'flag' is not NULL, it points to a variable that is set
+   to the value given in the field 'val' when the option is found, but
+   left unchanged if the option is not found.
+
+   To have a long-named option do something other than set an 'int' to
+   a compiled-in constant, such as set a value from 'optarg', set the
+   option's 'flag' field to zero and its 'val' field to a nonzero
+   value (the equivalent single-letter option character, if there is
+   one).  For long options that have a zero 'flag' field, 'getopt'
+   returns the contents of the 'val' field.  */
+
+struct option
+{
+  const char *name;
+  /* has_arg can't be an enum because some compilers complain about
+     type mismatches in all the code that assumes it is an int.  */
+  int has_arg;
+  int *flag;
+  int val;
+};
+
+/* Names for the values of the 'has_arg' field of 'struct option'.  */
+
+#define no_argument		0
+#define required_argument	1
+#define optional_argument	2
+
+extern int getopt_long (int ___argc, char *__getopt_argv_const *___argv,
+			const char *__shortopts,
+		        const struct option *__longopts, int *__longind)
+       __THROW _GL_ARG_NONNULL ((2, 3));
+extern int getopt_long_only (int ___argc, char *__getopt_argv_const *___argv,
+			     const char *__shortopts,
+		             const struct option *__longopts, int *__longind)
+       __THROW _GL_ARG_NONNULL ((2, 3));
+
+__END_DECLS
+
+#endif /* _GETOPT_EXT_H */
diff -Naur ../orig/sed-4.9/lib/getopt-pfx-core.h ./lib/getopt-pfx-core.h
--- ../orig/sed-4.9/lib/getopt-pfx-core.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/getopt-pfx-core.h	2022-12-01 17:13:29.290430800 +0300
@@ -0,0 +1,59 @@
+/* getopt (basic, portable features) gnulib wrapper header.
+   Copyright (C) 1989-2020 Free Software Foundation, Inc.
+   This file is part of gnulib.
+   Unlike most of the getopt implementation, it is NOT shared
+   with the GNU C Library.
+
+   This file is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 3 of
+   the License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public
+   License along with gnulib; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GETOPT_PFX_CORE_H
+#define _GETOPT_PFX_CORE_H 1
+
+/* This header should not be used directly; include getopt.h or
+   unistd.h instead.  It does not have a protective #error, because
+   the guard macro for getopt.h in gnulib is not fixed.  */
+
+/* Standalone applications should #define __GETOPT_PREFIX to an
+   identifier that prefixes the external functions and variables
+   defined in getopt-core.h and getopt-ext.h.  Systematically
+   rename identifiers so that they do not collide with the system
+   functions and variables.  Renaming avoids problems with some
+   compilers and linkers.  */
+#ifdef __GETOPT_PREFIX
+# ifndef __GETOPT_ID
+#  define __GETOPT_CONCAT(x, y) x ## y
+#  define __GETOPT_XCONCAT(x, y) __GETOPT_CONCAT (x, y)
+#  define __GETOPT_ID(y) __GETOPT_XCONCAT (__GETOPT_PREFIX, y)
+# endif
+# undef getopt
+# undef optarg
+# undef opterr
+# undef optind
+# undef optopt
+# define getopt __GETOPT_ID (getopt)
+# define optarg __GETOPT_ID (optarg)
+# define opterr __GETOPT_ID (opterr)
+# define optind __GETOPT_ID (optind)
+# define optopt __GETOPT_ID (optopt)
+
+/* The system's getopt.h may have already included getopt-core.h to
+   declare the unprefixed identifiers.  Undef _GETOPT_CORE_H so that
+   getopt-core.h declares them with prefixes.  */
+# undef _GETOPT_CORE_H
+#endif
+
+#include <getopt-core.h>
+
+#endif /* _GETOPT_PFX_CORE_H */
diff -Naur ../orig/sed-4.9/lib/getopt-pfx-ext.h ./lib/getopt-pfx-ext.h
--- ../orig/sed-4.9/lib/getopt-pfx-ext.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/getopt-pfx-ext.h	2022-12-01 17:13:29.300430800 +0300
@@ -0,0 +1,71 @@
+/* getopt (GNU extensions) gnulib wrapper header.
+   Copyright (C) 1989-2020 Free Software Foundation, Inc.
+   This file is part of gnulib.
+   Unlike most of the getopt implementation, it is NOT shared
+   with the GNU C Library.
+
+   This file is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 3 of
+   the License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public
+   License along with gnulib; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GETOPT_PFX_EXT_H
+#define _GETOPT_PFX_EXT_H 1
+
+/* This header should not be used directly; include getopt.h instead.
+   It does not have a protective #error, because the guard macro for
+   getopt.h in gnulib is not fixed.  */
+
+/* Standalone applications should #define __GETOPT_PREFIX to an
+   identifier that prefixes the external functions and variables
+   defined in getopt-core.h and getopt-ext.h.  Systematically
+   rename identifiers so that they do not collide with the system
+   functions and variables.  Renaming avoids problems with some
+   compilers and linkers.  */
+#ifdef __GETOPT_PREFIX
+# ifndef __GETOPT_ID
+#  define __GETOPT_CONCAT(x, y) x ## y
+#  define __GETOPT_XCONCAT(x, y) __GETOPT_CONCAT (x, y)
+#  define __GETOPT_ID(y) __GETOPT_XCONCAT (__GETOPT_PREFIX, y)
+# endif
+# undef getopt_long
+# undef getopt_long_only
+# undef option
+# undef _getopt_internal
+# define getopt_long __GETOPT_ID (getopt_long)
+# define getopt_long_only __GETOPT_ID (getopt_long_only)
+# define option __GETOPT_ID (option)
+# define _getopt_internal __GETOPT_ID (getopt_internal)
+
+/* The system's getopt.h may have already included getopt-ext.h to
+   declare the unprefixed identifiers.  Undef _GETOPT_EXT_H so that
+   getopt-ext.h declares them with prefixes.  */
+# undef _GETOPT_EXT_H
+#endif
+
+/* Standalone applications get correct prototypes for getopt_long and
+   getopt_long_only; they declare "char **argv".  For backward
+   compatibility with old applications, if __GETOPT_PREFIX is not
+   defined, we supply GNU-libc-compatible, but incorrect, prototypes
+   using "char *const *argv".  (GNU libc is stuck with the incorrect
+   prototypes, as they are baked into older versions of LSB.)  */
+#ifndef __getopt_argv_const
+# if defined __GETOPT_PREFIX
+#  define __getopt_argv_const /* empty */
+# else
+#  define __getopt_argv_const const
+# endif
+#endif
+
+#include <getopt-ext.h>
+
+#endif /* _GETOPT_PFX_EXT_H */
diff -Naur ../orig/sed-4.9/lib/getopt.c ./lib/getopt.c
--- ../orig/sed-4.9/lib/getopt.c	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/getopt.c	2022-12-01 17:13:29.300430800 +0300
@@ -0,0 +1,811 @@
+/* Getopt for GNU.
+   Copyright (C) 1987-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library and is also part of gnulib.
+   Patches to this file should be submitted to both projects.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 3 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _LIBC
+# include <config.h>
+#endif
+
+#include "getopt.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#ifdef _LIBC
+/* When used as part of glibc, error printing must be done differently
+   for standards compliance.  getopt is not a cancellation point, so
+   it must not call functions that are, and it is specified by an
+   older standard than stdio locking, so it must not refer to
+   functions in the "user namespace" related to stdio locking.
+   Finally, it must use glibc's internal message translation so that
+   the messages are looked up in the proper text domain.  */
+# include <libintl.h>
+# define fprintf __fxprintf_nocancel
+# define flockfile(fp) _IO_flockfile (fp)
+# define funlockfile(fp) _IO_funlockfile (fp)
+#else
+# include "gettext.h"
+# define _(msgid) gettext (msgid)
+/* When used standalone, flockfile and funlockfile might not be
+   available.  */
+# if (!defined _POSIX_THREAD_SAFE_FUNCTIONS \
+      || (defined _WIN32 && ! defined __CYGWIN__))
+#  define flockfile(fp) /* nop */
+#  define funlockfile(fp) /* nop */
+# endif
+/* When used standalone, do not attempt to use alloca.  */
+# define __libc_use_alloca(size) 0
+# undef alloca
+# define alloca(size) (abort (), (void *)0)
+#endif
+
+/* This implementation of 'getopt' has three modes for handling
+   options interspersed with non-option arguments.  It can stop
+   scanning for options at the first non-option argument encountered,
+   as POSIX specifies.  It can continue scanning for options after the
+   first non-option argument, but permute 'argv' as it goes so that,
+   after 'getopt' is done, all the options precede all the non-option
+   arguments and 'optind' points to the first non-option argument.
+   Or, it can report non-option arguments as if they were arguments to
+   the option character '\x01'.
+
+   The default behavior of 'getopt_long' is to permute the argument list.
+   When this implementation is used standalone, the default behavior of
+   'getopt' is to stop at the first non-option argument, but when it is
+   used as part of GNU libc it also permutes the argument list.  In both
+   cases, setting the environment variable POSIXLY_CORRECT to any value
+   disables permutation.
+
+   If the first character of the OPTSTRING argument to 'getopt' or
+   'getopt_long' is '+', both functions will stop at the first
+   non-option argument.  If it is '-', both functions will report
+   non-option arguments as arguments to the option character '\x01'.  */
+
+#include "getopt_int.h"
+
+/* For communication from 'getopt' to the caller.
+   When 'getopt' finds an option that takes an argument,
+   the argument value is returned here.
+   Also, when 'ordering' is RETURN_IN_ORDER,
+   each non-option ARGV-element is returned here.  */
+
+char *optarg;
+
+/* Index in ARGV of the next element to be scanned.
+   This is used for communication to and from the caller
+   and for communication between successive calls to 'getopt'.
+
+   On entry to 'getopt', zero means this is the first call; initialize.
+
+   When 'getopt' returns -1, this is the index of the first of the
+   non-option elements that the caller should itself scan.
+
+   Otherwise, 'optind' communicates from one call to the next
+   how much of ARGV has been scanned so far.  */
+
+/* 1003.2 says this must be 1 before any call.  */
+int optind = 1;
+
+/* Callers store zero here to inhibit the error message
+   for unrecognized options.  */
+
+int opterr = 1;
+
+/* Set to an option character which was unrecognized.
+   This must be initialized on some systems to avoid linking in the
+   system's own getopt implementation.  */
+
+int optopt = '?';
+
+/* Keep a global copy of all internal members of getopt_data.  */
+
+static struct _getopt_data getopt_data;
+
+/* Exchange two adjacent subsequences of ARGV.
+   One subsequence is elements [first_nonopt,last_nonopt)
+   which contains all the non-options that have been skipped so far.
+   The other is elements [last_nonopt,optind), which contains all
+   the options processed since those non-options were skipped.
+
+   'first_nonopt' and 'last_nonopt' are relocated so that they describe
+   the new indices of the non-options in ARGV after they are moved.  */
+
+static void
+exchange (char **argv, struct _getopt_data *d)
+{
+  int bottom = d->__first_nonopt;
+  int middle = d->__last_nonopt;
+  int top = d->optind;
+  char *tem;
+
+  /* Exchange the shorter segment with the far end of the longer segment.
+     That puts the shorter segment into the right place.
+     It leaves the longer segment in the right place overall,
+     but it consists of two parts that need to be swapped next.  */
+
+  while (top > middle && middle > bottom)
+    {
+      if (top - middle > middle - bottom)
+	{
+	  /* Bottom segment is the short one.  */
+	  int len = middle - bottom;
+	  int i;
+
+	  /* Swap it with the top part of the top segment.  */
+	  for (i = 0; i < len; i++)
+	    {
+	      tem = argv[bottom + i];
+	      argv[bottom + i] = argv[top - (middle - bottom) + i];
+	      argv[top - (middle - bottom) + i] = tem;
+	    }
+	  /* Exclude the moved bottom segment from further swapping.  */
+	  top -= len;
+	}
+      else
+	{
+	  /* Top segment is the short one.  */
+	  int len = top - middle;
+	  int i;
+
+	  /* Swap it with the bottom part of the bottom segment.  */
+	  for (i = 0; i < len; i++)
+	    {
+	      tem = argv[bottom + i];
+	      argv[bottom + i] = argv[middle + i];
+	      argv[middle + i] = tem;
+	    }
+	  /* Exclude the moved top segment from further swapping.  */
+	  bottom += len;
+	}
+    }
+
+  /* Update records for the slots the non-options now occupy.  */
+
+  d->__first_nonopt += (d->optind - d->__last_nonopt);
+  d->__last_nonopt = d->optind;
+}
+
+/* Process the argument starting with d->__nextchar as a long option.
+   d->optind should *not* have been advanced over this argument.
+
+   If the value returned is -1, it was not actually a long option, the
+   state is unchanged, and the argument should be processed as a set
+   of short options (this can only happen when long_only is true).
+   Otherwise, the option (and its argument, if any) have been consumed
+   and the return value is the value to return from _getopt_internal_r.  */
+static int
+process_long_option (int argc, char **argv, const char *optstring,
+		     const struct option *longopts, int *longind,
+		     int long_only, struct _getopt_data *d,
+		     int print_errors, const char *prefix)
+{
+  char *nameend;
+  size_t namelen;
+  const struct option *p;
+  const struct option *pfound = NULL;
+  int n_options;
+  int option_index;
+
+  for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)
+    /* Do nothing.  */ ;
+  namelen = nameend - d->__nextchar;
+
+  /* First look for an exact match, counting the options as a side
+     effect.  */
+  for (p = longopts, n_options = 0; p->name; p++, n_options++)
+    if (!strncmp (p->name, d->__nextchar, namelen)
+	&& namelen == strlen (p->name))
+      {
+	/* Exact match found.  */
+	pfound = p;
+	option_index = n_options;
+	break;
+      }
+
+  if (pfound == NULL)
+    {
+      /* Didn't find an exact match, so look for abbreviations.  */
+      unsigned char *ambig_set = NULL;
+      int ambig_malloced = 0;
+      int ambig_fallback = 0;
+      int indfound = -1;
+
+      for (p = longopts, option_index = 0; p->name; p++, option_index++)
+	if (!strncmp (p->name, d->__nextchar, namelen))
+	  {
+	    if (pfound == NULL)
+	      {
+		/* First nonexact match found.  */
+		pfound = p;
+		indfound = option_index;
+	      }
+	    else if (long_only
+		     || pfound->has_arg != p->has_arg
+		     || pfound->flag != p->flag
+		     || pfound->val != p->val)
+	      {
+		/* Second or later nonexact match found.  */
+		if (!ambig_fallback)
+		  {
+		    if (!print_errors)
+		      /* Don't waste effort tracking the ambig set if
+			 we're not going to print it anyway.  */
+		      ambig_fallback = 1;
+		    else if (!ambig_set)
+		      {
+			if (__libc_use_alloca (n_options))
+			  ambig_set = alloca (n_options);
+			else if ((ambig_set = malloc (n_options)) == NULL)
+			  /* Fall back to simpler error message.  */
+			  ambig_fallback = 1;
+			else
+			  ambig_malloced = 1;
+
+			if (ambig_set)
+			  {
+			    memset (ambig_set, 0, n_options);
+			    ambig_set[indfound] = 1;
+			  }
+		      }
+		    if (ambig_set)
+		      ambig_set[option_index] = 1;
+		  }
+	      }
+	  }
+
+      if (ambig_set || ambig_fallback)
+	{
+	  if (print_errors)
+	    {
+	      if (ambig_fallback)
+		fprintf (stderr, _("%s: option '%s%s' is ambiguous\n"),
+			 argv[0], prefix, d->__nextchar);
+	      else
+		{
+		  flockfile (stderr);
+		  fprintf (stderr,
+			   _("%s: option '%s%s' is ambiguous; possibilities:"),
+			   argv[0], prefix, d->__nextchar);
+
+		  for (option_index = 0; option_index < n_options; option_index++)
+		    if (ambig_set[option_index])
+		      fprintf (stderr, " '%s%s'",
+			       prefix, longopts[option_index].name);
+
+		  /* This must use 'fprintf' even though it's only
+		     printing a single character, so that it goes through
+		     __fxprintf_nocancel when compiled as part of glibc.  */
+		  fprintf (stderr, "\n");
+		  funlockfile (stderr);
+		}
+	    }
+	  if (ambig_malloced)
+	    free (ambig_set);
+	  d->__nextchar += strlen (d->__nextchar);
+	  d->optind++;
+	  d->optopt = 0;
+	  return '?';
+	}
+
+      option_index = indfound;
+    }
+
+  if (pfound == NULL)
+    {
+      /* Can't find it as a long option.  If this is not getopt_long_only,
+	 or the option starts with '--' or is not a valid short option,
+	 then it's an error.  */
+      if (!long_only || argv[d->optind][1] == '-'
+	  || strchr (optstring, *d->__nextchar) == NULL)
+	{
+	  if (print_errors)
+	    fprintf (stderr, _("%s: unrecognized option '%s%s'\n"),
+		     argv[0], prefix, d->__nextchar);
+
+	  d->__nextchar = NULL;
+	  d->optind++;
+	  d->optopt = 0;
+	  return '?';
+	}
+
+      /* Otherwise interpret it as a short option.  */
+      return -1;
+    }
+
+  /* We have found a matching long option.  Consume it.  */
+  d->optind++;
+  d->__nextchar = NULL;
+  if (*nameend)
+    {
+      /* Don't test has_arg with >, because some C compilers don't
+	 allow it to be used on enums.  */
+      if (pfound->has_arg)
+	d->optarg = nameend + 1;
+      else
+	{
+	  if (print_errors)
+	    fprintf (stderr,
+		     _("%s: option '%s%s' doesn't allow an argument\n"),
+		     argv[0], prefix, pfound->name);
+
+	  d->optopt = pfound->val;
+	  return '?';
+	}
+    }
+  else if (pfound->has_arg == 1)
+    {
+      if (d->optind < argc)
+	d->optarg = argv[d->optind++];
+      else
+	{
+	  if (print_errors)
+	    fprintf (stderr,
+		     _("%s: option '%s%s' requires an argument\n"),
+		     argv[0], prefix, pfound->name);
+
+	  d->optopt = pfound->val;
+	  return optstring[0] == ':' ? ':' : '?';
+	}
+    }
+
+  if (longind != NULL)
+    *longind = option_index;
+  if (pfound->flag)
+    {
+      *(pfound->flag) = pfound->val;
+      return 0;
+    }
+  return pfound->val;
+}
+
+/* Initialize internal data upon the first call to getopt.  */
+
+static const char *
+_getopt_initialize (int argc _GL_UNUSED,
+		    char **argv _GL_UNUSED, const char *optstring,
+		    struct _getopt_data *d, int posixly_correct)
+{
+  /* Start processing options with ARGV-element 1 (since ARGV-element 0
+     is the program name); the sequence of previously skipped
+     non-option ARGV-elements is empty.  */
+  if (d->optind == 0)
+    d->optind = 1;
+
+  d->__first_nonopt = d->__last_nonopt = d->optind;
+  d->__nextchar = NULL;
+
+  /* Determine how to handle the ordering of options and nonoptions.  */
+  if (optstring[0] == '-')
+    {
+      d->__ordering = RETURN_IN_ORDER;
+      ++optstring;
+    }
+  else if (optstring[0] == '+')
+    {
+      d->__ordering = REQUIRE_ORDER;
+      ++optstring;
+    }
+  else if (posixly_correct || !!getenv ("POSIXLY_CORRECT"))
+    d->__ordering = REQUIRE_ORDER;
+  else
+    d->__ordering = PERMUTE;
+
+  d->__initialized = 1;
+  return optstring;
+}
+
+/* Scan elements of ARGV (whose length is ARGC) for option characters
+   given in OPTSTRING.
+
+   If an element of ARGV starts with '-', and is not exactly "-" or "--",
+   then it is an option element.  The characters of this element
+   (aside from the initial '-') are option characters.  If 'getopt'
+   is called repeatedly, it returns successively each of the option characters
+   from each of the option elements.
+
+   If 'getopt' finds another option character, it returns that character,
+   updating 'optind' and 'nextchar' so that the next call to 'getopt' can
+   resume the scan with the following option character or ARGV-element.
+
+   If there are no more option characters, 'getopt' returns -1.
+   Then 'optind' is the index in ARGV of the first ARGV-element
+   that is not an option.  (The ARGV-elements have been permuted
+   so that those that are not options now come last.)
+
+   OPTSTRING is a string containing the legitimate option characters.
+   If an option character is seen that is not listed in OPTSTRING,
+   return '?' after printing an error message.  If you set 'opterr' to
+   zero, the error message is suppressed but we still return '?'.
+
+   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
+   so the following text in the same ARGV-element, or the text of the following
+   ARGV-element, is returned in 'optarg'.  Two colons mean an option that
+   wants an optional arg; if there is text in the current ARGV-element,
+   it is returned in 'optarg', otherwise 'optarg' is set to zero.
+
+   If OPTSTRING starts with '-' or '+', it requests different methods of
+   handling the non-option ARGV-elements.
+   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
+
+   Long-named options begin with '--' instead of '-'.
+   Their names may be abbreviated as long as the abbreviation is unique
+   or is an exact match for some defined option.  If they have an
+   argument, it follows the option name in the same ARGV-element, separated
+   from the option name by a '=', or else the in next ARGV-element.
+   When 'getopt' finds a long-named option, it returns 0 if that option's
+   'flag' field is nonzero, the value of the option's 'val' field
+   if the 'flag' field is zero.
+
+   The elements of ARGV aren't really const, because we permute them.
+   But we pretend they're const in the prototype to be compatible
+   with other systems.
+
+   LONGOPTS is a vector of 'struct option' terminated by an
+   element containing a name which is zero.
+
+   LONGIND returns the index in LONGOPT of the long-named option found.
+   It is only valid when a long-named option has been found by the most
+   recent call.
+
+   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
+   long-named options.  */
+
+int
+_getopt_internal_r (int argc, char **argv, const char *optstring,
+		    const struct option *longopts, int *longind,
+		    int long_only, struct _getopt_data *d, int posixly_correct)
+{
+  int print_errors = d->opterr;
+
+  if (argc < 1)
+    return -1;
+
+  d->optarg = NULL;
+
+  if (d->optind == 0 || !d->__initialized)
+    optstring = _getopt_initialize (argc, argv, optstring, d, posixly_correct);
+  else if (optstring[0] == '-' || optstring[0] == '+')
+    optstring++;
+
+  if (optstring[0] == ':')
+    print_errors = 0;
+
+  /* Test whether ARGV[optind] points to a non-option argument.  */
+#define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\0')
+
+  if (d->__nextchar == NULL || *d->__nextchar == '\0')
+    {
+      /* Advance to the next ARGV-element.  */
+
+      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
+	 moved back by the user (who may also have changed the arguments).  */
+      if (d->__last_nonopt > d->optind)
+	d->__last_nonopt = d->optind;
+      if (d->__first_nonopt > d->optind)
+	d->__first_nonopt = d->optind;
+
+      if (d->__ordering == PERMUTE)
+	{
+	  /* If we have just processed some options following some non-options,
+	     exchange them so that the options come first.  */
+
+	  if (d->__first_nonopt != d->__last_nonopt
+	      && d->__last_nonopt != d->optind)
+	    exchange (argv, d);
+	  else if (d->__last_nonopt != d->optind)
+	    d->__first_nonopt = d->optind;
+
+	  /* Skip any additional non-options
+	     and extend the range of non-options previously skipped.  */
+
+	  while (d->optind < argc && NONOPTION_P)
+	    d->optind++;
+	  d->__last_nonopt = d->optind;
+	}
+
+      /* The special ARGV-element '--' means premature end of options.
+	 Skip it like a null option,
+	 then exchange with previous non-options as if it were an option,
+	 then skip everything else like a non-option.  */
+
+      if (d->optind != argc && !strcmp (argv[d->optind], "--"))
+	{
+	  d->optind++;
+
+	  if (d->__first_nonopt != d->__last_nonopt
+	      && d->__last_nonopt != d->optind)
+	    exchange (argv, d);
+	  else if (d->__first_nonopt == d->__last_nonopt)
+	    d->__first_nonopt = d->optind;
+	  d->__last_nonopt = argc;
+
+	  d->optind = argc;
+	}
+
+      /* If we have done all the ARGV-elements, stop the scan
+	 and back over any non-options that we skipped and permuted.  */
+
+      if (d->optind == argc)
+	{
+	  /* Set the next-arg-index to point at the non-options
+	     that we previously skipped, so the caller will digest them.  */
+	  if (d->__first_nonopt != d->__last_nonopt)
+	    d->optind = d->__first_nonopt;
+	  return -1;
+	}
+
+      /* If we have come to a non-option and did not permute it,
+	 either stop the scan or describe it to the caller and pass it by.  */
+
+      if (NONOPTION_P)
+	{
+	  if (d->__ordering == REQUIRE_ORDER)
+	    return -1;
+	  d->optarg = argv[d->optind++];
+	  return 1;
+	}
+
+      /* We have found another option-ARGV-element.
+	 Check whether it might be a long option.  */
+      if (longopts)
+	{
+	  if (argv[d->optind][1] == '-')
+	    {
+	      /* "--foo" is always a long option.  The special option
+		 "--" was handled above.  */
+	      d->__nextchar = argv[d->optind] + 2;
+	      return process_long_option (argc, argv, optstring, longopts,
+					  longind, long_only, d,
+					  print_errors, "--");
+	    }
+
+	  /* If long_only and the ARGV-element has the form "-f",
+	     where f is a valid short option, don't consider it an
+	     abbreviated form of a long option that starts with f.
+	     Otherwise there would be no way to give the -f short
+	     option.
+
+	     On the other hand, if there's a long option "fubar" and
+	     the ARGV-element is "-fu", do consider that an
+	     abbreviation of the long option, just like "--fu", and
+	     not "-f" with arg "u".
+
+	     This distinction seems to be the most useful approach.  */
+	  if (long_only && (argv[d->optind][2]
+			    || !strchr (optstring, argv[d->optind][1])))
+	    {
+	      int code;
+	      d->__nextchar = argv[d->optind] + 1;
+	      code = process_long_option (argc, argv, optstring, longopts,
+					  longind, long_only, d,
+					  print_errors, "-");
+	      if (code != -1)
+		return code;
+	    }
+	}
+
+      /* It is not a long option.  Skip the initial punctuation.  */
+      d->__nextchar = argv[d->optind] + 1;
+    }
+
+  /* Look at and handle the next short option-character.  */
+
+  {
+    char c = *d->__nextchar++;
+    const char *temp = strchr (optstring, c);
+
+    /* Increment 'optind' when we start to process its last character.  */
+    if (*d->__nextchar == '\0')
+      ++d->optind;
+
+    if (temp == NULL || c == ':' || c == ';')
+      {
+	if (print_errors)
+	  fprintf (stderr, _("%s: invalid option -- '%c'\n"), argv[0], c);
+	d->optopt = c;
+	return '?';
+      }
+
+    /* Convenience. Treat POSIX -W foo same as long option --foo */
+    if (temp[0] == 'W' && temp[1] == ';' && longopts != NULL)
+      {
+	/* This is an option that requires an argument.  */
+	if (*d->__nextchar != '\0')
+	  d->optarg = d->__nextchar;
+	else if (d->optind == argc)
+	  {
+	    if (print_errors)
+	      fprintf (stderr,
+		       _("%s: option requires an argument -- '%c'\n"),
+		       argv[0], c);
+
+	    d->optopt = c;
+	    if (optstring[0] == ':')
+	      c = ':';
+	    else
+	      c = '?';
+	    return c;
+	  }
+	else
+	  d->optarg = argv[d->optind];
+
+	d->__nextchar = d->optarg;
+	d->optarg = NULL;
+	return process_long_option (argc, argv, optstring, longopts, longind,
+				    0 /* long_only */, d, print_errors, "-W ");
+      }
+    if (temp[1] == ':')
+      {
+	if (temp[2] == ':')
+	  {
+	    /* This is an option that accepts an argument optionally.  */
+	    if (*d->__nextchar != '\0')
+	      {
+		d->optarg = d->__nextchar;
+		d->optind++;
+	      }
+	    else
+	      d->optarg = NULL;
+	    d->__nextchar = NULL;
+	  }
+	else
+	  {
+	    /* This is an option that requires an argument.  */
+	    if (*d->__nextchar != '\0')
+	      {
+		d->optarg = d->__nextchar;
+		/* If we end this ARGV-element by taking the rest as an arg,
+		   we must advance to the next element now.  */
+		d->optind++;
+	      }
+	    else if (d->optind == argc)
+	      {
+		if (print_errors)
+		  fprintf (stderr,
+			   _("%s: option requires an argument -- '%c'\n"),
+			   argv[0], c);
+
+		d->optopt = c;
+		if (optstring[0] == ':')
+		  c = ':';
+		else
+		  c = '?';
+	      }
+	    else
+	      /* We already incremented 'optind' once;
+		 increment it again when taking next ARGV-elt as argument.  */
+	      d->optarg = argv[d->optind++];
+	    d->__nextchar = NULL;
+	  }
+      }
+    return c;
+  }
+}
+
+int
+_getopt_internal (int argc, char **argv, const char *optstring,
+		  const struct option *longopts, int *longind, int long_only,
+		  int posixly_correct)
+{
+  int result;
+
+  getopt_data.optind = optind;
+  getopt_data.opterr = opterr;
+
+  result = _getopt_internal_r (argc, argv, optstring, longopts,
+			       longind, long_only, &getopt_data,
+			       posixly_correct);
+
+  optind = getopt_data.optind;
+  optarg = getopt_data.optarg;
+  optopt = getopt_data.optopt;
+
+  return result;
+}
+
+/* glibc gets a LSB-compliant getopt and a POSIX-complaint __posix_getopt.
+   Standalone applications just get a POSIX-compliant getopt.
+   POSIX and LSB both require these functions to take 'char *const *argv'
+   even though this is incorrect (because of the permutation).  */
+#define GETOPT_ENTRY(NAME, POSIXLY_CORRECT)			\
+  int								\
+  NAME (int argc, char *const *argv, const char *optstring)	\
+  {								\
+    return _getopt_internal (argc, (char **)argv, optstring,	\
+			     0, 0, 0, POSIXLY_CORRECT);		\
+  }
+
+#ifdef _LIBC
+GETOPT_ENTRY(getopt, 0)
+GETOPT_ENTRY(__posix_getopt, 1)
+#else
+GETOPT_ENTRY(getopt, 1)
+#endif
+
+
+#ifdef TEST
+
+/* Compile with -DTEST to make an executable for use in testing
+   the above definition of 'getopt'.  */
+
+int
+main (int argc, char **argv)
+{
+  int c;
+  int digit_optind = 0;
+
+  while (1)
+    {
+      int this_option_optind = optind ? optind : 1;
+
+      c = getopt (argc, argv, "abc:d:0123456789");
+      if (c == -1)
+	break;
+
+      switch (c)
+	{
+	case '0':
+	case '1':
+	case '2':
+	case '3':
+	case '4':
+	case '5':
+	case '6':
+	case '7':
+	case '8':
+	case '9':
+	  if (digit_optind != 0 && digit_optind != this_option_optind)
+	    printf ("digits occur in two different argv-elements.\n");
+	  digit_optind = this_option_optind;
+	  printf ("option %c\n", c);
+	  break;
+
+	case 'a':
+	  printf ("option a\n");
+	  break;
+
+	case 'b':
+	  printf ("option b\n");
+	  break;
+
+	case 'c':
+	  printf ("option c with value '%s'\n", optarg);
+	  break;
+
+	case '?':
+	  break;
+
+	default:
+	  printf ("?? getopt returned character code 0%o ??\n", c);
+	}
+    }
+
+  if (optind < argc)
+    {
+      printf ("non-option ARGV-elements: ");
+      while (optind < argc)
+	printf ("%s ", argv[optind++]);
+      printf ("\n");
+    }
+
+  exit (0);
+}
+
+#endif /* TEST */
diff -Naur ../orig/sed-4.9/lib/getopt.h ./lib/getopt.h
--- ../orig/sed-4.9/lib/getopt.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/getopt.h	2022-12-01 17:13:29.310430800 +0300
@@ -0,0 +1,88 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Declarations for getopt.
+   Copyright (C) 1989-2020 Free Software Foundation, Inc.
+   This file is part of gnulib.
+   Unlike most of the getopt implementation, it is NOT shared
+   with the GNU C Library, which supplies a different version of
+   this file.
+
+   This file is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 3 of
+   the License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public
+   License along with gnulib; if not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_GETOPT_H
+
+#if __GNUC__ >= 3
+
+#endif
+
+
+/* The include_next requires a split double-inclusion guard.  We must
+   also inform the replacement unistd.h to not recursively use
+   <getopt.h>; our definitions will be present soon enough.  */
+#if 0
+# define _GL_SYSTEM_GETOPT
+# include ""
+# undef _GL_SYSTEM_GETOPT
+#endif
+
+#define _GL_GETOPT_H 1
+
+/* Standalone applications should #define __GETOPT_PREFIX to an
+   identifier that prefixes the external functions and variables
+   defined in getopt-core.h and getopt-ext.h.  When this happens,
+   include the headers that might declare getopt so that they will not
+   cause confusion if included after this file (if the system had
+   <getopt.h>, we have already included it).  */
+#if defined __GETOPT_PREFIX
+# if !0
+#  define __need_system_stdlib_h
+#  include <stdlib.h>
+#  undef __need_system_stdlib_h
+#  include <stdio.h>
+#  include <unistd.h>
+# endif
+#endif
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2020 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || __GNUC__ > 3
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+#include <getopt-cdefs.h>
+#include <getopt-pfx-core.h>
+#include <getopt-pfx-ext.h>
+
+#endif /* _GL_GETOPT_H */
diff -Naur ../orig/sed-4.9/lib/getopt1.c ./lib/getopt1.c
--- ../orig/sed-4.9/lib/getopt1.c	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/getopt1.c	2022-12-01 17:13:29.310430800 +0300
@@ -0,0 +1,159 @@
+/* getopt_long and getopt_long_only entry points for GNU getopt.
+   Copyright (C) 1987-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library and is also part of gnulib.
+   Patches to this file should be submitted to both projects.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 3 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _LIBC
+# include <config.h>
+#endif
+
+#include "getopt.h"
+#include "getopt_int.h"
+
+int
+getopt_long (int argc, char *__getopt_argv_const *argv, const char *options,
+	     const struct option *long_options, int *opt_index)
+{
+  return _getopt_internal (argc, (char **) argv, options, long_options,
+			   opt_index, 0, 0);
+}
+
+int
+_getopt_long_r (int argc, char **argv, const char *options,
+		const struct option *long_options, int *opt_index,
+		struct _getopt_data *d)
+{
+  return _getopt_internal_r (argc, argv, options, long_options, opt_index,
+			     0, d, 0);
+}
+
+/* Like getopt_long, but '-' as well as '--' can indicate a long option.
+   If an option that starts with '-' (not '--') doesn't match a long option,
+   but does match a short option, it is parsed as a short option
+   instead.  */
+
+int
+getopt_long_only (int argc, char *__getopt_argv_const *argv,
+		  const char *options,
+		  const struct option *long_options, int *opt_index)
+{
+  return _getopt_internal (argc, (char **) argv, options, long_options,
+			   opt_index, 1, 0);
+}
+
+int
+_getopt_long_only_r (int argc, char **argv, const char *options,
+		     const struct option *long_options, int *opt_index,
+		     struct _getopt_data *d)
+{
+  return _getopt_internal_r (argc, argv, options, long_options, opt_index,
+			     1, d, 0);
+}
+
+
+#ifdef TEST
+
+#include <stdio.h>
+#include <stdlib.h>
+
+int
+main (int argc, char **argv)
+{
+  int c;
+  int digit_optind = 0;
+
+  while (1)
+    {
+      int this_option_optind = optind ? optind : 1;
+      int option_index = 0;
+      static const struct option long_options[] =
+      {
+	{"add", 1, 0, 0},
+	{"append", 0, 0, 0},
+	{"delete", 1, 0, 0},
+	{"verbose", 0, 0, 0},
+	{"create", 0, 0, 0},
+	{"file", 1, 0, 0},
+	{0, 0, 0, 0}
+      };
+
+      c = getopt_long (argc, argv, "abc:d:0123456789",
+		       long_options, &option_index);
+      if (c == -1)
+	break;
+
+      switch (c)
+	{
+	case 0:
+	  printf ("option %s", long_options[option_index].name);
+	  if (optarg)
+	    printf (" with arg %s", optarg);
+	  printf ("\n");
+	  break;
+
+	case '0':
+	case '1':
+	case '2':
+	case '3':
+	case '4':
+	case '5':
+	case '6':
+	case '7':
+	case '8':
+	case '9':
+	  if (digit_optind != 0 && digit_optind != this_option_optind)
+	    printf ("digits occur in two different argv-elements.\n");
+	  digit_optind = this_option_optind;
+	  printf ("option %c\n", c);
+	  break;
+
+	case 'a':
+	  printf ("option a\n");
+	  break;
+
+	case 'b':
+	  printf ("option b\n");
+	  break;
+
+	case 'c':
+	  printf ("option c with value '%s'\n", optarg);
+	  break;
+
+	case 'd':
+	  printf ("option d with value '%s'\n", optarg);
+	  break;
+
+	case '?':
+	  break;
+
+	default:
+	  printf ("?? getopt returned character code 0%o ??\n", c);
+	}
+    }
+
+  if (optind < argc)
+    {
+      printf ("non-option ARGV-elements: ");
+      while (optind < argc)
+	printf ("%s ", argv[optind++]);
+      printf ("\n");
+    }
+
+  exit (0);
+}
+
+#endif /* TEST */
diff -Naur ../orig/sed-4.9/lib/getopt_int.h ./lib/getopt_int.h
--- ../orig/sed-4.9/lib/getopt_int.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/getopt_int.h	2022-12-01 17:13:29.320430800 +0300
@@ -0,0 +1,118 @@
+/* Internal declarations for getopt.
+   Copyright (C) 1989-2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library and is also part of gnulib.
+   Patches to this file should be submitted to both projects.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public
+   License as published by the Free Software Foundation; either
+   version 3 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GETOPT_INT_H
+#define _GETOPT_INT_H	1
+
+#include <getopt.h>
+
+extern int _getopt_internal (int ___argc, char **___argv,
+			     const char *__shortopts,
+			     const struct option *__longopts, int *__longind,
+			     int __long_only, int __posixly_correct);
+
+
+/* Reentrant versions which can handle parsing multiple argument
+   vectors at the same time.  */
+
+/* Describe how to deal with options that follow non-option ARGV-elements.
+
+   REQUIRE_ORDER means don't recognize them as options; stop option
+   processing when the first non-option is seen.  This is what POSIX
+   specifies should happen.
+
+   PERMUTE means permute the contents of ARGV as we scan, so that
+   eventually all the non-options are at the end.  This allows options
+   to be given in any order, even with programs that were not written
+   to expect this.
+
+   RETURN_IN_ORDER is an option available to programs that were
+   written to expect options and other ARGV-elements in any order
+   and that care about the ordering of the two.  We describe each
+   non-option ARGV-element as if it were the argument of an option
+   with character code 1.
+
+   The special argument '--' forces an end of option-scanning regardless
+   of the value of 'ordering'.  In the case of RETURN_IN_ORDER, only
+   '--' can cause 'getopt' to return -1 with 'optind' != ARGC.  */
+
+enum __ord
+  {
+    REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
+  };
+
+/* Data type for reentrant functions.  */
+struct _getopt_data
+{
+  /* These have exactly the same meaning as the corresponding global
+     variables, except that they are used for the reentrant
+     versions of getopt.  */
+  int optind;
+  int opterr;
+  int optopt;
+  char *optarg;
+
+  /* Internal members.  */
+
+  /* True if the internal members have been initialized.  */
+  int __initialized;
+
+  /* The next char to be scanned in the option-element
+     in which the last option character we returned was found.
+     This allows us to pick up the scan where we left off.
+
+     If this is zero, or a null string, it means resume the scan
+     by advancing to the next ARGV-element.  */
+  char *__nextchar;
+
+  /* See __ord above.  */
+  enum __ord __ordering;
+
+  /* Handle permutation of arguments.  */
+
+  /* Describe the part of ARGV that contains non-options that have
+     been skipped.  'first_nonopt' is the index in ARGV of the first
+     of them; 'last_nonopt' is the index after the last of them.  */
+
+  int __first_nonopt;
+  int __last_nonopt;
+};
+
+/* The initializer is necessary to set OPTIND and OPTERR to their
+   default values and to clear the initialization flag.  */
+#define _GETOPT_DATA_INITIALIZER	{ 1, 1 }
+
+extern int _getopt_internal_r (int ___argc, char **___argv,
+			       const char *__shortopts,
+			       const struct option *__longopts, int *__longind,
+			       int __long_only, struct _getopt_data *__data,
+			       int __posixly_correct);
+
+extern int _getopt_long_r (int ___argc, char **___argv,
+			   const char *__shortopts,
+			   const struct option *__longopts, int *__longind,
+			   struct _getopt_data *__data);
+
+extern int _getopt_long_only_r (int ___argc, char **___argv,
+				const char *__shortopts,
+				const struct option *__longopts,
+				int *__longind,
+				struct _getopt_data *__data);
+
+#endif /* getopt_int.h */
diff -Naur ../orig/sed-4.9/lib/inttypes.h ./lib/inttypes.h
--- ../orig/sed-4.9/lib/inttypes.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/inttypes.h	2022-12-01 17:12:55.887152400 +0300
@@ -0,0 +1,1509 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Copyright (C) 2006-2022 Free Software Foundation, Inc.
+   Written by Paul Eggert, Bruno Haible, Derek Price.
+   This file is part of gnulib.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/*
+ * ISO C 99 <inttypes.h> for platforms that lack it.
+ * <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/inttypes.h.html>
+ */
+
+#if __GNUC__ >= 3
+
+#endif
+
+
+/* Include the original <inttypes.h> if it exists, and if this file
+   has not been included yet or if this file includes gnulib stdint.h
+   which in turn includes this file.
+   The include_next requires a split double-inclusion guard.  */
+#if ! defined INTTYPES_H || defined _GL_JUST_INCLUDE_SYSTEM_INTTYPES_H
+# if 0
+
+   /* Some pre-C++11 <stdint.h> implementations need this.  */
+#  if defined __cplusplus && ! defined __STDC_FORMAT_MACROS
+#   define __STDC_FORMAT_MACROS 1
+#  endif
+
+#  include ""
+
+#  define _GL_FINISHED_INCLUDING_SYSTEM_INTTYPES_H
+# endif
+#endif
+
+#if ! defined INTTYPES_H && ! defined _GL_JUST_INCLUDE_SYSTEM_INTTYPES_H
+#define INTTYPES_H
+
+/* Include <stdint.h> or the gnulib replacement.
+   But avoid namespace pollution on glibc systems.  */
+#ifndef __GLIBC__
+# include <stdint.h>
+#endif
+/* Get CHAR_BIT, INT_MAX, LONG_MAX, etc.  */
+#include <limits.h>
+/* On mingw, __USE_MINGW_ANSI_STDIO only works if <stdio.h> is also included */
+#if defined _WIN32 && ! defined __CYGWIN__
+# include <stdio.h>
+#endif
+
+#if !(INT_MAX == 0x7fffffff && INT_MIN + INT_MAX == -1)
+# error "This file assumes that 'int' is 32-bit two's complement. Please report your platform and compiler to <bug-gnulib@gnu.org>."
+#endif
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA (func, rettype, parameters);
+   is to be used when func is a Microsoft deprecated alias, on native Windows.
+   It declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to _func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_MDA (open, int, (const char *filename, int flags, ...));
+ */
+#define _GL_CXXALIAS_MDA(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_MDA (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#define _GL_CXXALIAS_MDA_CAST(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_CAST_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || defined __clang__
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype_gcc, rettype_clang, parameters_and_attributes, "message")
+   is like _GL_WARN_ON_USE (function, "message"), except that in C++ mode the
+   function is declared with the given prototype, consisting of return type,
+   parameters, and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if !defined __cplusplus
+#  define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+     _GL_WARN_ON_USE (function, msg)
+# else
+#  if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes \
+  __attribute__ ((__warning__ (msg)))
+#  elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_clang function parameters_and_attributes \
+  __attribute__ ((__diagnose_if__ (1, msg, "warning")))
+#  elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes
+#  else /* Unsupported.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  endif
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+/* 7.8.1 Macros for format specifiers */
+
+#if defined _TNS_R_TARGET
+   /* Tandem NonStop R series and compatible platforms released before
+      July 2005 support %Ld but not %lld.  */
+# define _LONG_LONG_FORMAT_PREFIX "L"
+#else
+# define _LONG_LONG_FORMAT_PREFIX "ll"
+#endif
+
+#if !defined PRId8
+# ifdef INT8_MAX
+#  define PRId8 "d"
+# endif
+#endif
+#if !defined PRIi8
+# ifdef INT8_MAX
+#  define PRIi8 "i"
+# endif
+#endif
+#if !defined PRIo8
+# ifdef UINT8_MAX
+#  define PRIo8 "o"
+# endif
+#endif
+#if !defined PRIu8
+# ifdef UINT8_MAX
+#  define PRIu8 "u"
+# endif
+#endif
+#if !defined PRIx8
+# ifdef UINT8_MAX
+#  define PRIx8 "x"
+# endif
+#endif
+#if !defined PRIX8
+# ifdef UINT8_MAX
+#  define PRIX8 "X"
+# endif
+#endif
+#if !defined PRId16
+# ifdef INT16_MAX
+#  define PRId16 "d"
+# endif
+#endif
+#if !defined PRIi16
+# ifdef INT16_MAX
+#  define PRIi16 "i"
+# endif
+#endif
+#if !defined PRIo16
+# ifdef UINT16_MAX
+#  define PRIo16 "o"
+# endif
+#endif
+#if !defined PRIu16
+# ifdef UINT16_MAX
+#  define PRIu16 "u"
+# endif
+#endif
+#if !defined PRIx16
+# ifdef UINT16_MAX
+#  define PRIx16 "x"
+# endif
+#endif
+#if !defined PRIX16
+# ifdef UINT16_MAX
+#  define PRIX16 "X"
+# endif
+#endif
+#if !defined PRId32
+# ifdef INT32_MAX
+#  define PRId32 "d"
+# endif
+#endif
+#if !defined PRIi32
+# ifdef INT32_MAX
+#  define PRIi32 "i"
+# endif
+#endif
+#if !defined PRIo32
+# ifdef UINT32_MAX
+#  define PRIo32 "o"
+# endif
+#endif
+#if !defined PRIu32
+# ifdef UINT32_MAX
+#  define PRIu32 "u"
+# endif
+#endif
+#if !defined PRIx32
+# ifdef UINT32_MAX
+#  define PRIx32 "x"
+# endif
+#endif
+#if !defined PRIX32
+# ifdef UINT32_MAX
+#  define PRIX32 "X"
+# endif
+#endif
+#ifdef INT64_MAX
+# if (0 ? defined _LP64 : 0)
+#  define _PRI64_PREFIX "l"
+# elif defined _MSC_VER || defined __MINGW32__
+#  define _PRI64_PREFIX "I64"
+# elif LONG_MAX >> 30 == 1
+#  define _PRI64_PREFIX _LONG_LONG_FORMAT_PREFIX
+# endif
+# if !defined PRId64
+#  define PRId64 _PRI64_PREFIX "d"
+# endif
+# if !defined PRIi64
+#  define PRIi64 _PRI64_PREFIX "i"
+# endif
+#endif
+#ifdef UINT64_MAX
+# if (0 ? defined _LP64 : 0)
+#  define _PRIu64_PREFIX "l"
+# elif defined _MSC_VER || defined __MINGW32__
+#  define _PRIu64_PREFIX "I64"
+# elif ULONG_MAX >> 31 == 1
+#  define _PRIu64_PREFIX _LONG_LONG_FORMAT_PREFIX
+# endif
+# if !defined PRIo64
+#  define PRIo64 _PRIu64_PREFIX "o"
+# endif
+# if !defined PRIu64
+#  define PRIu64 _PRIu64_PREFIX "u"
+# endif
+# if !defined PRIx64
+#  define PRIx64 _PRIu64_PREFIX "x"
+# endif
+# if !defined PRIX64
+#  define PRIX64 _PRIu64_PREFIX "X"
+# endif
+#endif
+
+#if !defined PRIdLEAST8
+# define PRIdLEAST8 "d"
+#endif
+#if !defined PRIiLEAST8
+# define PRIiLEAST8 "i"
+#endif
+#if !defined PRIoLEAST8
+# define PRIoLEAST8 "o"
+#endif
+#if !defined PRIuLEAST8
+# define PRIuLEAST8 "u"
+#endif
+#if !defined PRIxLEAST8
+# define PRIxLEAST8 "x"
+#endif
+#if !defined PRIXLEAST8
+# define PRIXLEAST8 "X"
+#endif
+#if !defined PRIdLEAST16
+# define PRIdLEAST16 "d"
+#endif
+#if !defined PRIiLEAST16
+# define PRIiLEAST16 "i"
+#endif
+#if !defined PRIoLEAST16
+# define PRIoLEAST16 "o"
+#endif
+#if !defined PRIuLEAST16
+# define PRIuLEAST16 "u"
+#endif
+#if !defined PRIxLEAST16
+# define PRIxLEAST16 "x"
+#endif
+#if !defined PRIXLEAST16
+# define PRIXLEAST16 "X"
+#endif
+#if !defined PRIdLEAST32
+# define PRIdLEAST32 "d"
+#endif
+#if !defined PRIiLEAST32
+# define PRIiLEAST32 "i"
+#endif
+#if !defined PRIoLEAST32
+# define PRIoLEAST32 "o"
+#endif
+#if !defined PRIuLEAST32
+# define PRIuLEAST32 "u"
+#endif
+#if !defined PRIxLEAST32
+# define PRIxLEAST32 "x"
+#endif
+#if !defined PRIXLEAST32
+# define PRIXLEAST32 "X"
+#endif
+#ifdef INT64_MAX
+# if !defined PRIdLEAST64
+#  define PRIdLEAST64 PRId64
+# endif
+# if !defined PRIiLEAST64
+#  define PRIiLEAST64 PRIi64
+# endif
+#endif
+#ifdef UINT64_MAX
+# if !defined PRIoLEAST64
+#  define PRIoLEAST64 PRIo64
+# endif
+# if !defined PRIuLEAST64
+#  define PRIuLEAST64 PRIu64
+# endif
+# if !defined PRIxLEAST64
+#  define PRIxLEAST64 PRIx64
+# endif
+# if !defined PRIXLEAST64
+#  define PRIXLEAST64 PRIX64
+# endif
+#endif
+
+#if !defined PRIdFAST8
+# if INT_FAST8_MAX > INT32_MAX
+#  define PRIdFAST8 PRId64
+# else
+#  define PRIdFAST8 "d"
+# endif
+#endif
+#if !defined PRIiFAST8
+# if INT_FAST8_MAX > INT32_MAX
+#  define PRIiFAST8 PRIi64
+# else
+#  define PRIiFAST8 "i"
+# endif
+#endif
+#if !defined PRIoFAST8
+# if UINT_FAST8_MAX > UINT32_MAX
+#  define PRIoFAST8 PRIo64
+# else
+#  define PRIoFAST8 "o"
+# endif
+#endif
+#if !defined PRIuFAST8
+# if UINT_FAST8_MAX > UINT32_MAX
+#  define PRIuFAST8 PRIu64
+# else
+#  define PRIuFAST8 "u"
+# endif
+#endif
+#if !defined PRIxFAST8
+# if UINT_FAST8_MAX > UINT32_MAX
+#  define PRIxFAST8 PRIx64
+# else
+#  define PRIxFAST8 "x"
+# endif
+#endif
+#if !defined PRIXFAST8
+# if UINT_FAST8_MAX > UINT32_MAX
+#  define PRIXFAST8 PRIX64
+# else
+#  define PRIXFAST8 "X"
+# endif
+#endif
+#if !defined PRIdFAST16
+# if INT_FAST16_MAX > INT32_MAX
+#  define PRIdFAST16 PRId64
+# else
+#  define PRIdFAST16 "d"
+# endif
+#endif
+#if !defined PRIiFAST16
+# if INT_FAST16_MAX > INT32_MAX
+#  define PRIiFAST16 PRIi64
+# else
+#  define PRIiFAST16 "i"
+# endif
+#endif
+#if !defined PRIoFAST16
+# if UINT_FAST16_MAX > UINT32_MAX
+#  define PRIoFAST16 PRIo64
+# else
+#  define PRIoFAST16 "o"
+# endif
+#endif
+#if !defined PRIuFAST16
+# if UINT_FAST16_MAX > UINT32_MAX
+#  define PRIuFAST16 PRIu64
+# else
+#  define PRIuFAST16 "u"
+# endif
+#endif
+#if !defined PRIxFAST16
+# if UINT_FAST16_MAX > UINT32_MAX
+#  define PRIxFAST16 PRIx64
+# else
+#  define PRIxFAST16 "x"
+# endif
+#endif
+#if !defined PRIXFAST16
+# if UINT_FAST16_MAX > UINT32_MAX
+#  define PRIXFAST16 PRIX64
+# else
+#  define PRIXFAST16 "X"
+# endif
+#endif
+#if !defined PRIdFAST32
+# if INT_FAST32_MAX > INT32_MAX
+#  define PRIdFAST32 PRId64
+# else
+#  define PRIdFAST32 "d"
+# endif
+#endif
+#if !defined PRIiFAST32
+# if INT_FAST32_MAX > INT32_MAX
+#  define PRIiFAST32 PRIi64
+# else
+#  define PRIiFAST32 "i"
+# endif
+#endif
+#if !defined PRIoFAST32
+# if UINT_FAST32_MAX > UINT32_MAX
+#  define PRIoFAST32 PRIo64
+# else
+#  define PRIoFAST32 "o"
+# endif
+#endif
+#if !defined PRIuFAST32
+# if UINT_FAST32_MAX > UINT32_MAX
+#  define PRIuFAST32 PRIu64
+# else
+#  define PRIuFAST32 "u"
+# endif
+#endif
+#if !defined PRIxFAST32
+# if UINT_FAST32_MAX > UINT32_MAX
+#  define PRIxFAST32 PRIx64
+# else
+#  define PRIxFAST32 "x"
+# endif
+#endif
+#if !defined PRIXFAST32
+# if UINT_FAST32_MAX > UINT32_MAX
+#  define PRIXFAST32 PRIX64
+# else
+#  define PRIXFAST32 "X"
+# endif
+#endif
+#ifdef INT64_MAX
+# if !defined PRIdFAST64
+#  define PRIdFAST64 PRId64
+# endif
+# if !defined PRIiFAST64
+#  define PRIiFAST64 PRIi64
+# endif
+#endif
+#ifdef UINT64_MAX
+# if !defined PRIoFAST64
+#  define PRIoFAST64 PRIo64
+# endif
+# if !defined PRIuFAST64
+#  define PRIuFAST64 PRIu64
+# endif
+# if !defined PRIxFAST64
+#  define PRIxFAST64 PRIx64
+# endif
+# if !defined PRIXFAST64
+#  define PRIXFAST64 PRIX64
+# endif
+#endif
+
+#if !defined PRIdMAX
+# if 1
+#  define PRIdMAX PRId64
+# else
+#  define PRIdMAX "ld"
+# endif
+#endif
+#if !defined PRIiMAX
+# if 1
+#  define PRIiMAX PRIi64
+# else
+#  define PRIiMAX "li"
+# endif
+#endif
+#if !defined PRIoMAX
+# if 1
+#  define PRIoMAX PRIo64
+# else
+#  define PRIoMAX "lo"
+# endif
+#endif
+#if !defined PRIuMAX
+# if 1
+#  define PRIuMAX PRIu64
+# else
+#  define PRIuMAX "lu"
+# endif
+#endif
+#if !defined PRIxMAX
+# if 1
+#  define PRIxMAX PRIx64
+# else
+#  define PRIxMAX "lx"
+# endif
+#endif
+#if !defined PRIXMAX
+# if 1
+#  define PRIXMAX PRIX64
+# else
+#  define PRIXMAX "lX"
+# endif
+#endif
+
+#if !defined PRIdPTR
+# ifdef INTPTR_MAX
+#  define PRIdPTR "l" "d"
+# endif
+#endif
+#if !defined PRIiPTR
+# ifdef INTPTR_MAX
+#  define PRIiPTR "l" "i"
+# endif
+#endif
+#if !defined PRIoPTR
+# ifdef UINTPTR_MAX
+#  define PRIoPTR "l" "o"
+# endif
+#endif
+#if !defined PRIuPTR
+# ifdef UINTPTR_MAX
+#  define PRIuPTR "l" "u"
+# endif
+#endif
+#if !defined PRIxPTR
+# ifdef UINTPTR_MAX
+#  define PRIxPTR "l" "x"
+# endif
+#endif
+#if !defined PRIXPTR
+# ifdef UINTPTR_MAX
+#  define PRIXPTR "l" "X"
+# endif
+#endif
+
+#if !defined SCNd8
+# ifdef INT8_MAX
+#  define SCNd8 "hhd"
+# endif
+#endif
+#if !defined SCNi8
+# ifdef INT8_MAX
+#  define SCNi8 "hhi"
+# endif
+#endif
+#if !defined SCNo8
+# ifdef UINT8_MAX
+#  define SCNo8 "hho"
+# endif
+#endif
+#if !defined SCNu8
+# ifdef UINT8_MAX
+#  define SCNu8 "hhu"
+# endif
+#endif
+#if !defined SCNx8
+# ifdef UINT8_MAX
+#  define SCNx8 "hhx"
+# endif
+#endif
+#if !defined SCNd16
+# ifdef INT16_MAX
+#  define SCNd16 "hd"
+# endif
+#endif
+#if !defined SCNi16
+# ifdef INT16_MAX
+#  define SCNi16 "hi"
+# endif
+#endif
+#if !defined SCNo16
+# ifdef UINT16_MAX
+#  define SCNo16 "ho"
+# endif
+#endif
+#if !defined SCNu16
+# ifdef UINT16_MAX
+#  define SCNu16 "hu"
+# endif
+#endif
+#if !defined SCNx16
+# ifdef UINT16_MAX
+#  define SCNx16 "hx"
+# endif
+#endif
+#if !defined SCNd32
+# ifdef INT32_MAX
+#  define SCNd32 "d"
+# endif
+#endif
+#if !defined SCNi32
+# ifdef INT32_MAX
+#  define SCNi32 "i"
+# endif
+#endif
+#if !defined SCNo32
+# ifdef UINT32_MAX
+#  define SCNo32 "o"
+# endif
+#endif
+#if !defined SCNu32
+# ifdef UINT32_MAX
+#  define SCNu32 "u"
+# endif
+#endif
+#if !defined SCNx32
+# ifdef UINT32_MAX
+#  define SCNx32 "x"
+# endif
+#endif
+#ifdef INT64_MAX
+# if (0 ? defined _LP64 : 0)
+#  define _SCN64_PREFIX "l"
+# elif defined _MSC_VER || defined __MINGW32__
+#  define _SCN64_PREFIX "I64"
+# elif LONG_MAX >> 30 == 1
+#  define _SCN64_PREFIX _LONG_LONG_FORMAT_PREFIX
+# endif
+# if !defined SCNd64
+#  define SCNd64 _SCN64_PREFIX "d"
+# endif
+# if !defined SCNi64
+#  define SCNi64 _SCN64_PREFIX "i"
+# endif
+#endif
+#ifdef UINT64_MAX
+# if (0 ? defined _LP64 : 0)
+#  define _SCNu64_PREFIX "l"
+# elif defined _MSC_VER || defined __MINGW32__
+#  define _SCNu64_PREFIX "I64"
+# elif ULONG_MAX >> 31 == 1
+#  define _SCNu64_PREFIX _LONG_LONG_FORMAT_PREFIX
+# endif
+# if !defined SCNo64
+#  define SCNo64 _SCNu64_PREFIX "o"
+# endif
+# if !defined SCNu64
+#  define SCNu64 _SCNu64_PREFIX "u"
+# endif
+# if !defined SCNx64
+#  define SCNx64 _SCNu64_PREFIX "x"
+# endif
+#endif
+
+#if !defined SCNdLEAST8
+# define SCNdLEAST8 "hhd"
+#endif
+#if !defined SCNiLEAST8
+# define SCNiLEAST8 "hhi"
+#endif
+#if !defined SCNoLEAST8
+# define SCNoLEAST8 "hho"
+#endif
+#if !defined SCNuLEAST8
+# define SCNuLEAST8 "hhu"
+#endif
+#if !defined SCNxLEAST8
+# define SCNxLEAST8 "hhx"
+#endif
+#if !defined SCNdLEAST16
+# define SCNdLEAST16 "hd"
+#endif
+#if !defined SCNiLEAST16
+# define SCNiLEAST16 "hi"
+#endif
+#if !defined SCNoLEAST16
+# define SCNoLEAST16 "ho"
+#endif
+#if !defined SCNuLEAST16
+# define SCNuLEAST16 "hu"
+#endif
+#if !defined SCNxLEAST16
+# define SCNxLEAST16 "hx"
+#endif
+#if !defined SCNdLEAST32
+# define SCNdLEAST32 "d"
+#endif
+#if !defined SCNiLEAST32
+# define SCNiLEAST32 "i"
+#endif
+#if !defined SCNoLEAST32
+# define SCNoLEAST32 "o"
+#endif
+#if !defined SCNuLEAST32
+# define SCNuLEAST32 "u"
+#endif
+#if !defined SCNxLEAST32
+# define SCNxLEAST32 "x"
+#endif
+#ifdef INT64_MAX
+# if !defined SCNdLEAST64
+#  define SCNdLEAST64 SCNd64
+# endif
+# if !defined SCNiLEAST64
+#  define SCNiLEAST64 SCNi64
+# endif
+#endif
+#ifdef UINT64_MAX
+# if !defined SCNoLEAST64
+#  define SCNoLEAST64 SCNo64
+# endif
+# if !defined SCNuLEAST64
+#  define SCNuLEAST64 SCNu64
+# endif
+# if !defined SCNxLEAST64
+#  define SCNxLEAST64 SCNx64
+# endif
+#endif
+
+#if !defined SCNdFAST8
+# if INT_FAST8_MAX > INT32_MAX
+#  define SCNdFAST8 SCNd64
+# elif INT_FAST8_MAX == 0x7fff
+#  define SCNdFAST8 "hd"
+# elif INT_FAST8_MAX == 0x7f
+#  define SCNdFAST8 "hhd"
+# else
+#  define SCNdFAST8 "d"
+# endif
+#endif
+#if !defined SCNiFAST8
+# if INT_FAST8_MAX > INT32_MAX
+#  define SCNiFAST8 SCNi64
+# elif INT_FAST8_MAX == 0x7fff
+#  define SCNiFAST8 "hi"
+# elif INT_FAST8_MAX == 0x7f
+#  define SCNiFAST8 "hhi"
+# else
+#  define SCNiFAST8 "i"
+# endif
+#endif
+#if !defined SCNoFAST8
+# if UINT_FAST8_MAX > UINT32_MAX
+#  define SCNoFAST8 SCNo64
+# elif UINT_FAST8_MAX == 0xffff
+#  define SCNoFAST8 "ho"
+# elif UINT_FAST8_MAX == 0xff
+#  define SCNoFAST8 "hho"
+# else
+#  define SCNoFAST8 "o"
+# endif
+#endif
+#if !defined SCNuFAST8
+# if UINT_FAST8_MAX > UINT32_MAX
+#  define SCNuFAST8 SCNu64
+# elif UINT_FAST8_MAX == 0xffff
+#  define SCNuFAST8 "hu"
+# elif UINT_FAST8_MAX == 0xff
+#  define SCNuFAST8 "hhu"
+# else
+#  define SCNuFAST8 "u"
+# endif
+#endif
+#if !defined SCNxFAST8
+# if UINT_FAST8_MAX > UINT32_MAX
+#  define SCNxFAST8 SCNx64
+# elif UINT_FAST8_MAX == 0xffff
+#  define SCNxFAST8 "hx"
+# elif UINT_FAST8_MAX == 0xff
+#  define SCNxFAST8 "hhx"
+# else
+#  define SCNxFAST8 "x"
+# endif
+#endif
+#if !defined SCNdFAST16
+# if INT_FAST16_MAX > INT32_MAX
+#  define SCNdFAST16 SCNd64
+# elif INT_FAST16_MAX == 0x7fff
+#  define SCNdFAST16 "hd"
+# else
+#  define SCNdFAST16 "d"
+# endif
+#endif
+#if !defined SCNiFAST16
+# if INT_FAST16_MAX > INT32_MAX
+#  define SCNiFAST16 SCNi64
+# elif INT_FAST16_MAX == 0x7fff
+#  define SCNiFAST16 "hi"
+# else
+#  define SCNiFAST16 "i"
+# endif
+#endif
+#if !defined SCNoFAST16
+# if UINT_FAST16_MAX > UINT32_MAX
+#  define SCNoFAST16 SCNo64
+# elif UINT_FAST16_MAX == 0xffff
+#  define SCNoFAST16 "ho"
+# else
+#  define SCNoFAST16 "o"
+# endif
+#endif
+#if !defined SCNuFAST16
+# if UINT_FAST16_MAX > UINT32_MAX
+#  define SCNuFAST16 SCNu64
+# elif UINT_FAST16_MAX == 0xffff
+#  define SCNuFAST16 "hu"
+# else
+#  define SCNuFAST16 "u"
+# endif
+#endif
+#if !defined SCNxFAST16
+# if UINT_FAST16_MAX > UINT32_MAX
+#  define SCNxFAST16 SCNx64
+# elif UINT_FAST16_MAX == 0xffff
+#  define SCNxFAST16 "hx"
+# else
+#  define SCNxFAST16 "x"
+# endif
+#endif
+#if !defined SCNdFAST32
+# if INT_FAST32_MAX > INT32_MAX
+#  define SCNdFAST32 SCNd64
+# else
+#  define SCNdFAST32 "d"
+# endif
+#endif
+#if !defined SCNiFAST32
+# if INT_FAST32_MAX > INT32_MAX
+#  define SCNiFAST32 SCNi64
+# else
+#  define SCNiFAST32 "i"
+# endif
+#endif
+#if !defined SCNoFAST32
+# if UINT_FAST32_MAX > UINT32_MAX
+#  define SCNoFAST32 SCNo64
+# else
+#  define SCNoFAST32 "o"
+# endif
+#endif
+#if !defined SCNuFAST32
+# if UINT_FAST32_MAX > UINT32_MAX
+#  define SCNuFAST32 SCNu64
+# else
+#  define SCNuFAST32 "u"
+# endif
+#endif
+#if !defined SCNxFAST32
+# if UINT_FAST32_MAX > UINT32_MAX
+#  define SCNxFAST32 SCNx64
+# else
+#  define SCNxFAST32 "x"
+# endif
+#endif
+#ifdef INT64_MAX
+# if !defined SCNdFAST64
+#  define SCNdFAST64 SCNd64
+# endif
+# if !defined SCNiFAST64
+#  define SCNiFAST64 SCNi64
+# endif
+#endif
+#ifdef UINT64_MAX
+# if !defined SCNoFAST64
+#  define SCNoFAST64 SCNo64
+# endif
+# if !defined SCNuFAST64
+#  define SCNuFAST64 SCNu64
+# endif
+# if !defined SCNxFAST64
+#  define SCNxFAST64 SCNx64
+# endif
+#endif
+
+#if !defined SCNdMAX
+# if 1
+#  define SCNdMAX SCNd64
+# else
+#  define SCNdMAX "ld"
+# endif
+#endif
+#if !defined SCNiMAX
+# if 1
+#  define SCNiMAX SCNi64
+# else
+#  define SCNiMAX "li"
+# endif
+#endif
+#if !defined SCNoMAX
+# if 1
+#  define SCNoMAX SCNo64
+# else
+#  define SCNoMAX "lo"
+# endif
+#endif
+#if !defined SCNuMAX
+# if 1
+#  define SCNuMAX SCNu64
+# else
+#  define SCNuMAX "lu"
+# endif
+#endif
+#if !defined SCNxMAX
+# if 1
+#  define SCNxMAX SCNx64
+# else
+#  define SCNxMAX "lx"
+# endif
+#endif
+
+#if !defined SCNdPTR
+# ifdef INTPTR_MAX
+#  define SCNdPTR "l" "d"
+# endif
+#endif
+#if !defined SCNiPTR
+# ifdef INTPTR_MAX
+#  define SCNiPTR "l" "i"
+# endif
+#endif
+#if !defined SCNoPTR
+# ifdef UINTPTR_MAX
+#  define SCNoPTR "l" "o"
+# endif
+#endif
+#if !defined SCNuPTR
+# ifdef UINTPTR_MAX
+#  define SCNuPTR "l" "u"
+# endif
+#endif
+#if !defined SCNxPTR
+# ifdef UINTPTR_MAX
+#  define SCNxPTR "l" "x"
+# endif
+#endif
+
+/* 7.8.2 Functions for greatest-width integer types */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if 0
+# if !1
+extern intmax_t imaxabs (intmax_t);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef imaxabs
+# if HAVE_RAW_DECL_IMAXABS
+_GL_WARN_ON_USE (imaxabs, "imaxabs is unportable - "
+                 "use gnulib module imaxabs for portability");
+# endif
+#endif
+
+#if 0
+# if !1
+#  if !GNULIB_defined_imaxdiv_t
+typedef struct { intmax_t quot; intmax_t rem; } imaxdiv_t;
+#   define GNULIB_defined_imaxdiv_t 1
+#  endif
+# endif
+# if !1
+extern imaxdiv_t imaxdiv (intmax_t, intmax_t);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef imaxdiv
+# if HAVE_RAW_DECL_IMAXDIV
+_GL_WARN_ON_USE (imaxdiv, "imaxdiv is unportable - "
+                 "use gnulib module imaxdiv for portability");
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strtoimax
+#   define strtoimax rpl_strtoimax
+#  endif
+_GL_FUNCDECL_RPL (strtoimax, intmax_t,
+                  (const char *restrict, char **restrict, int)
+                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strtoimax, intmax_t,
+                  (const char *restrict, char **restrict, int));
+# else
+#  if !1
+#   undef strtoimax
+_GL_FUNCDECL_SYS (strtoimax, intmax_t,
+                  (const char *restrict, char **restrict, int)
+                  _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (strtoimax, intmax_t,
+                  (const char *restrict, char **restrict, int));
+# endif
+_GL_CXXALIASWARN (strtoimax);
+#elif defined GNULIB_POSIXCHECK
+# undef strtoimax
+# if HAVE_RAW_DECL_STRTOIMAX
+_GL_WARN_ON_USE (strtoimax, "strtoimax is unportable - "
+                 "use gnulib module strtoimax for portability");
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strtoumax
+#   define strtoumax rpl_strtoumax
+#  endif
+_GL_FUNCDECL_RPL (strtoumax, uintmax_t,
+                  (const char *restrict, char **restrict, int)
+                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strtoumax, uintmax_t,
+                  (const char *restrict, char **restrict, int));
+# else
+#  if !1
+#   undef strtoumax
+_GL_FUNCDECL_SYS (strtoumax, uintmax_t,
+                  (const char *restrict, char **restrict, int)
+                  _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (strtoumax, uintmax_t,
+                  (const char *restrict, char **restrict, int));
+# endif
+_GL_CXXALIASWARN (strtoumax);
+#elif defined GNULIB_POSIXCHECK
+# undef strtoumax
+# if HAVE_RAW_DECL_STRTOUMAX
+_GL_WARN_ON_USE (strtoumax, "strtoumax is unportable - "
+                 "use gnulib module strtoumax for portability");
+# endif
+#endif
+
+/* Don't bother defining or declaring wcstoimax and wcstoumax, since
+   wide-character functions like this are hardly ever useful.  */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !defined INTTYPES_H && !defined _GL_JUST_INCLUDE_SYSTEM_INTTYPES_H */
diff -Naur ../orig/sed-4.9/lib/langinfo.h ./lib/langinfo.h
--- ../orig/sed-4.9/lib/langinfo.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/langinfo.h	2022-12-01 17:12:56.033160700 +0300
@@ -0,0 +1,703 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Substitute for and wrapper around <langinfo.h>.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/*
+ * POSIX <langinfo.h> for platforms that lack it or have an incomplete one.
+ * <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html>
+ */
+
+#ifndef _GL_LANGINFO_H
+
+#if __GNUC__ >= 3
+
+#endif
+
+
+/* The include_next requires a split double-inclusion guard.  */
+#if 0
+# include ""
+#endif
+
+#ifndef _GL_LANGINFO_H
+#define _GL_LANGINFO_H
+
+
+#if !0
+
+/* A platform that lacks <langinfo.h>.  */
+
+/* Assume that it also lacks <nl_types.h> and the nl_item type.  */
+# if !GNULIB_defined_nl_item
+typedef int nl_item;
+#  define GNULIB_defined_nl_item 1
+# endif
+
+/* nl_langinfo items of the LC_CTYPE category */
+# define CODESET     10000
+/* nl_langinfo items of the LC_NUMERIC category */
+# define RADIXCHAR   10001
+# define DECIMAL_POINT RADIXCHAR
+# define THOUSEP     10002
+# define THOUSANDS_SEP THOUSEP
+# define GROUPING    10114
+/* nl_langinfo items of the LC_TIME category */
+# define D_T_FMT     10003
+# define D_FMT       10004
+# define T_FMT       10005
+# define T_FMT_AMPM  10006
+# define AM_STR      10007
+# define PM_STR      10008
+# define DAY_1       10009
+# define DAY_2       (DAY_1 + 1)
+# define DAY_3       (DAY_1 + 2)
+# define DAY_4       (DAY_1 + 3)
+# define DAY_5       (DAY_1 + 4)
+# define DAY_6       (DAY_1 + 5)
+# define DAY_7       (DAY_1 + 6)
+# define ABDAY_1     10016
+# define ABDAY_2     (ABDAY_1 + 1)
+# define ABDAY_3     (ABDAY_1 + 2)
+# define ABDAY_4     (ABDAY_1 + 3)
+# define ABDAY_5     (ABDAY_1 + 4)
+# define ABDAY_6     (ABDAY_1 + 5)
+# define ABDAY_7     (ABDAY_1 + 6)
+# define MON_1       10023
+# define MON_2       (MON_1 + 1)
+# define MON_3       (MON_1 + 2)
+# define MON_4       (MON_1 + 3)
+# define MON_5       (MON_1 + 4)
+# define MON_6       (MON_1 + 5)
+# define MON_7       (MON_1 + 6)
+# define MON_8       (MON_1 + 7)
+# define MON_9       (MON_1 + 8)
+# define MON_10      (MON_1 + 9)
+# define MON_11      (MON_1 + 10)
+# define MON_12      (MON_1 + 11)
+# define ALTMON_1    10200
+# define ALTMON_2    (ALTMON_1 + 1)
+# define ALTMON_3    (ALTMON_1 + 2)
+# define ALTMON_4    (ALTMON_1 + 3)
+# define ALTMON_5    (ALTMON_1 + 4)
+# define ALTMON_6    (ALTMON_1 + 5)
+# define ALTMON_7    (ALTMON_1 + 6)
+# define ALTMON_8    (ALTMON_1 + 7)
+# define ALTMON_9    (ALTMON_1 + 8)
+# define ALTMON_10   (ALTMON_1 + 9)
+# define ALTMON_11   (ALTMON_1 + 10)
+# define ALTMON_12   (ALTMON_1 + 11)
+# define ABMON_1     10035
+# define ABMON_2     (ABMON_1 + 1)
+# define ABMON_3     (ABMON_1 + 2)
+# define ABMON_4     (ABMON_1 + 3)
+# define ABMON_5     (ABMON_1 + 4)
+# define ABMON_6     (ABMON_1 + 5)
+# define ABMON_7     (ABMON_1 + 6)
+# define ABMON_8     (ABMON_1 + 7)
+# define ABMON_9     (ABMON_1 + 8)
+# define ABMON_10    (ABMON_1 + 9)
+# define ABMON_11    (ABMON_1 + 10)
+# define ABMON_12    (ABMON_1 + 11)
+# define ERA         10047
+# define ERA_D_FMT   10048
+# define ERA_D_T_FMT 10049
+# define ERA_T_FMT   10050
+# define ALT_DIGITS  10051
+/* nl_langinfo items of the LC_MONETARY category */
+# define CRNCYSTR    10052
+# define CURRENCY_SYMBOL   CRNCYSTR
+# define INT_CURR_SYMBOL   10100
+# define MON_DECIMAL_POINT 10101
+# define MON_THOUSANDS_SEP 10102
+# define MON_GROUPING      10103
+# define POSITIVE_SIGN     10104
+# define NEGATIVE_SIGN     10105
+# define FRAC_DIGITS       10106
+# define INT_FRAC_DIGITS   10107
+# define P_CS_PRECEDES     10108
+# define N_CS_PRECEDES     10109
+# define P_SEP_BY_SPACE    10110
+# define N_SEP_BY_SPACE    10111
+# define P_SIGN_POSN       10112
+# define N_SIGN_POSN       10113
+/* nl_langinfo items of the LC_MESSAGES category */
+# define YESEXPR     10053
+# define NOEXPR      10054
+
+#else
+
+/* A platform that has <langinfo.h>.  */
+
+# if !0
+#  define CODESET     10000
+#  define GNULIB_defined_CODESET 1
+# endif
+
+# if !0
+#  define T_FMT_AMPM  10006
+#  define GNULIB_defined_T_FMT_AMPM 1
+# endif
+
+# if !0
+#  define ALTMON_1    10200
+#  define ALTMON_2    (ALTMON_1 + 1)
+#  define ALTMON_3    (ALTMON_1 + 2)
+#  define ALTMON_4    (ALTMON_1 + 3)
+#  define ALTMON_5    (ALTMON_1 + 4)
+#  define ALTMON_6    (ALTMON_1 + 5)
+#  define ALTMON_7    (ALTMON_1 + 6)
+#  define ALTMON_8    (ALTMON_1 + 7)
+#  define ALTMON_9    (ALTMON_1 + 8)
+#  define ALTMON_10   (ALTMON_1 + 9)
+#  define ALTMON_11   (ALTMON_1 + 10)
+#  define ALTMON_12   (ALTMON_1 + 11)
+#  define GNULIB_defined_ALTMON 1
+# endif
+
+# if !0
+#  define ERA         10047
+#  define ERA_D_FMT   10048
+#  define ERA_D_T_FMT 10049
+#  define ERA_T_FMT   10050
+#  define ALT_DIGITS  10051
+#  define GNULIB_defined_ERA 1
+# endif
+
+# if !0
+#  define YESEXPR     10053
+#  define NOEXPR      10054
+#  define GNULIB_defined_YESEXPR 1
+# endif
+
+#endif
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA (func, rettype, parameters);
+   is to be used when func is a Microsoft deprecated alias, on native Windows.
+   It declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to _func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_MDA (open, int, (const char *filename, int flags, ...));
+ */
+#define _GL_CXXALIAS_MDA(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_MDA (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#define _GL_CXXALIAS_MDA_CAST(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_CAST_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype_gcc, rettype_clang, parameters_and_attributes, "message")
+   is like _GL_WARN_ON_USE (function, "message"), except that in C++ mode the
+   function is declared with the given prototype, consisting of return type,
+   parameters, and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if !defined __cplusplus
+#  define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+     _GL_WARN_ON_USE (function, msg)
+# else
+#  if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes \
+  __attribute__ ((__warning__ (msg)))
+#  elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_clang function parameters_and_attributes \
+  __attribute__ ((__diagnose_if__ (1, msg, "warning")))
+#  elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes
+#  else /* Unsupported.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  endif
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+/* Declare overridden functions.  */
+
+
+/* Return a piece of locale dependent information.
+   Note: The difference between nl_langinfo (CODESET) and locale_charset ()
+   is that the latter normalizes the encoding names to GNU conventions.  */
+
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef nl_langinfo
+#   define nl_langinfo rpl_nl_langinfo
+#  endif
+_GL_FUNCDECL_RPL (nl_langinfo, char *, (nl_item item));
+_GL_CXXALIAS_RPL (nl_langinfo, char *, (nl_item item));
+# else
+#  if !0
+_GL_FUNCDECL_SYS (nl_langinfo, char *, (nl_item item));
+#  endif
+_GL_CXXALIAS_SYS (nl_langinfo, char *, (nl_item item));
+# endif
+_GL_CXXALIASWARN (nl_langinfo);
+#elif defined GNULIB_POSIXCHECK
+# undef nl_langinfo
+# if HAVE_RAW_DECL_NL_LANGINFO
+_GL_WARN_ON_USE (nl_langinfo, "nl_langinfo is not portable - "
+                 "use gnulib module nl_langinfo for portability");
+# endif
+#endif
+
+
+#endif /* _GL_LANGINFO_H */
+#endif /* _GL_LANGINFO_H */
diff -Naur ../orig/sed-4.9/lib/limits.h ./lib/limits.h
--- ../orig/sed-4.9/lib/limits.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/limits.h	2022-12-01 17:13:19.119986300 +0300
@@ -0,0 +1,132 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A GNU-like <limits.h>.
+
+   Copyright 2016-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#if __GNUC__ >= 3
+
+#endif
+
+
+#if defined _GL_ALREADY_INCLUDING_LIMITS_H
+/* Special invocation convention:
+   On Haiku/x86_64, we have a sequence of nested includes
+   <limits.h> -> <syslimits.h> -> <limits.h>.
+   In this situation, LONG_MAX and INT_MAX are not yet defined,
+   therefore we should not attempt to define LONG_BIT.  */
+
+#include ""
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_LIMITS_H
+
+# define _GL_ALREADY_INCLUDING_LIMITS_H
+
+/* The include_next requires a split double-inclusion guard.  */
+# include "C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\INCLUDE\limits.h"
+
+# undef _GL_ALREADY_INCLUDING_LIMITS_H
+
+#ifndef _GL_LIMITS_H
+#define _GL_LIMITS_H
+
+#ifndef LLONG_MIN
+# if defined LONG_LONG_MIN /* HP-UX 11.31 */
+#  define LLONG_MIN LONG_LONG_MIN
+# elif defined LONGLONG_MIN /* IRIX 6.5 */
+#  define LLONG_MIN LONGLONG_MIN
+# elif defined __GNUC__
+#  define LLONG_MIN (- __LONG_LONG_MAX__ - 1LL)
+# endif
+#endif
+#ifndef LLONG_MAX
+# if defined LONG_LONG_MAX /* HP-UX 11.31 */
+#  define LLONG_MAX LONG_LONG_MAX
+# elif defined LONGLONG_MAX /* IRIX 6.5 */
+#  define LLONG_MAX LONGLONG_MAX
+# elif defined __GNUC__
+#  define LLONG_MAX __LONG_LONG_MAX__
+# endif
+#endif
+#ifndef ULLONG_MAX
+# if defined ULONG_LONG_MAX /* HP-UX 11.31 */
+#  define ULLONG_MAX ULONG_LONG_MAX
+# elif defined ULONGLONG_MAX /* IRIX 6.5 */
+#  define ULLONG_MAX ULONGLONG_MAX
+# elif defined __GNUC__
+#  define ULLONG_MAX (__LONG_LONG_MAX__ * 2ULL + 1ULL)
+# endif
+#endif
+
+/* The number of usable bits in an unsigned or signed integer type
+   with minimum value MIN and maximum value MAX, as an int expression
+   suitable in #if.  Cover all known practical hosts.  This
+   implementation exploits the fact that MAX is 1 less than a power of
+   2, and merely counts the number of 1 bits in MAX; "COBn" means
+   "count the number of 1 bits in the low-order n bits").  */
+#define _GL_INTEGER_WIDTH(min, max) (((min) < 0) + _GL_COB128 (max))
+#define _GL_COB128(n) (_GL_COB64 ((n) >> 31 >> 31 >> 2) + _GL_COB64 (n))
+#define _GL_COB64(n) (_GL_COB32 ((n) >> 31 >> 1) + _GL_COB32 (n))
+#define _GL_COB32(n) (_GL_COB16 ((n) >> 16) + _GL_COB16 (n))
+#define _GL_COB16(n) (_GL_COB8 ((n) >> 8) + _GL_COB8 (n))
+#define _GL_COB8(n) (_GL_COB4 ((n) >> 4) + _GL_COB4 (n))
+#define _GL_COB4(n) (!!((n) & 8) + !!((n) & 4) + !!((n) & 2) + !!((n) & 1))
+
+#ifndef WORD_BIT
+/* Assume 'int' is 32 bits wide.  */
+# define WORD_BIT 32
+#endif
+#ifndef LONG_BIT
+/* Assume 'long' is 32 or 64 bits wide.  */
+# if LONG_MAX == INT_MAX
+#  define LONG_BIT 32
+# else
+#  define LONG_BIT 64
+# endif
+#endif
+
+/* Macros specified by C2x and by ISO/IEC TS 18661-1:2014.  */
+
+#if (! defined ULLONG_WIDTH                                             \
+     && (defined _GNU_SOURCE || defined __STDC_WANT_IEC_60559_BFP_EXT__ \
+         || (defined __STDC_VERSION__ && 201710 < __STDC_VERSION__)))
+# define CHAR_WIDTH _GL_INTEGER_WIDTH (CHAR_MIN, CHAR_MAX)
+# define SCHAR_WIDTH _GL_INTEGER_WIDTH (SCHAR_MIN, SCHAR_MAX)
+# define UCHAR_WIDTH _GL_INTEGER_WIDTH (0, UCHAR_MAX)
+# define SHRT_WIDTH _GL_INTEGER_WIDTH (SHRT_MIN, SHRT_MAX)
+# define USHRT_WIDTH _GL_INTEGER_WIDTH (0, USHRT_MAX)
+# define INT_WIDTH _GL_INTEGER_WIDTH (INT_MIN, INT_MAX)
+# define UINT_WIDTH _GL_INTEGER_WIDTH (0, UINT_MAX)
+# define LONG_WIDTH _GL_INTEGER_WIDTH (LONG_MIN, LONG_MAX)
+# define ULONG_WIDTH _GL_INTEGER_WIDTH (0, ULONG_MAX)
+# define LLONG_WIDTH _GL_INTEGER_WIDTH (LLONG_MIN, LLONG_MAX)
+# define ULLONG_WIDTH _GL_INTEGER_WIDTH (0, ULLONG_MAX)
+#endif
+
+/* Macros specified by C2x.  */
+
+#if (! defined BOOL_WIDTH \
+     && (defined _GNU_SOURCE \
+         || (defined __STDC_VERSION__ && 201710 < __STDC_VERSION__)))
+# define BOOL_MAX 1
+# define BOOL_WIDTH 1
+#endif
+
+#endif /* _GL_LIMITS_H */
+#endif /* _GL_LIMITS_H */
+#endif
diff -Naur ../orig/sed-4.9/lib/localcharset.c ./lib/localcharset.c
--- ../orig/sed-4.9/lib/localcharset.c	2022-07-02 21:22:03.000000000 +0300
+++ ./lib/localcharset.c	2022-12-01 17:08:55.505645500 +0300
@@ -925,25 +925,32 @@
   char *current_locale = setlocale (LC_CTYPE, NULL);
   char *pdot = strrchr (current_locale, '.');
 
-  if (pdot && 2 + strlen (pdot + 1) + 1 <= sizeof (buf))
-    sprintf (buf, "CP%s", pdot + 1);
-  else
-    {
-      /* The Windows API has a function returning the locale's codepage as a
-         number: GetACP().
-         When the output goes to a console window, it needs to be provided in
-         GetOEMCP() encoding if the console is using a raster font, or in
-         GetConsoleOutputCP() encoding if it is using a TrueType font.
-         But in GUI programs and for output sent to files and pipes, GetACP()
-         encoding is the best bet.  */
-      sprintf (buf, "CP%u", GetACP ());
-    }
-  /* For a locale name such as "French_France.65001", in Windows 10,
-     setlocale now returns "French_France.utf8" instead.  */
-  if (strcmp (buf + 2, "65001") == 0 || strcmp (buf + 2, "utf8") == 0)
+  /* After a dot may follow a codepage number, or the "utf8"/"utf-8" string,
+     in any case.  For example, "Russian_Russia.uTf-8".  */
+  /* Also, iterpret the code page number 65001 as utf8.  */
+  if (pdot && (!strcmp (pdot + 1, "65001") || (
+      ('u' == pdot[1] || 'U' == pdot[1]) &&
+      ('t' == pdot[2] || 'T' == pdot[2]) &&
+      ('f' == pdot[3] || 'F' == pdot[3]) &&
+      (('8' == pdot[4] && '\0' == pdot[5]) ||
+       ('-' == pdot[4] && '8' == pdot[5] && '\0' == pdot[6])))))
     codeset = "UTF-8";
   else
     {
+      if (pdot && 2 + strlen (pdot + 1) + 1 <= sizeof (buf))
+        sprintf (buf, "CP%s", pdot + 1);
+      else
+        {
+          /* The Windows API has a function returning the locale's codepage as a
+             number: GetACP().
+             When the output goes to a console window, it needs to be provided in
+             GetOEMCP() encoding if the console is using a raster font, or in
+             GetConsoleOutputCP() encoding if it is using a TrueType font.
+             But in GUI programs and for output sent to files and pipes, GetACP()
+             encoding is the best bet.  */
+          sprintf (buf, "CP%u", GetACP ());
+        }
+
       strcpy (resultbuf, buf);
       codeset = resultbuf;
     }
diff -Naur ../orig/sed-4.9/lib/locale.h ./lib/locale.h
--- ../orig/sed-4.9/lib/locale.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/locale.h	2022-12-01 17:13:19.129986300 +0300
@@ -0,0 +1,812 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A POSIX <locale.h>.
+   Copyright (C) 2007-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#if __GNUC__ >= 3
+
+#endif
+
+
+#if (defined _WIN32 && !defined __CYGWIN__ && defined __need_locale_t) \
+    || defined _GL_ALREADY_INCLUDING_LOCALE_H
+
+/* Special invocation convention:
+   - Inside mingw header files,
+   - To handle Solaris header files (through Solaris 10) when combined
+     with gettext's libintl.h.  */
+
+#include ""
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_LOCALE_H
+
+#define _GL_ALREADY_INCLUDING_LOCALE_H
+
+/* The include_next requires a split double-inclusion guard.  */
+#include "C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\INCLUDE\locale.h"
+
+#undef _GL_ALREADY_INCLUDING_LOCALE_H
+
+#ifndef _GL_LOCALE_H
+#define _GL_LOCALE_H
+
+/* NetBSD 5.0 mis-defines NULL.  */
+#include <stddef.h>
+
+/* Mac OS X 10.5 defines the locale_t type in <xlocale.h>.  */
+#if 0
+# include <xlocale.h>
+#endif
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA (func, rettype, parameters);
+   is to be used when func is a Microsoft deprecated alias, on native Windows.
+   It declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to _func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_MDA (open, int, (const char *filename, int flags, ...));
+ */
+#define _GL_CXXALIAS_MDA(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_MDA (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#define _GL_CXXALIAS_MDA_CAST(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_CAST_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || defined __clang__
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype_gcc, rettype_clang, parameters_and_attributes, "message")
+   is like _GL_WARN_ON_USE (function, "message"), except that in C++ mode the
+   function is declared with the given prototype, consisting of return type,
+   parameters, and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if !defined __cplusplus
+#  define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+     _GL_WARN_ON_USE (function, msg)
+# else
+#  if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes \
+  __attribute__ ((__warning__ (msg)))
+#  elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_clang function parameters_and_attributes \
+  __attribute__ ((__diagnose_if__ (1, msg, "warning")))
+#  elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes
+#  else /* Unsupported.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  endif
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+/* The LC_MESSAGES locale category is specified in POSIX, but not in ISO C.
+   On systems that don't define it, use the same value as GNU libintl.  */
+#if !defined LC_MESSAGES
+# define LC_MESSAGES 1729
+#endif
+
+/* On native Windows with MSVC, 'struct lconv' lacks the members int_p_* and
+   int_n_*.  Instead of overriding 'struct lconv', merely define these member
+   names as macros.  This avoids trouble in C++ mode.  */
+#if defined _MSC_VER
+# define int_p_cs_precedes   p_cs_precedes
+# define int_p_sign_posn     p_sign_posn
+# define int_p_sep_by_space  p_sep_by_space
+# define int_n_cs_precedes   n_cs_precedes
+# define int_n_sign_posn     n_sign_posn
+# define int_n_sep_by_space  n_sep_by_space
+#endif
+
+/* Bionic libc's 'struct lconv' is just a dummy.  */
+#if 0
+# define lconv rpl_lconv
+struct lconv
+{
+  /* All 'char *' are actually 'const char *'.  */
+
+  /* Members that depend on the LC_NUMERIC category of the locale.  See
+     <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_04> */
+
+  /* Symbol used as decimal point.  */
+  char *decimal_point;
+  /* Symbol used to separate groups of digits to the left of the decimal
+     point.  */
+  char *thousands_sep;
+  /* Definition of the size of groups of digits to the left of the decimal
+     point.  */
+  char *grouping;
+
+  /* Members that depend on the LC_MONETARY category of the locale.  See
+     <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_03> */
+
+  /* Symbol used as decimal point.  */
+  char *mon_decimal_point;
+  /* Symbol used to separate groups of digits to the left of the decimal
+     point.  */
+  char *mon_thousands_sep;
+  /* Definition of the size of groups of digits to the left of the decimal
+     point.  */
+  char *mon_grouping;
+  /* Sign used to indicate a value >= 0.  */
+  char *positive_sign;
+  /* Sign used to indicate a value < 0.  */
+  char *negative_sign;
+
+  /* For formatting local currency.  */
+  /* Currency symbol (3 characters) followed by separator (1 character).  */
+  char *currency_symbol;
+  /* Number of digits after the decimal point.  */
+  char frac_digits;
+  /* For values >= 0: 1 if the currency symbol precedes the number, 0 if it
+     comes after the number.  */
+  char p_cs_precedes;
+  /* For values >= 0: Position of the sign.  */
+  char p_sign_posn;
+  /* For values >= 0: Placement of spaces between currency symbol, sign, and
+     number.  */
+  char p_sep_by_space;
+  /* For values < 0: 1 if the currency symbol precedes the number, 0 if it
+     comes after the number.  */
+  char n_cs_precedes;
+  /* For values < 0: Position of the sign.  */
+  char n_sign_posn;
+  /* For values < 0: Placement of spaces between currency symbol, sign, and
+     number.  */
+  char n_sep_by_space;
+
+  /* For formatting international currency.  */
+  /* Currency symbol (3 characters) followed by separator (1 character).  */
+  char *int_curr_symbol;
+  /* Number of digits after the decimal point.  */
+  char int_frac_digits;
+  /* For values >= 0: 1 if the currency symbol precedes the number, 0 if it
+     comes after the number.  */
+  char int_p_cs_precedes;
+  /* For values >= 0: Position of the sign.  */
+  char int_p_sign_posn;
+  /* For values >= 0: Placement of spaces between currency symbol, sign, and
+     number.  */
+  char int_p_sep_by_space;
+  /* For values < 0: 1 if the currency symbol precedes the number, 0 if it
+     comes after the number.  */
+  char int_n_cs_precedes;
+  /* For values < 0: Position of the sign.  */
+  char int_n_sign_posn;
+  /* For values < 0: Placement of spaces between currency symbol, sign, and
+     number.  */
+  char int_n_sep_by_space;
+};
+#endif
+
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef localeconv
+#   define localeconv rpl_localeconv
+#  endif
+_GL_FUNCDECL_RPL (localeconv, struct lconv *, (void));
+_GL_CXXALIAS_RPL (localeconv, struct lconv *, (void));
+# else
+_GL_CXXALIAS_SYS (localeconv, struct lconv *, (void));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (localeconv);
+# endif
+#elif 0
+# undef localeconv
+# define localeconv localeconv_used_without_requesting_gnulib_module_localeconv
+#elif defined GNULIB_POSIXCHECK
+# undef localeconv
+# if HAVE_RAW_DECL_LOCALECONV
+_GL_WARN_ON_USE (localeconv,
+                 "localeconv returns too few information on some platforms - "
+                 "use gnulib module localeconv for portability");
+# endif
+#endif
+
+#if IN_SED_GNULIB_TESTS
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef setlocale
+#   define setlocale rpl_setlocale
+#   define GNULIB_defined_setlocale 1
+#  endif
+_GL_FUNCDECL_RPL (setlocale, char *, (int category, const char *locale));
+_GL_CXXALIAS_RPL (setlocale, char *, (int category, const char *locale));
+# else
+_GL_CXXALIAS_SYS (setlocale, char *, (int category, const char *locale));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (setlocale);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef setlocale
+# if HAVE_RAW_DECL_SETLOCALE
+_GL_WARN_ON_USE (setlocale, "setlocale works differently on native Windows - "
+                 "use gnulib module setlocale for portability");
+# endif
+#endif
+
+#if 1
+/* Included here for convenience.  */
+# include "setlocale_null.h"
+#endif
+
+#if /*@GNULIB_NEWLOCALE@ ||*/ (IN_SED_GNULIB_TESTS && 0 && 0)
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef newlocale
+#   define newlocale rpl_newlocale
+#   define GNULIB_defined_newlocale 1
+#  endif
+_GL_FUNCDECL_RPL (newlocale, locale_t,
+                  (int category_mask, const char *name, locale_t base)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (newlocale, locale_t,
+                  (int category_mask, const char *name, locale_t base));
+# else
+#  if 0
+_GL_CXXALIAS_SYS (newlocale, locale_t,
+                  (int category_mask, const char *name, locale_t base));
+#  endif
+# endif
+# if 0
+_GL_CXXALIASWARN (newlocale);
+# endif
+# if 0 || 0
+#  ifndef HAVE_WORKING_NEWLOCALE
+#   define HAVE_WORKING_NEWLOCALE 1
+#  endif
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef newlocale
+# if HAVE_RAW_DECL_NEWLOCALE
+_GL_WARN_ON_USE (newlocale, "newlocale is not portable");
+# endif
+#endif
+
+#if 0 || (IN_SED_GNULIB_TESTS && 0 && 0)
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef duplocale
+#   define duplocale rpl_duplocale
+#   define GNULIB_defined_duplocale 1
+#  endif
+_GL_FUNCDECL_RPL (duplocale, locale_t, (locale_t locale) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (duplocale, locale_t, (locale_t locale));
+# else
+#  if 0
+_GL_CXXALIAS_SYS (duplocale, locale_t, (locale_t locale));
+#  endif
+# endif
+# if 0
+_GL_CXXALIASWARN (duplocale);
+# endif
+# if 0 || 0
+#  ifndef HAVE_WORKING_DUPLOCALE
+#   define HAVE_WORKING_DUPLOCALE 1
+#  endif
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef duplocale
+# if HAVE_RAW_DECL_DUPLOCALE
+_GL_WARN_ON_USE (duplocale, "duplocale is buggy on some glibc systems - "
+                 "use gnulib module duplocale for portability");
+# endif
+#endif
+
+#if /*@GNULIB_FREELOCALE@ ||*/ (IN_SED_GNULIB_TESTS && 0 && 0)
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef freelocale
+#   define freelocale rpl_freelocale
+#   define GNULIB_defined_freelocale 1
+#  endif
+_GL_FUNCDECL_RPL (freelocale, void, (locale_t locale) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (freelocale, void, (locale_t locale));
+# else
+#  if 0
+/* Need to cast, because on FreeBSD and Mac OS X 10.13, the return type is
+                                   int.  */
+_GL_CXXALIAS_SYS_CAST (freelocale, void, (locale_t locale));
+#  endif
+# endif
+# if 0
+_GL_CXXALIASWARN (freelocale);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef freelocale
+# if HAVE_RAW_DECL_FREELOCALE
+_GL_WARN_ON_USE (freelocale, "freelocale is not portable");
+# endif
+#endif
+
+#endif /* _GL_LOCALE_H */
+#endif /* _GL_LOCALE_H */
+#endif /* !(__need_locale_t || _GL_ALREADY_INCLUDING_LOCALE_H) */
diff -Naur ../orig/sed-4.9/lib/localeinfo.c ./lib/localeinfo.c
--- ../orig/sed-4.9/lib/localeinfo.c	2022-10-09 17:42:28.000000000 +0300
+++ ./lib/localeinfo.c	2022-12-01 17:13:49.446204700 +0300
@@ -49,6 +49,7 @@
 static bool
 using_simple_locale (bool multibyte)
 {
+  int i;
   /* The native character set is known to be compatible with
      the C locale.  The following test isn't perfect, but it's good
      enough in practice, as only ASCII and EBCDIC are in common use
@@ -74,9 +75,13 @@
      although it would be invalid for artificially-constructed locales
      where the native order is the collating-sequence order but there
      are multi-character collating elements.  */
-  for (int i = 0; i < UCHAR_MAX; i++)
-    if (0 <= strcoll (((char []) {i, 0}), ((char []) {i + 1, 0})))
-      return false;
+  for (i = 0; i < UCHAR_MAX; i++)
+    {
+      const char a[] = {i, 0};
+      const char b[] = {i + 1, 0};
+      if (0 <= strcoll (a, b))
+        return false;
+    }
 
   return true;
 }
@@ -86,11 +91,12 @@
 void
 init_localeinfo (struct localeinfo *localeinfo)
 {
+  int i;
   localeinfo->multibyte = MB_CUR_MAX > 1;
   localeinfo->simple = using_simple_locale (localeinfo->multibyte);
   localeinfo->using_utf8 = is_using_utf8 ();
 
-  for (int i = CHAR_MIN; i <= CHAR_MAX; i++)
+  for (i = CHAR_MIN; i <= CHAR_MAX; i++)
     {
       char c = i;
       unsigned char uc = i;
diff -Naur ../orig/sed-4.9/lib/malloc/dynarray-skeleton.gl.h ./lib/malloc/dynarray-skeleton.gl.h
--- ../orig/sed-4.9/lib/malloc/dynarray-skeleton.gl.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/malloc/dynarray-skeleton.gl.h	2022-12-01 17:12:55.614136800 +0300
@@ -0,0 +1,529 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Type-safe arrays which grow dynamically.
+   Copyright (C) 2017-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Pre-processor macros which act as parameters:
+
+   DYNARRAY_STRUCT
+      The struct tag of dynamic array to be defined.
+   DYNARRAY_ELEMENT
+      The type name of the element type.  Elements are copied
+      as if by memcpy, and can change address as the dynamic
+      array grows.
+   DYNARRAY_PREFIX
+      The prefix of the functions which are defined.
+
+   The following parameters are optional:
+
+   DYNARRAY_ELEMENT_FREE
+      DYNARRAY_ELEMENT_FREE (E) is evaluated to deallocate the
+      contents of elements. E is of type  DYNARRAY_ELEMENT *.
+   DYNARRAY_ELEMENT_INIT
+      DYNARRAY_ELEMENT_INIT (E) is evaluated to initialize a new
+      element.  E is of type  DYNARRAY_ELEMENT *.
+      If DYNARRAY_ELEMENT_FREE but not DYNARRAY_ELEMENT_INIT is
+      defined, new elements are automatically zero-initialized.
+      Otherwise, new elements have undefined contents.
+   DYNARRAY_INITIAL_SIZE
+      The size of the statically allocated array (default:
+      at least 2, more elements if they fit into 128 bytes).
+      Must be a preprocessor constant.  If DYNARRAY_INITIAL_SIZE is 0,
+      there is no statically allocated array at, and all non-empty
+      arrays are heap-allocated.
+   DYNARRAY_FINAL_TYPE
+      The name of the type which holds the final array.  If not
+      defined, is PREFIX##finalize not provided.  DYNARRAY_FINAL_TYPE
+      must be a struct type, with members of type DYNARRAY_ELEMENT and
+      size_t at the start (in this order).
+
+   These macros are undefined after this header file has been
+   included.
+
+   The following types are provided (their members are private to the
+   dynarray implementation):
+
+     struct DYNARRAY_STRUCT
+
+   The following functions are provided:
+
+     void DYNARRAY_PREFIX##init (struct DYNARRAY_STRUCT *);
+     void DYNARRAY_PREFIX##free (struct DYNARRAY_STRUCT *);
+     bool DYNARRAY_PREFIX##has_failed (const struct DYNARRAY_STRUCT *);
+     void DYNARRAY_PREFIX##mark_failed (struct DYNARRAY_STRUCT *);
+     size_t DYNARRAY_PREFIX##size (const struct DYNARRAY_STRUCT *);
+     DYNARRAY_ELEMENT *DYNARRAY_PREFIX##begin (const struct DYNARRAY_STRUCT *);
+     DYNARRAY_ELEMENT *DYNARRAY_PREFIX##end (const struct DYNARRAY_STRUCT *);
+     DYNARRAY_ELEMENT *DYNARRAY_PREFIX##at (struct DYNARRAY_STRUCT *, size_t);
+     void DYNARRAY_PREFIX##add (struct DYNARRAY_STRUCT *, DYNARRAY_ELEMENT);
+     DYNARRAY_ELEMENT *DYNARRAY_PREFIX##emplace (struct DYNARRAY_STRUCT *);
+     bool DYNARRAY_PREFIX##resize (struct DYNARRAY_STRUCT *, size_t);
+     void DYNARRAY_PREFIX##remove_last (struct DYNARRAY_STRUCT *);
+     void DYNARRAY_PREFIX##clear (struct DYNARRAY_STRUCT *);
+
+   The following functions are provided are provided if the
+   prerequisites are met:
+
+     bool DYNARRAY_PREFIX##finalize (struct DYNARRAY_STRUCT *,
+                                     DYNARRAY_FINAL_TYPE *);
+       (if DYNARRAY_FINAL_TYPE is defined)
+     DYNARRAY_ELEMENT *DYNARRAY_PREFIX##finalize (struct DYNARRAY_STRUCT *,
+                                                  size_t *);
+       (if DYNARRAY_FINAL_TYPE is not defined)
+*/
+
+#include <malloc/dynarray.gl.h>
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+
+#ifndef DYNARRAY_STRUCT
+# error "DYNARRAY_STRUCT must be defined"
+#endif
+
+#ifndef DYNARRAY_ELEMENT
+# error "DYNARRAY_ELEMENT must be defined"
+#endif
+
+#ifndef DYNARRAY_PREFIX
+# error "DYNARRAY_PREFIX must be defined"
+#endif
+
+#ifdef DYNARRAY_INITIAL_SIZE
+# if DYNARRAY_INITIAL_SIZE < 0
+#  error "DYNARRAY_INITIAL_SIZE must be non-negative"
+# endif
+# if DYNARRAY_INITIAL_SIZE > 0
+#  define DYNARRAY_HAVE_SCRATCH 1
+# else
+#  define DYNARRAY_HAVE_SCRATCH 0
+# endif
+#else
+/* Provide a reasonable default which limits the size of
+   DYNARRAY_STRUCT.  */
+# define DYNARRAY_INITIAL_SIZE \
+  (sizeof (DYNARRAY_ELEMENT) > 64 ? 2 : 128 / sizeof (DYNARRAY_ELEMENT))
+# define DYNARRAY_HAVE_SCRATCH 1
+#endif
+
+/* Public type definitions.  */
+
+/* All fields of this struct are private to the implementation.  */
+struct DYNARRAY_STRUCT
+{
+  union
+  {
+    struct dynarray_header dynarray_abstract;
+    struct
+    {
+      /* These fields must match struct dynarray_header.  */
+      size_t used;
+      size_t allocated;
+      DYNARRAY_ELEMENT *array;
+    } dynarray_header;
+  } u;
+
+#if DYNARRAY_HAVE_SCRATCH
+  /* Initial inline allocation.  */
+  DYNARRAY_ELEMENT scratch[DYNARRAY_INITIAL_SIZE];
+#endif
+};
+
+/* Internal use only: Helper macros.  */
+
+/* Ensure macro-expansion of DYNARRAY_PREFIX.  */
+#define DYNARRAY_CONCAT0(prefix, name) prefix##name
+#define DYNARRAY_CONCAT1(prefix, name) DYNARRAY_CONCAT0(prefix, name)
+#define DYNARRAY_NAME(name) DYNARRAY_CONCAT1(DYNARRAY_PREFIX, name)
+
+/* Use DYNARRAY_FREE instead of DYNARRAY_NAME (free),
+   so that Gnulib does not change 'free' to 'rpl_free'.  */
+#define DYNARRAY_FREE DYNARRAY_CONCAT1 (DYNARRAY_NAME (f), ree)
+
+/* Address of the scratch buffer if any.  */
+#if DYNARRAY_HAVE_SCRATCH
+# define DYNARRAY_SCRATCH(list) (list)->scratch
+#else
+# define DYNARRAY_SCRATCH(list) NULL
+#endif
+
+/* Internal use only: Helper functions.  */
+
+/* Internal function.  Call DYNARRAY_ELEMENT_FREE with the array
+   elements.  Name mangling needed due to the DYNARRAY_ELEMENT_FREE
+   macro expansion.  */
+static inline void
+DYNARRAY_NAME (free__elements__) (DYNARRAY_ELEMENT *__dynarray_array,
+                                  size_t __dynarray_used)
+{
+#ifdef DYNARRAY_ELEMENT_FREE
+  for (size_t __dynarray_i = 0; __dynarray_i < __dynarray_used; ++__dynarray_i)
+    DYNARRAY_ELEMENT_FREE (&__dynarray_array[__dynarray_i]);
+#endif /* DYNARRAY_ELEMENT_FREE */
+}
+
+/* Internal function.  Free the non-scratch array allocation.  */
+static inline void
+DYNARRAY_NAME (free__array__) (struct DYNARRAY_STRUCT *list)
+{
+#if DYNARRAY_HAVE_SCRATCH
+  if (list->u.dynarray_header.array != list->scratch)
+    free (list->u.dynarray_header.array);
+#else
+  free (list->u.dynarray_header.array);
+#endif
+}
+
+/* Public functions.  */
+
+/* Initialize a dynamic array object.  This must be called before any
+   use of the object.  */
+_GL_ATTRIBUTE_NONNULL ((1))
+static void
+DYNARRAY_NAME (init) (struct DYNARRAY_STRUCT *list)
+{
+  list->u.dynarray_header.used = 0;
+  list->u.dynarray_header.allocated = DYNARRAY_INITIAL_SIZE;
+  list->u.dynarray_header.array = DYNARRAY_SCRATCH (list);
+}
+
+/* Deallocate the dynamic array and its elements.  */
+_GL_ATTRIBUTE_MAYBE_UNUSED _GL_ATTRIBUTE_NONNULL ((1))
+static void
+DYNARRAY_FREE (struct DYNARRAY_STRUCT *list)
+{
+  DYNARRAY_NAME (free__elements__)
+    (list->u.dynarray_header.array, list->u.dynarray_header.used);
+  DYNARRAY_NAME (free__array__) (list);
+  DYNARRAY_NAME (init) (list);
+}
+
+/* Return true if the dynamic array is in an error state.  */
+_GL_ATTRIBUTE_NONNULL ((1))
+static inline bool
+DYNARRAY_NAME (has_failed) (const struct DYNARRAY_STRUCT *list)
+{
+  return list->u.dynarray_header.allocated == __dynarray_error_marker ();
+}
+
+/* Mark the dynamic array as failed.  All elements are deallocated as
+   a side effect.  */
+_GL_ATTRIBUTE_NONNULL ((1))
+static void
+DYNARRAY_NAME (mark_failed) (struct DYNARRAY_STRUCT *list)
+{
+  DYNARRAY_NAME (free__elements__)
+    (list->u.dynarray_header.array, list->u.dynarray_header.used);
+  DYNARRAY_NAME (free__array__) (list);
+  list->u.dynarray_header.array = DYNARRAY_SCRATCH (list);
+  list->u.dynarray_header.used = 0;
+  list->u.dynarray_header.allocated = __dynarray_error_marker ();
+}
+
+/* Return the number of elements which have been added to the dynamic
+   array.  */
+_GL_ATTRIBUTE_NONNULL ((1))
+static inline size_t
+DYNARRAY_NAME (size) (const struct DYNARRAY_STRUCT *list)
+{
+  return list->u.dynarray_header.used;
+}
+
+/* Return a pointer to the array element at INDEX.  Terminate the
+   process if INDEX is out of bounds.  */
+_GL_ATTRIBUTE_NONNULL ((1))
+static inline DYNARRAY_ELEMENT *
+DYNARRAY_NAME (at) (struct DYNARRAY_STRUCT *list, size_t index)
+{
+  if (_GL_UNLIKELY (index >= DYNARRAY_NAME (size) (list)))
+    __libc_dynarray_at_failure (DYNARRAY_NAME (size) (list), index);
+  return list->u.dynarray_header.array + index;
+}
+
+/* Return a pointer to the first array element, if any.  For a
+   zero-length array, the pointer can be NULL even though the dynamic
+   array has not entered the failure state.  */
+_GL_ATTRIBUTE_NONNULL ((1))
+static inline DYNARRAY_ELEMENT *
+DYNARRAY_NAME (begin) (struct DYNARRAY_STRUCT *list)
+{
+  return list->u.dynarray_header.array;
+}
+
+/* Return a pointer one element past the last array element.  For a
+   zero-length array, the pointer can be NULL even though the dynamic
+   array has not entered the failure state.  */
+_GL_ATTRIBUTE_NONNULL ((1))
+static inline DYNARRAY_ELEMENT *
+DYNARRAY_NAME (end) (struct DYNARRAY_STRUCT *list)
+{
+  return list->u.dynarray_header.array + list->u.dynarray_header.used;
+}
+
+/* Internal function.  Slow path for the add function below.  */
+static void
+DYNARRAY_NAME (add__) (struct DYNARRAY_STRUCT *list, DYNARRAY_ELEMENT item)
+{
+  if (_GL_UNLIKELY
+      (!__libc_dynarray_emplace_enlarge (&list->u.dynarray_abstract,
+                                         DYNARRAY_SCRATCH (list),
+                                         sizeof (DYNARRAY_ELEMENT))))
+    {
+      DYNARRAY_NAME (mark_failed) (list);
+      return;
+    }
+
+  /* Copy the new element and increase the array length.  */
+  list->u.dynarray_header.array[list->u.dynarray_header.used++] = item;
+}
+
+/* Add ITEM at the end of the array, enlarging it by one element.
+   Mark *LIST as failed if the dynamic array allocation size cannot be
+   increased.  */
+_GL_ATTRIBUTE_NONNULL ((1))
+static inline void
+DYNARRAY_NAME (add) (struct DYNARRAY_STRUCT *list, DYNARRAY_ELEMENT item)
+{
+  /* Do nothing in case of previous error.  */
+  if (DYNARRAY_NAME (has_failed) (list))
+    return;
+
+  /* Enlarge the array if necessary.  */
+  if (_GL_UNLIKELY (list->u.dynarray_header.used
+                        == list->u.dynarray_header.allocated))
+    {
+      DYNARRAY_NAME (add__) (list, item);
+      return;
+    }
+
+  /* Copy the new element and increase the array length.  */
+  list->u.dynarray_header.array[list->u.dynarray_header.used++] = item;
+}
+
+/* Internal function.  Building block for the emplace functions below.
+   Assumes space for one more element in *LIST.  */
+static inline DYNARRAY_ELEMENT *
+DYNARRAY_NAME (emplace__tail__) (struct DYNARRAY_STRUCT *list)
+{
+  DYNARRAY_ELEMENT *result
+    = &list->u.dynarray_header.array[list->u.dynarray_header.used];
+  ++list->u.dynarray_header.used;
+#if defined (DYNARRAY_ELEMENT_INIT)
+  DYNARRAY_ELEMENT_INIT (result);
+#elif defined (DYNARRAY_ELEMENT_FREE)
+  memset (result, 0, sizeof (*result));
+#endif
+  return result;
+}
+
+/* Internal function.  Slow path for the emplace function below.  */
+static DYNARRAY_ELEMENT *
+DYNARRAY_NAME (emplace__) (struct DYNARRAY_STRUCT *list)
+{
+  if (_GL_UNLIKELY
+      (!__libc_dynarray_emplace_enlarge (&list->u.dynarray_abstract,
+                                         DYNARRAY_SCRATCH (list),
+                                         sizeof (DYNARRAY_ELEMENT))))
+    {
+      DYNARRAY_NAME (mark_failed) (list);
+      return NULL;
+    }
+  return DYNARRAY_NAME (emplace__tail__) (list);
+}
+
+/* Allocate a place for a new element in *LIST and return a pointer to
+   it.  The pointer can be NULL if the dynamic array cannot be
+   enlarged due to a memory allocation failure.  */
+_GL_ATTRIBUTE_MAYBE_UNUSED _GL_ATTRIBUTE_NODISCARD
+_GL_ATTRIBUTE_NONNULL ((1))
+static
+/* Avoid inlining with the larger initialization code.  */
+#if !(defined (DYNARRAY_ELEMENT_INIT) || defined (DYNARRAY_ELEMENT_FREE))
+inline
+#endif
+DYNARRAY_ELEMENT *
+DYNARRAY_NAME (emplace) (struct DYNARRAY_STRUCT *list)
+{
+  /* Do nothing in case of previous error.  */
+  if (DYNARRAY_NAME (has_failed) (list))
+    return NULL;
+
+  /* Enlarge the array if necessary.  */
+  if (_GL_UNLIKELY (list->u.dynarray_header.used
+                        == list->u.dynarray_header.allocated))
+    return (DYNARRAY_NAME (emplace__) (list));
+  return DYNARRAY_NAME (emplace__tail__) (list);
+}
+
+/* Change the size of *LIST to SIZE.  If SIZE is larger than the
+   existing size, new elements are added (which can be initialized).
+   Otherwise, the list is truncated, and elements are freed.  Return
+   false on memory allocation failure (and mark *LIST as failed).  */
+_GL_ATTRIBUTE_MAYBE_UNUSED _GL_ATTRIBUTE_NONNULL ((1))
+static bool
+DYNARRAY_NAME (resize) (struct DYNARRAY_STRUCT *list, size_t size)
+{
+  if (size > list->u.dynarray_header.used)
+    {
+      bool ok;
+#if defined (DYNARRAY_ELEMENT_INIT)
+      /* The new elements have to be initialized.  */
+      size_t old_size = list->u.dynarray_header.used;
+      ok = __libc_dynarray_resize (&list->u.dynarray_abstract,
+                                   size, DYNARRAY_SCRATCH (list),
+                                   sizeof (DYNARRAY_ELEMENT));
+      if (ok)
+        for (size_t i = old_size; i < size; ++i)
+          {
+            DYNARRAY_ELEMENT_INIT (&list->u.dynarray_header.array[i]);
+          }
+#elif defined (DYNARRAY_ELEMENT_FREE)
+      /* Zero initialization is needed so that the elements can be
+         safely freed.  */
+      ok = __libc_dynarray_resize_clear
+        (&list->u.dynarray_abstract, size,
+         DYNARRAY_SCRATCH (list), sizeof (DYNARRAY_ELEMENT));
+#else
+      ok =  __libc_dynarray_resize (&list->u.dynarray_abstract,
+                                    size, DYNARRAY_SCRATCH (list),
+                                    sizeof (DYNARRAY_ELEMENT));
+#endif
+      if (_GL_UNLIKELY (!ok))
+        DYNARRAY_NAME (mark_failed) (list);
+      return ok;
+    }
+  else
+    {
+      /* The list has shrunk in size.  Free the removed elements.  */
+      DYNARRAY_NAME (free__elements__)
+        (list->u.dynarray_header.array + size,
+         list->u.dynarray_header.used - size);
+      list->u.dynarray_header.used = size;
+      return true;
+    }
+}
+
+/* Remove the last element of LIST if it is present.  */
+_GL_ATTRIBUTE_MAYBE_UNUSED _GL_ATTRIBUTE_NONNULL ((1))
+static void
+DYNARRAY_NAME (remove_last) (struct DYNARRAY_STRUCT *list)
+{
+  /* used > 0 implies that the array is the non-failed state.  */
+  if (list->u.dynarray_header.used > 0)
+    {
+      size_t new_length = list->u.dynarray_header.used - 1;
+#ifdef DYNARRAY_ELEMENT_FREE
+      DYNARRAY_ELEMENT_FREE (&list->u.dynarray_header.array[new_length]);
+#endif
+      list->u.dynarray_header.used = new_length;
+    }
+}
+
+/* Remove all elements from the list.  The elements are freed, but the
+   list itself is not.  */
+_GL_ATTRIBUTE_MAYBE_UNUSED _GL_ATTRIBUTE_NONNULL ((1))
+static void
+DYNARRAY_NAME (clear) (struct DYNARRAY_STRUCT *list)
+{
+  /* free__elements__ does nothing if the list is in the failed
+     state.  */
+  DYNARRAY_NAME (free__elements__)
+    (list->u.dynarray_header.array, list->u.dynarray_header.used);
+  list->u.dynarray_header.used = 0;
+}
+
+#ifdef DYNARRAY_FINAL_TYPE
+/* Transfer the dynamic array to a permanent location at *RESULT.
+   Returns true on success on false on allocation failure.  In either
+   case, *LIST is re-initialized and can be reused.  A NULL pointer is
+   stored in *RESULT if LIST refers to an empty list.  On success, the
+   pointer in *RESULT is heap-allocated and must be deallocated using
+   free.  */
+_GL_ATTRIBUTE_MAYBE_UNUSED _GL_ATTRIBUTE_NODISCARD
+_GL_ATTRIBUTE_NONNULL ((1, 2))
+static bool
+DYNARRAY_NAME (finalize) (struct DYNARRAY_STRUCT *list,
+                          DYNARRAY_FINAL_TYPE *result)
+{
+  struct dynarray_finalize_result res;
+  if (__libc_dynarray_finalize (&list->u.dynarray_abstract,
+                                DYNARRAY_SCRATCH (list),
+                                sizeof (DYNARRAY_ELEMENT), &res))
+    {
+      /* On success, the result owns all the data.  */
+      DYNARRAY_NAME (init) (list);
+      *result = (DYNARRAY_FINAL_TYPE) { res.array, res.length };
+      return true;
+    }
+  else
+    {
+      /* On error, we need to free all data.  */
+      DYNARRAY_FREE (list);
+      errno = ENOMEM;
+      return false;
+    }
+}
+#else /* !DYNARRAY_FINAL_TYPE */
+/* Transfer the dynamic array to a heap-allocated array and return a
+   pointer to it.  The pointer is NULL if memory allocation fails, or
+   if the array is empty, so this function should be used only for
+   arrays which are known not be empty (usually because they always
+   have a sentinel at the end).  If LENGTHP is not NULL, the array
+   length is written to *LENGTHP.  *LIST is re-initialized and can be
+   reused.  */
+_GL_ATTRIBUTE_MAYBE_UNUSED _GL_ATTRIBUTE_NODISCARD
+_GL_ATTRIBUTE_NONNULL ((1))
+static DYNARRAY_ELEMENT *
+DYNARRAY_NAME (finalize) (struct DYNARRAY_STRUCT *list, size_t *lengthp)
+{
+  struct dynarray_finalize_result res;
+  if (__libc_dynarray_finalize (&list->u.dynarray_abstract,
+                                DYNARRAY_SCRATCH (list),
+                                sizeof (DYNARRAY_ELEMENT), &res))
+    {
+      /* On success, the result owns all the data.  */
+      DYNARRAY_NAME (init) (list);
+      if (lengthp != NULL)
+        *lengthp = res.length;
+      return res.array;
+    }
+  else
+    {
+      /* On error, we need to free all data.  */
+      DYNARRAY_FREE (list);
+      errno = ENOMEM;
+      return NULL;
+    }
+}
+#endif /* !DYNARRAY_FINAL_TYPE */
+
+/* Undo macro definitions.  */
+
+#undef DYNARRAY_CONCAT0
+#undef DYNARRAY_CONCAT1
+#undef DYNARRAY_NAME
+#undef DYNARRAY_SCRATCH
+#undef DYNARRAY_HAVE_SCRATCH
+
+#undef DYNARRAY_STRUCT
+#undef DYNARRAY_ELEMENT
+#undef DYNARRAY_PREFIX
+#undef DYNARRAY_ELEMENT_FREE
+#undef DYNARRAY_ELEMENT_INIT
+#undef DYNARRAY_INITIAL_SIZE
+#undef DYNARRAY_FINAL_TYPE
diff -Naur ../orig/sed-4.9/lib/malloc/dynarray.gl.h ./lib/malloc/dynarray.gl.h
--- ../orig/sed-4.9/lib/malloc/dynarray.gl.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/malloc/dynarray.gl.h	2022-12-01 17:12:55.490129700 +0300
@@ -0,0 +1,173 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Type-safe arrays which grow dynamically.  Shared definitions.
+   Copyright (C) 2017-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* To use the dynarray facility, you need to include
+   <malloc/dynarray-skeleton.c> and define the parameter macros
+   documented in that file.
+
+   A minimal example which provides a growing list of integers can be
+   defined like this:
+
+     struct int_array
+     {
+       // Pointer to result array followed by its length,
+       // as required by DYNARRAY_FINAL_TYPE.
+       int *array;
+       size_t length;
+     };
+
+     #define DYNARRAY_STRUCT dynarray_int
+     #define DYNARRAY_ELEMENT int
+     #define DYNARRAY_PREFIX dynarray_int_
+     #define DYNARRAY_FINAL_TYPE struct int_array
+     #include <malloc/dynarray-skeleton.c>
+
+   To create a three-element array with elements 1, 2, 3, use this
+   code:
+
+     struct dynarray_int dyn;
+     dynarray_int_init (&dyn);
+     for (int i = 1; i <= 3; ++i)
+       {
+         int *place = dynarray_int_emplace (&dyn);
+         assert (place != NULL);
+         *place = i;
+       }
+     struct int_array result;
+     bool ok = dynarray_int_finalize (&dyn, &result);
+     assert (ok);
+     assert (result.length == 3);
+     assert (result.array[0] == 1);
+     assert (result.array[1] == 2);
+     assert (result.array[2] == 3);
+     free (result.array);
+
+   If the elements contain resources which must be freed, define
+   DYNARRAY_ELEMENT_FREE appropriately, like this:
+
+     struct str_array
+     {
+       char **array;
+       size_t length;
+     };
+
+     #define DYNARRAY_STRUCT dynarray_str
+     #define DYNARRAY_ELEMENT char *
+     #define DYNARRAY_ELEMENT_FREE(ptr) free (*ptr)
+     #define DYNARRAY_PREFIX dynarray_str_
+     #define DYNARRAY_FINAL_TYPE struct str_array
+     #include <malloc/dynarray-skeleton.c>
+
+   Compared to scratch buffers, dynamic arrays have the following
+   features:
+
+   - They have an element type, and are not just an untyped buffer of
+     bytes.
+
+   - When growing, previously stored elements are preserved.  (It is
+     expected that scratch_buffer_grow_preserve and
+     scratch_buffer_set_array_size eventually go away because all
+     current users are moved to dynamic arrays.)
+
+   - Scratch buffers have a more aggressive growth policy because
+     growing them typically means a retry of an operation (across an
+     NSS service module boundary), which is expensive.
+
+   - For the same reason, scratch buffers have a much larger initial
+     stack allocation.  */
+
+#ifndef _DYNARRAY_H
+#define _DYNARRAY_H
+
+#include <stddef.h>
+#include <string.h>
+
+struct dynarray_header
+{
+  size_t used;
+  size_t allocated;
+  void *array;
+};
+
+/* Marker used in the allocated member to indicate that an error was
+   encountered.  */
+static inline size_t
+__dynarray_error_marker (void)
+{
+  return -1;
+}
+
+/* Internal function.  See the has_failed function in
+   dynarray-skeleton.c.  */
+static inline bool
+__dynarray_error (struct dynarray_header *list)
+{
+  return list->allocated == __dynarray_error_marker ();
+}
+
+/* Internal function.  Enlarge the dynamically allocated area of the
+   array to make room for one more element.  SCRATCH is a pointer to
+   the scratch area (which is not heap-allocated and must not be
+   freed).  ELEMENT_SIZE is the size, in bytes, of one element.
+   Return false on failure, true on success.  */
+bool __libc_dynarray_emplace_enlarge (struct dynarray_header *,
+                                      void *scratch, size_t element_size);
+
+/* Internal function.  Enlarge the dynamically allocated area of the
+   array to make room for at least SIZE elements (which must be larger
+   than the existing used part of the dynamic array).  SCRATCH is a
+   pointer to the scratch area (which is not heap-allocated and must
+   not be freed).  ELEMENT_SIZE is the size, in bytes, of one element.
+   Return false on failure, true on success.  */
+bool __libc_dynarray_resize (struct dynarray_header *, size_t size,
+                             void *scratch, size_t element_size);
+
+/* Internal function.  Like __libc_dynarray_resize, but clear the new
+   part of the dynamic array.  */
+bool __libc_dynarray_resize_clear (struct dynarray_header *, size_t size,
+                                   void *scratch, size_t element_size);
+
+/* Internal type.  */
+struct dynarray_finalize_result
+{
+  void *array;
+  size_t length;
+};
+
+/* Internal function.  Copy the dynamically-allocated area to an
+   explicitly-sized heap allocation.  SCRATCH is a pointer to the
+   embedded scratch space.  ELEMENT_SIZE is the size, in bytes, of the
+   element type.  On success, true is returned, and pointer and length
+   are written to *RESULT.  On failure, false is returned.  The caller
+   has to take care of some of the memory management; this function is
+   expected to be called from dynarray-skeleton.c.  */
+bool __libc_dynarray_finalize (struct dynarray_header *list, void *scratch,
+                               size_t element_size,
+                               struct dynarray_finalize_result *result);
+
+
+/* Internal function.  Terminate the process after an index error.
+   SIZE is the number of elements of the dynamic array.  INDEX is the
+   lookup index which triggered the failure.  */
+_Noreturn void __libc_dynarray_at_failure (size_t size, size_t index);
+
+#ifndef _ISOMAC
+#endif
+
+#endif /* _DYNARRAY_H */
diff -Naur ../orig/sed-4.9/lib/malloc/dynarray_emplace_enlarge.c ./lib/malloc/dynarray_emplace_enlarge.c
--- ../orig/sed-4.9/lib/malloc/dynarray_emplace_enlarge.c	2022-07-02 21:22:03.000000000 +0300
+++ ./lib/malloc/dynarray_emplace_enlarge.c	2022-12-01 17:13:49.451205000 +0300
@@ -31,6 +31,8 @@
                                  void *scratch, size_t element_size)
 {
   size_t new_allocated;
+  size_t new_size;
+  void *new_array;
   if (list->allocated == 0)
     {
       /* No scratch buffer provided.  Choose a reasonable default
@@ -55,10 +57,8 @@
         }
     }
 
-  size_t new_size;
   if (INT_MULTIPLY_WRAPV (new_allocated, element_size, &new_size))
     return false;
-  void *new_array;
   if (list->array == scratch)
     {
       /* The previous array was not heap-allocated.  */
diff -Naur ../orig/sed-4.9/lib/malloc/dynarray_finalize.c ./lib/malloc/dynarray_finalize.c
--- ../orig/sed-4.9/lib/malloc/dynarray_finalize.c	2022-07-02 21:22:03.000000000 +0300
+++ ./lib/malloc/dynarray_finalize.c	2022-12-01 17:13:49.456205300 +0300
@@ -29,11 +29,15 @@
                           void *scratch, size_t element_size,
                           struct dynarray_finalize_result *result)
 {
+  size_t used;
+  size_t allocation_size;
+  void *heap_array;
+
   if (__dynarray_error (list))
     /* The caller will reported the deferred error.  */
     return false;
 
-  size_t used = list->used;
+  used = list->used;
 
   /* Empty list.  */
   if (used == 0)
@@ -42,12 +46,15 @@
          array.  Free it if necessary.  */
       if (list->array != scratch)
         free (list->array);
-      *result = (struct dynarray_finalize_result) { NULL, 0 };
+      {
+        const struct dynarray_finalize_result r = { NULL, 0 };
+        *result = r;
+      }
       return true;
     }
 
-  size_t allocation_size = used * element_size;
-  void *heap_array = malloc (allocation_size);
+  allocation_size = used * element_size;
+  heap_array = malloc (allocation_size);
   if (heap_array != NULL)
     {
       /* The new array takes ownership of the strings.  */
@@ -55,8 +62,10 @@
         memcpy (heap_array, list->array, allocation_size);
       if (list->array != scratch)
         free (list->array);
-      *result = (struct dynarray_finalize_result)
-        { .array = heap_array, .length = used };
+      {
+        const struct dynarray_finalize_result r = { heap_array, used };
+        *result = r;
+      }
       return true;
     }
   else
diff -Naur ../orig/sed-4.9/lib/malloc/dynarray_resize.c ./lib/malloc/dynarray_resize.c
--- ../orig/sed-4.9/lib/malloc/dynarray_resize.c	2022-07-02 21:22:03.000000000 +0300
+++ ./lib/malloc/dynarray_resize.c	2022-12-01 17:13:49.461205600 +0300
@@ -30,6 +30,9 @@
 __libc_dynarray_resize (struct dynarray_header *list, size_t size,
                         void *scratch, size_t element_size)
 {
+  void *new_array;
+  size_t new_size_bytes;
+
   /* The existing allocation provides sufficient room.  */
   if (size <= list->allocated)
     {
@@ -41,14 +44,12 @@
      expected to provide the final size of the array, so there is no
      over-allocation here.  */
 
-  size_t new_size_bytes;
   if (INT_MULTIPLY_WRAPV (size, element_size, &new_size_bytes))
     {
       /* Overflow.  */
       __set_errno (ENOMEM);
       return false;
     }
-  void *new_array;
   if (list->array == scratch)
     {
       /* The previous array was not heap-allocated.  */
diff -Naur ../orig/sed-4.9/lib/malloc/dynarray_resize_clear.c ./lib/malloc/dynarray_resize_clear.c
--- ../orig/sed-4.9/lib/malloc/dynarray_resize_clear.c	2022-07-02 21:22:03.000000000 +0300
+++ ./lib/malloc/dynarray_resize_clear.c	2022-12-01 17:13:49.466205900 +0300
@@ -27,11 +27,12 @@
 __libc_dynarray_resize_clear (struct dynarray_header *list, size_t size,
                               void *scratch, size_t element_size)
 {
+  char *array;
   size_t old_size = list->used;
   if (!__libc_dynarray_resize (list, size, scratch, element_size))
     return false;
   /* __libc_dynarray_resize already checked for overflow.  */
-  char *array = list->array;
+  array = list->array;
   memset (array + (old_size * element_size), 0,
           (size - old_size) * element_size);
   return true;
diff -Naur ../orig/sed-4.9/lib/malloc/scratch_buffer.gl.h ./lib/malloc/scratch_buffer.gl.h
--- ../orig/sed-4.9/lib/malloc/scratch_buffer.gl.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/malloc/scratch_buffer.gl.h	2022-12-01 17:12:55.732143500 +0300
@@ -0,0 +1,133 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Variable-sized buffer with on-stack default allocation.
+   Copyright (C) 2015-2022 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _SCRATCH_BUFFER_H
+#define _SCRATCH_BUFFER_H
+
+/* Scratch buffers with a default stack allocation and fallback to
+   heap allocation.  It is expected that this function is used in this
+   way:
+
+     struct scratch_buffer tmpbuf;
+     scratch_buffer_init (&tmpbuf);
+
+     while (!function_that_uses_buffer (tmpbuf.data, tmpbuf.length))
+       if (!scratch_buffer_grow (&tmpbuf))
+	 return -1;
+
+     scratch_buffer_free (&tmpbuf);
+     return 0;
+
+   The allocation functions (scratch_buffer_grow,
+   scratch_buffer_grow_preserve, scratch_buffer_set_array_size) make
+   sure that the heap allocation, if any, is freed, so that the code
+   above does not have a memory leak.  The buffer still remains in a
+   state that can be deallocated using scratch_buffer_free, so a loop
+   like this is valid as well:
+
+     struct scratch_buffer tmpbuf;
+     scratch_buffer_init (&tmpbuf);
+
+     while (!function_that_uses_buffer (tmpbuf.data, tmpbuf.length))
+       if (!scratch_buffer_grow (&tmpbuf))
+	 break;
+
+     scratch_buffer_free (&tmpbuf);
+
+   scratch_buffer_grow and scratch_buffer_grow_preserve are guaranteed
+   to grow the buffer by at least 512 bytes.  This means that when
+   using the scratch buffer as a backing store for a non-character
+   array whose element size, in bytes, is 512 or smaller, the scratch
+   buffer only has to grow once to make room for at least one more
+   element.
+*/
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdlib.h>
+
+/* Scratch buffer.  Must be initialized with scratch_buffer_init
+   before its use.  */
+struct scratch_buffer {
+  void *data;    /* Pointer to the beginning of the scratch area.  */
+  size_t length; /* Allocated space at the data pointer, in bytes.  */
+  union { max_align_t __align; char __c[1024]; } __space;
+};
+
+/* Initializes *BUFFER so that BUFFER->data points to BUFFER->__space
+   and BUFFER->length reflects the available space.  */
+static inline void
+scratch_buffer_init (struct scratch_buffer *buffer)
+{
+  buffer->data = buffer->__space.__c;
+  buffer->length = sizeof (buffer->__space);
+}
+
+/* Deallocates *BUFFER (if it was heap-allocated).  */
+static inline void
+scratch_buffer_free (struct scratch_buffer *buffer)
+{
+  if (buffer->data != buffer->__space.__c)
+    free (buffer->data);
+}
+
+/* Grow *BUFFER by some arbitrary amount.  The buffer contents is NOT
+   preserved.  Return true on success, false on allocation failure (in
+   which case the old buffer is freed).  On success, the new buffer is
+   larger than the previous size.  On failure, *BUFFER is deallocated,
+   but remains in a free-able state, and errno is set.  */
+bool __libc_scratch_buffer_grow (struct scratch_buffer *buffer);
+
+/* Alias for __libc_scratch_buffer_grow.  */
+static inline _GL_ATTRIBUTE_ALWAYS_INLINE bool
+scratch_buffer_grow (struct scratch_buffer *buffer)
+{
+  return _GL_LIKELY (__libc_scratch_buffer_grow (buffer));
+}
+
+/* Like __libc_scratch_buffer_grow, but preserve the old buffer
+   contents on success, as a prefix of the new buffer.  */
+bool __libc_scratch_buffer_grow_preserve (struct scratch_buffer *buffer);
+
+/* Alias for __libc_scratch_buffer_grow_preserve.  */
+static inline _GL_ATTRIBUTE_ALWAYS_INLINE bool
+scratch_buffer_grow_preserve (struct scratch_buffer *buffer)
+{
+  return _GL_LIKELY (__libc_scratch_buffer_grow_preserve (buffer));
+}
+
+/* Grow *BUFFER so that it can store at least NELEM elements of SIZE
+   bytes.  The buffer contents are NOT preserved.  Both NELEM and SIZE
+   can be zero.  Return true on success, false on allocation failure
+   (in which case the old buffer is freed, but *BUFFER remains in a
+   free-able state, and errno is set).  It is unspecified whether this
+   function can reduce the array size.  */
+bool __libc_scratch_buffer_set_array_size (struct scratch_buffer *buffer,
+					   size_t nelem, size_t size);
+
+/* Alias for __libc_scratch_set_array_size.  */
+static inline _GL_ATTRIBUTE_ALWAYS_INLINE bool
+scratch_buffer_set_array_size (struct scratch_buffer *buffer,
+			       size_t nelem, size_t size)
+{
+  return _GL_LIKELY (__libc_scratch_buffer_set_array_size
+			 (buffer, nelem, size));
+}
+
+#endif /* _SCRATCH_BUFFER_H */
diff -Naur ../orig/sed-4.9/lib/malloc/scratch_buffer_set_array_size.c ./lib/malloc/scratch_buffer_set_array_size.c
--- ../orig/sed-4.9/lib/malloc/scratch_buffer_set_array_size.c	2022-07-02 21:22:03.000000000 +0300
+++ ./lib/malloc/scratch_buffer_set_array_size.c	2022-12-01 17:13:49.470206100 +0300
@@ -28,6 +28,7 @@
 __libc_scratch_buffer_set_array_size (struct scratch_buffer *buffer,
 				      size_t nelem, size_t size)
 {
+  char *new_ptr;
   size_t new_length = nelem * size;
 
   /* Avoid overflow check if both values are small. */
@@ -48,7 +49,7 @@
   /* Discard old buffer.  */
   scratch_buffer_free (buffer);
 
-  char *new_ptr = malloc (new_length);
+  new_ptr = malloc (new_length);
   if (new_ptr == NULL)
     {
       /* Buffer must remain valid to free.  */
diff -Naur ../orig/sed-4.9/lib/malloc.c ./lib/malloc.c
--- ../orig/sed-4.9/lib/malloc.c	2022-07-02 21:22:03.000000000 +0300
+++ ./lib/malloc.c	2022-12-01 17:13:49.475206400 +0300
@@ -31,6 +31,8 @@
 void *
 rpl_malloc (size_t n)
 {
+  void *result;
+
   if (n == 0)
     n = 1;
 
@@ -40,7 +42,7 @@
       return NULL;
     }
 
-  void *result = malloc (n);
+  result = malloc (n);
 
 #if !HAVE_MALLOC_POSIX
   if (result == NULL)
diff -Naur ../orig/sed-4.9/lib/malloca.c ./lib/malloca.c
--- ../orig/sed-4.9/lib/malloca.c	2022-10-09 17:42:28.000000000 +0300
+++ ./lib/malloca.c	2022-12-01 17:13:49.480206700 +0300
@@ -60,6 +60,7 @@
           /* The ckd_add avoids signed integer overflow on
              theoretical platforms where UINTPTR_MAX <= INT_MAX.  */
           ckd_add (&umemplus, umem, sizeof (small_t) + sa_alignment_max - 1);
+          {
           idx_t offset = ((umemplus & ~alignment2_mask)
                           + sa_alignment_max - umem);
           void *vp = mem + offset;
@@ -72,6 +73,7 @@
           p[-1] = offset;
           /* p  sa_alignment_max mod 2*sa_alignment_max.  */
           return p;
+          }
         }
     }
   /* Out of memory.  */
diff -Naur ../orig/sed-4.9/lib/mbtowc-lock.h ./lib/mbtowc-lock.h
--- ../orig/sed-4.9/lib/mbtowc-lock.h	2022-07-02 21:22:03.000000000 +0300
+++ ./lib/mbtowc-lock.h	2022-12-01 17:08:55.525645500 +0300
@@ -44,7 +44,7 @@
 
 #elif defined _WIN32 && !defined __CYGWIN__
 
-extern __declspec(dllimport) CRITICAL_SECTION *gl_get_mbtowc_lock (void);
+extern /*__declspec(dllimport)*/ CRITICAL_SECTION *gl_get_mbtowc_lock (void);
 
 static int
 mbtowc_with_lock (wchar_t *pwc, const char *p, size_t m)
diff -Naur ../orig/sed-4.9/lib/nl_langinfo.c ./lib/nl_langinfo.c
--- ../orig/sed-4.9/lib/nl_langinfo.c	2022-07-02 21:22:03.000000000 +0300
+++ ./lib/nl_langinfo.c	2022-12-01 17:08:55.505645500 +0300
@@ -113,21 +113,27 @@
      GetACP, which returns the locale's codepage as a number (although
      this doesn't change according to what the 'setlocale' call specified).
      Either way, prepend "CP" to make it a valid codeset name.  */
+
+  /* After a dot may follow a codepage number, or the "utf8"/"utf-8" string
+     in any case.  For example, "Russian_Russia.uTf-8".  */
+  /* Also, iterpret the code page number 65001 as utf8.  */
+  if (!strcmp (codeset, "65001") || (
+      ('u' == codeset[0] || 'U' == codeset[0]) &&
+      ('t' == codeset[1] || 'T' == codeset[1]) &&
+      ('f' == codeset[2] || 'F' == codeset[2]) &&
+      (('8' == codeset[3] && '\0' == codeset[4]) ||
+       ('-' == codeset[3] && '8' == codeset[4] && '\0' == codeset[5]))))
+    return (char *) "UTF-8";
+
   codesetlen = strlen (codeset);
   if (0 < codesetlen && codesetlen < sizeof buf - 2)
     memmove (buf + 2, codeset, codesetlen + 1);
   else
     sprintf (buf + 2, "%u", GetACP ());
-  /* For a locale name such as "French_France.65001", in Windows 10,
-     setlocale now returns "French_France.utf8" instead.  */
-  if (strcmp (buf + 2, "65001") == 0 || strcmp (buf + 2, "utf8") == 0)
-    return (char *) "UTF-8";
-  else
-    {
-      memcpy (buf, "CP", 2);
-      strcpy (result, buf);
-      return result;
-    }
+
+  memcpy (buf, "CP", 2);
+  strcpy (result, buf);
+  return result;
 # else
   strcpy (result, codeset);
   return result;
diff -Naur ../orig/sed-4.9/lib/rawmemchr.c ./lib/rawmemchr.c
--- ../orig/sed-4.9/lib/rawmemchr.c	2022-10-09 17:42:28.000000000 +0300
+++ ./lib/rawmemchr.c	2022-12-01 17:13:49.484206900 +0300
@@ -47,6 +47,7 @@
     if (*char_ptr == c)
       return (void *) char_ptr;
 
+  {
   longword const *longword_ptr = s = char_ptr;
 
   /* Compute auxiliary longword values:
@@ -107,6 +108,7 @@
     }
 
   char_ptr = s = longword_ptr;
+  }
 
   /* At this point, we know that one of the sizeof (longword) bytes
      starting at char_ptr is == c.  If we knew endianness, we
diff -Naur ../orig/sed-4.9/lib/realloc.c ./lib/realloc.c
--- ../orig/sed-4.9/lib/realloc.c	2022-07-02 21:22:03.000000000 +0300
+++ ./lib/realloc.c	2022-12-01 17:13:49.489207200 +0300
@@ -37,6 +37,8 @@
 void *
 rpl_realloc (void *p, size_t n)
 {
+  void *result;
+
   if (p == NULL)
     return malloc (n);
 
@@ -52,7 +54,7 @@
       return NULL;
     }
 
-  void *result = realloc (p, n);
+  result = realloc (p, n);
 
 #if !HAVE_MALLOC_POSIX
   if (result == NULL)
diff -Naur ../orig/sed-4.9/lib/regcomp.c ./lib/regcomp.c
--- ../orig/sed-4.9/lib/regcomp.c	2022-10-09 17:42:17.000000000 +0300
+++ ./lib/regcomp.c	2022-12-01 17:13:49.494207500 +0300
@@ -2652,6 +2652,9 @@
 		 int_fast32_t table_size, const void *symb_table,
 		 const unsigned char *extra)
 {
+  unsigned int start_ch, end_ch;
+  wint_t start_wc, end_wc;
+
   /* Equivalence Classes and Character Classes can't be a range start/end.  */
   if (__glibc_unlikely (start_elem->type == EQUIV_CLASS
 			|| start_elem->type == CHAR_CLASS
@@ -2667,17 +2670,16 @@
 			    && strlen ((char *) end_elem->opr.name) > 1)))
     return REG_ECOLLATE;
 
-  unsigned int
-    start_ch = ((start_elem->type == SB_CHAR) ? start_elem->opr.ch
+  start_ch = ((start_elem->type == SB_CHAR) ? start_elem->opr.ch
 		: ((start_elem->type == COLL_SYM) ? start_elem->opr.name[0]
-		   : 0)),
-    end_ch = ((end_elem->type == SB_CHAR) ? end_elem->opr.ch
+		   : 0));
+  end_ch = ((end_elem->type == SB_CHAR) ? end_elem->opr.ch
 	      : ((end_elem->type == COLL_SYM) ? end_elem->opr.name[0]
 		 : 0));
-  wint_t
-    start_wc = ((start_elem->type == SB_CHAR || start_elem->type == COLL_SYM)
-		? parse_byte (start_ch, dfa) : start_elem->opr.wch),
-    end_wc = ((end_elem->type == SB_CHAR || end_elem->type == COLL_SYM)
+
+  start_wc = ((start_elem->type == SB_CHAR || start_elem->type == COLL_SYM)
+		? parse_byte (start_ch, dfa) : start_elem->opr.wch);
+  end_wc = ((end_elem->type == SB_CHAR || end_elem->type == COLL_SYM)
 	      ? parse_byte (end_ch, dfa) : end_elem->opr.wch);
 
   if (start_wc == WEOF || end_wc == WEOF)
@@ -2726,12 +2728,15 @@
       mbcset->range_ends[mbcset->nranges++] = end_wc;
     }
 
+  {
   /* Build the table for single byte characters.  */
-  for (wchar_t wc = 0; wc < SBC_MAX; ++wc)
+  wchar_t wc;
+  for (wc = 0; wc < SBC_MAX; ++wc)
     {
       if (start_wc <= wc && wc <= end_wc)
         bitset_set (sbcset, wc);
     }
+  }
 
   return REG_NOERROR;
 }
@@ -3585,8 +3590,11 @@
   if (dfa->mb_cur_max > 1)
     bitset_mask (sbcset, dfa->sb_char);
 
+  {
   /* Build a tree for simple bracket.  */
-  re_token_t br_token = { .type = SIMPLE_BRACKET, .opr.sbcset = sbcset };
+  re_token_t br_token = { 0 };
+  br_token.type = SIMPLE_BRACKET;
+  br_token.opr.sbcset = sbcset;
   tree = create_token_tree (dfa, NULL, NULL, &br_token);
   if (__glibc_unlikely (tree == NULL))
     goto build_word_op_espace;
@@ -3611,6 +3619,7 @@
       free_charset (mbcset);
       return tree;
     }
+  }
 
  build_word_op_espace:
   re_free (sbcset);
@@ -3669,7 +3678,8 @@
 create_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,
 	     re_token_type_t type)
 {
-  re_token_t t = { .type = type };
+  re_token_t t = { 0 };
+  t.type = type;
   return create_token_tree (dfa, left, right, &t);
 }
 
diff -Naur ../orig/sed-4.9/lib/regexec.c ./lib/regexec.c
--- ../orig/sed-4.9/lib/regexec.c	2022-10-09 17:42:17.000000000 +0300
+++ ./lib/regexec.c	2022-12-01 17:13:49.500207800 +0300
@@ -592,11 +592,12 @@
   Idx extra_nmatch;
   bool sb;
   int ch;
-  re_match_context_t mctx = { .dfa = dfa };
   char *fastmap = ((preg->fastmap != NULL && preg->fastmap_accurate
 		    && start != last_start && !preg->can_be_null)
 		   ? preg->fastmap : NULL);
   RE_TRANSLATE_TYPE t = preg->translate;
+  re_match_context_t mctx = { 0 };
+  *(const re_dfa_t **)(&mctx.dfa) = dfa;
 
   extra_nmatch = (nmatch > preg->re_nsub) ? nmatch - (preg->re_nsub + 1) : 0;
   nmatch -= extra_nmatch;
@@ -1204,6 +1205,7 @@
   const re_dfa_t *const dfa = mctx->dfa;
   if (IS_EPSILON_NODE (dfa->nodes[node].type))
     {
+      Idx dest_node = -1, i;
       re_node_set *cur_nodes = &mctx->state_log[*pidx]->nodes;
       re_node_set *edests = &dfa->edests[node];
 
@@ -1215,8 +1217,7 @@
         }
 
       /* Pick a valid destination, or return -1 if none is found.  */
-      Idx dest_node = -1;
-      for (Idx i = 0; i < edests->nelem; i++)
+      for (i = 0; i < edests->nelem; i++)
 	{
 	  Idx candidate = edests->elems[i];
 	  if (!re_node_set_contains (cur_nodes, candidate))
@@ -1336,9 +1337,10 @@
 		regmatch_t *regs, regmatch_t *prevregs,
 		re_node_set *eps_via_nodes)
 {
+  Idx num;
   if (fs == NULL || fs->num == 0)
     return -1;
-  Idx num = --fs->num;
+  num = --fs->num;
   *pidx = fs->stack[num].idx;
   memcpy (regs, fs->stack[num].regs, sizeof (regmatch_t) * nregs);
   memcpy (prevregs, fs->stack[num].regs + nregs, sizeof (regmatch_t) * nregs);
@@ -1371,6 +1373,7 @@
   struct re_fail_stack_t *fs;
   struct re_fail_stack_t fs_body = { 0, 2, NULL };
   struct regmatch_list prev_match;
+  regmatch_t *prev_idx_match;
   regmatch_list_init (&prev_match);
 
   DEBUG_ASSERT (nmatch > 1);
@@ -1394,7 +1397,7 @@
       free_fail_stack_return (fs);
       return REG_ESPACE;
     }
-  regmatch_t *prev_idx_match = regmatch_list_begin (&prev_match);
+  prev_idx_match = regmatch_list_begin (&prev_match);
   memcpy (prev_idx_match, pmatch, sizeof (regmatch_t) * nmatch);
 
   for (idx = pmatch[0].rm_so; idx <= pmatch[0].rm_eo ;)
diff -Naur ../orig/sed-4.9/lib/selinux/context.h ./lib/selinux/context.h
--- ../orig/sed-4.9/lib/selinux/context.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/selinux/context.h	2022-12-01 17:12:56.535189400 +0300
@@ -0,0 +1,86 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* SELinux-related headers.
+   Copyright (C) 2007-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* Written by Jim Meyering, 2007.  */
+
+#ifndef SELINUX_CONTEXT_H
+# define SELINUX_CONTEXT_H
+
+# include <errno.h>
+
+#ifndef _GL_INLINE_HEADER_BEGIN
+ #error "Please include config.h first."
+#endif
+_GL_INLINE_HEADER_BEGIN
+#ifndef SE_CONTEXT_INLINE
+# define SE_CONTEXT_INLINE _GL_INLINE
+#endif
+
+/* _GL_ATTRIBUTE_MAYBE_UNUSED declares that it is not a programming mistake if
+   the entity is not used.  The compiler should not warn if the entity is not
+   used.  */
+#ifndef _GL_ATTRIBUTE_MAYBE_UNUSED
+# if 0 /* no GCC or clang version supports this yet */
+#  define _GL_ATTRIBUTE_MAYBE_UNUSED [[__maybe_unused__]]
+# elif defined __GNUC__ || defined __clang__
+#  define _GL_ATTRIBUTE_MAYBE_UNUSED __attribute__ ((__unused__))
+# else
+#  define _GL_ATTRIBUTE_MAYBE_UNUSED
+# endif
+#endif
+
+typedef int context_t;
+SE_CONTEXT_INLINE context_t
+context_new (_GL_ATTRIBUTE_MAYBE_UNUSED char const *s)
+  { errno = ENOTSUP; return 0; }
+SE_CONTEXT_INLINE char *
+context_str (_GL_ATTRIBUTE_MAYBE_UNUSED context_t con)
+  { errno = ENOTSUP; return (void *) 0; }
+SE_CONTEXT_INLINE void context_free (_GL_ATTRIBUTE_MAYBE_UNUSED context_t c) {}
+
+SE_CONTEXT_INLINE int
+context_user_set (_GL_ATTRIBUTE_MAYBE_UNUSED context_t sc,
+                  _GL_ATTRIBUTE_MAYBE_UNUSED char const *s)
+  { errno = ENOTSUP; return -1; }
+SE_CONTEXT_INLINE int
+context_role_set (_GL_ATTRIBUTE_MAYBE_UNUSED context_t sc,
+                  _GL_ATTRIBUTE_MAYBE_UNUSED char const *s)
+  { errno = ENOTSUP; return -1; }
+SE_CONTEXT_INLINE int
+context_range_set (_GL_ATTRIBUTE_MAYBE_UNUSED context_t sc,
+                   _GL_ATTRIBUTE_MAYBE_UNUSED char const *s)
+  { errno = ENOTSUP; return -1; }
+SE_CONTEXT_INLINE int
+context_type_set (_GL_ATTRIBUTE_MAYBE_UNUSED context_t sc,
+                  _GL_ATTRIBUTE_MAYBE_UNUSED char const *s)
+  { errno = ENOTSUP; return -1; }
+SE_CONTEXT_INLINE char *
+context_type_get (_GL_ATTRIBUTE_MAYBE_UNUSED context_t sc)
+  { errno = ENOTSUP; return (void *) 0; }
+SE_CONTEXT_INLINE char *
+context_range_get (_GL_ATTRIBUTE_MAYBE_UNUSED context_t sc)
+  { errno = ENOTSUP; return (void *) 0; }
+SE_CONTEXT_INLINE char *
+context_role_get (_GL_ATTRIBUTE_MAYBE_UNUSED context_t sc)
+  { errno = ENOTSUP; return (void *) 0; }
+SE_CONTEXT_INLINE char *
+context_user_get (_GL_ATTRIBUTE_MAYBE_UNUSED context_t sc)
+  { errno = ENOTSUP; return (void *) 0; }
+
+_GL_INLINE_HEADER_END
+
+#endif
diff -Naur ../orig/sed-4.9/lib/selinux/label.h ./lib/selinux/label.h
--- ../orig/sed-4.9/lib/selinux/label.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/selinux/label.h	2022-12-01 17:12:56.604193400 +0300
@@ -0,0 +1,71 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Replacement <selinux/label.h> for platforms that lack it.
+   Copyright 2020-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* Written by Paul Eggert.  */
+
+#ifndef SELINUX_LABEL_H
+
+#define SELINUX_LABEL_H
+
+#include <selinux/selinux.h>
+#include <errno.h>
+
+#ifndef _GL_INLINE_HEADER_BEGIN
+ #error "Please include config.h first."
+#endif
+_GL_INLINE_HEADER_BEGIN
+#ifndef SE_LABEL_INLINE
+# define SE_LABEL_INLINE _GL_INLINE
+#endif
+
+/* _GL_ATTRIBUTE_MAYBE_UNUSED declares that it is not a programming mistake if
+   the entity is not used.  The compiler should not warn if the entity is not
+   used.  */
+#ifndef _GL_ATTRIBUTE_MAYBE_UNUSED
+# if 0 /* no GCC or clang version supports this yet */
+#  define _GL_ATTRIBUTE_MAYBE_UNUSED [[__maybe_unused__]]
+# elif defined __GNUC__ || defined __clang__
+#  define _GL_ATTRIBUTE_MAYBE_UNUSED __attribute__ ((__unused__))
+# else
+#  define _GL_ATTRIBUTE_MAYBE_UNUSED
+# endif
+#endif
+
+#define SELABEL_CTX_FILE 0
+
+struct selabel_handle;
+
+SE_LABEL_INLINE int
+selabel_lookup (_GL_ATTRIBUTE_MAYBE_UNUSED struct selabel_handle *hnd,
+                _GL_ATTRIBUTE_MAYBE_UNUSED char **context,
+                _GL_ATTRIBUTE_MAYBE_UNUSED char const *key,
+                _GL_ATTRIBUTE_MAYBE_UNUSED int type)
+{ errno = ENOTSUP; return -1; }
+
+SE_LABEL_INLINE struct selabel_handle *
+selabel_open (_GL_ATTRIBUTE_MAYBE_UNUSED int backend,
+              _GL_ATTRIBUTE_MAYBE_UNUSED struct selinux_opt *options,
+              _GL_ATTRIBUTE_MAYBE_UNUSED unsigned nopt)
+{ errno = ENOTSUP; return 0; }
+
+SE_LABEL_INLINE void
+selabel_close (_GL_ATTRIBUTE_MAYBE_UNUSED struct selabel_handle *hnd)
+{ errno = ENOTSUP; }
+
+_GL_INLINE_HEADER_END
+
+#endif
diff -Naur ../orig/sed-4.9/lib/selinux/selinux.h ./lib/selinux/selinux.h
--- ../orig/sed-4.9/lib/selinux/selinux.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/selinux/selinux.h	2022-12-01 17:12:56.463185300 +0300
@@ -0,0 +1,131 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Replacement <selinux/selinux.h> for platforms that lack it.
+   Copyright (C) 2008-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#if __GNUC__ >= 3
+
+#endif
+
+
+#if HAVE_SELINUX_SELINUX_H
+
+#include ""
+
+#else
+# if !defined _GL_SELINUX_SELINUX_H
+#  define _GL_SELINUX_SELINUX_H
+
+#  include <sys/types.h>
+#  include <errno.h>
+
+#  ifndef _GL_INLINE_HEADER_BEGIN
+    #error "Please include config.h first."
+#  endif
+_GL_INLINE_HEADER_BEGIN
+#  ifndef SE_SELINUX_INLINE
+#   define SE_SELINUX_INLINE _GL_INLINE
+#  endif
+
+/* _GL_ATTRIBUTE_MAYBE_UNUSED declares that it is not a programming mistake if
+   the entity is not used.  The compiler should not warn if the entity is not
+   used.  */
+#  ifndef _GL_ATTRIBUTE_MAYBE_UNUSED
+#   if 0 /* no GCC or clang version supports this yet */
+#    define _GL_ATTRIBUTE_MAYBE_UNUSED [[__maybe_unused__]]
+#   elif defined __GNUC__ || defined __clang__
+#    define _GL_ATTRIBUTE_MAYBE_UNUSED __attribute__ ((__unused__))
+#   else
+#    define _GL_ATTRIBUTE_MAYBE_UNUSED
+#   endif
+#  endif
+
+#  if !GNULIB_defined_security_types
+
+typedef unsigned short security_class_t;
+struct selinux_opt;
+#   define is_selinux_enabled() 0
+
+SE_SELINUX_INLINE int
+getcon (_GL_ATTRIBUTE_MAYBE_UNUSED char **con)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE void
+freecon (_GL_ATTRIBUTE_MAYBE_UNUSED char *con) {}
+
+SE_SELINUX_INLINE int
+getfscreatecon (_GL_ATTRIBUTE_MAYBE_UNUSED char **con)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+setfscreatecon (_GL_ATTRIBUTE_MAYBE_UNUSED char const *con)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+matchpathcon (_GL_ATTRIBUTE_MAYBE_UNUSED char const *file,
+              _GL_ATTRIBUTE_MAYBE_UNUSED mode_t m,
+              _GL_ATTRIBUTE_MAYBE_UNUSED char **con)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+getfilecon (_GL_ATTRIBUTE_MAYBE_UNUSED char const *file,
+            _GL_ATTRIBUTE_MAYBE_UNUSED char **con)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+lgetfilecon (_GL_ATTRIBUTE_MAYBE_UNUSED char const *file,
+             _GL_ATTRIBUTE_MAYBE_UNUSED char **con)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+fgetfilecon (int fd,_GL_ATTRIBUTE_MAYBE_UNUSED char **con)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+setfilecon (_GL_ATTRIBUTE_MAYBE_UNUSED char const *file,
+            _GL_ATTRIBUTE_MAYBE_UNUSED char const *con)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+lsetfilecon (_GL_ATTRIBUTE_MAYBE_UNUSED char const *file,
+             _GL_ATTRIBUTE_MAYBE_UNUSED char const *con)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+fsetfilecon (_GL_ATTRIBUTE_MAYBE_UNUSED int fd,
+             _GL_ATTRIBUTE_MAYBE_UNUSED char const *con)
+  { errno = ENOTSUP; return -1; }
+
+SE_SELINUX_INLINE int
+security_check_context (_GL_ATTRIBUTE_MAYBE_UNUSED char const *con)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+security_check_context_raw (_GL_ATTRIBUTE_MAYBE_UNUSED char const *con)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+setexeccon (_GL_ATTRIBUTE_MAYBE_UNUSED char const *con)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+security_compute_create (_GL_ATTRIBUTE_MAYBE_UNUSED char const *scon,
+                         _GL_ATTRIBUTE_MAYBE_UNUSED char const *tcon,
+                         _GL_ATTRIBUTE_MAYBE_UNUSED security_class_t tclass,
+                         _GL_ATTRIBUTE_MAYBE_UNUSED char **newcon)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE security_class_t
+string_to_security_class (char const *name)
+  { errno = ENOTSUP; return 0; }
+SE_SELINUX_INLINE int
+matchpathcon_init_prefix (_GL_ATTRIBUTE_MAYBE_UNUSED char const *path,
+                          _GL_ATTRIBUTE_MAYBE_UNUSED char const *prefix)
+  { errno = ENOTSUP; return -1; }
+
+#   define GNULIB_defined_security_types 1
+#  endif
+
+_GL_INLINE_HEADER_END
+
+# endif
+#endif
diff -Naur ../orig/sed-4.9/lib/stdalign.h ./lib/stdalign.h
--- ../orig/sed-4.9/lib/stdalign.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/stdalign.h	2022-12-01 17:12:56.671197200 +0300
@@ -0,0 +1,134 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A substitute for ISO C11 <stdalign.h>.
+
+   Copyright 2011-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* Written by Paul Eggert and Bruno Haible.  */
+
+#ifndef _GL_STDALIGN_H
+#define _GL_STDALIGN_H
+
+/* ISO C11 <stdalign.h> for platforms that lack it.
+
+   References:
+   ISO C11 (latest free draft
+   <http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf>)
+   sections 6.5.3.4, 6.7.5, 7.15.
+   C++11 (latest free draft
+   <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf>)
+   section 18.10. */
+
+/* alignof (TYPE), also known as _Alignof (TYPE), yields the alignment
+   requirement of a structure member (i.e., slot or field) that is of
+   type TYPE, as an integer constant expression.
+
+   This differs from GCC's and clang's __alignof__ operator, which can
+   yield a better-performing alignment for an object of that type.  For
+   example, on x86 with GCC and on Linux/x86 with clang,
+   __alignof__ (double) and __alignof__ (long long) are 8, whereas
+   alignof (double) and alignof (long long) are 4 unless the option
+   '-malign-double' is used.
+
+   The result cannot be used as a value for an 'enum' constant, if you
+   want to be portable to HP-UX 10.20 cc and AIX 3.2.5 xlc.  */
+
+/* FreeBSD 9.1 <sys/cdefs.h>, included by <stddef.h> and lots of other
+   standard headers, defines conflicting implementations of _Alignas
+   and _Alignof that are no better than ours; override them.  */
+#undef _Alignas
+#undef _Alignof
+
+/* GCC releases before GCC 4.9 had a bug in _Alignof.  See GCC bug 52023
+   <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=52023>.
+   clang versions < 8.0.0 have the same bug.  */
+#if (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112 \
+     || (defined __GNUC__ && __GNUC__ < 4 + (__GNUC_MINOR__ < 9) \
+         && !defined __clang__) \
+     || (defined __clang__ && __clang_major__ < 8))
+# ifdef __cplusplus
+#  if (201103 <= __cplusplus || defined _MSC_VER)
+#   define _Alignof(type) alignof (type)
+#  else
+   template <class __t> struct __alignof_helper { char __a; __t __b; };
+#   define _Alignof(type) offsetof (__alignof_helper<type>, __b)
+#   define _GL_STDALIGN_NEEDS_STDDEF 1
+#  endif
+# else
+#  define _Alignof(type) offsetof (struct { char __a; type __b; }, __b)
+#  define _GL_STDALIGN_NEEDS_STDDEF 1
+# endif
+#endif
+#if ! (defined __cplusplus && (201103 <= __cplusplus || defined _MSC_VER))
+# define alignof _Alignof
+#endif
+#define __alignof_is_defined 1
+
+/* alignas (A), also known as _Alignas (A), aligns a variable or type
+   to the alignment A, where A is an integer constant expression.  For
+   example:
+
+      int alignas (8) foo;
+      struct s { int a; int alignas (8) bar; };
+
+   aligns the address of FOO and the offset of BAR to be multiples of 8.
+
+   A should be a power of two that is at least the type's alignment
+   and at most the implementation's alignment limit.  This limit is
+   2**28 on typical GNUish hosts, and 2**13 on MSVC.  To be portable
+   to MSVC through at least version 10.0, A should be an integer
+   constant, as MSVC does not support expressions such as 1 << 3.
+   To be portable to Sun C 5.11, do not align auto variables to
+   anything stricter than their default alignment.
+
+   The following C11 requirements are not supported here:
+
+     - If A is zero, alignas has no effect.
+     - alignas can be used multiple times; the strictest one wins.
+     - alignas (TYPE) is equivalent to alignas (alignof (TYPE)).
+
+   */
+
+#if !defined __STDC_VERSION__ || __STDC_VERSION__ < 201112
+# if defined __cplusplus && (201103 <= __cplusplus || defined _MSC_VER)
+#  define _Alignas(a) alignas (a)
+# elif (!defined __attribute__ \
+        && ((defined __APPLE__ && defined __MACH__ \
+             ? 4 < __GNUC__ + (1 <= __GNUC_MINOR__) \
+             : __GNUC__ && !defined __ibmxl__) \
+            || (4 <= __clang_major__) \
+            || (__ia64 && (61200 <= __HP_cc || 61200 <= __HP_aCC)) \
+            || __ICC || 0x590 <= __SUNPRO_C || 0x0600 <= __xlC__))
+#  define _Alignas(a) __attribute__ ((__aligned__ (a)))
+# elif 1300 <= _MSC_VER
+#  define _Alignas(a) __declspec (align (a))
+# endif
+#endif
+#if ((defined _Alignas \
+      && !(defined __cplusplus && (201103 <= __cplusplus || defined _MSC_VER))) \
+     || (defined __STDC_VERSION__ && 201112 <= __STDC_VERSION__))
+# define alignas _Alignas
+#endif
+#if (defined alignas \
+     || (defined __cplusplus && (201103 <= __cplusplus || defined _MSC_VER)))
+# define __alignas_is_defined 1
+#endif
+
+/* Include <stddef.h> if needed for offsetof.  */
+#if _GL_STDALIGN_NEEDS_STDDEF
+# include <stddef.h>
+#endif
+
+#endif /* _GL_STDALIGN_H */
diff -Naur ../orig/sed-4.9/lib/stdckdint.h ./lib/stdckdint.h
--- ../orig/sed-4.9/lib/stdckdint.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/stdckdint.h	2022-12-01 17:12:56.769200000 +0300
@@ -0,0 +1,36 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* stdckdint.h -- checked integer arithmetic
+
+   Copyright 2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_STDCKDINT_H
+#define _GL_STDCKDINT_H
+
+#include "intprops-internal.h"
+
+/* Store into *R the low-order bits of A + B, A - B, A * B, respectively.
+   Return 1 if the result overflows, 0 otherwise.
+   A, B, and *R can have any integer type other than char, bool, a
+   bit-precise integer type, or an enumeration type.
+
+   These are like the standard macros introduced in C23, except that
+   arguments should not have side effects.  */
+
+#define ckd_add(r, a, b) ((bool) _GL_INT_ADD_WRAPV (a, b, r))
+#define ckd_sub(r, a, b) ((bool) _GL_INT_SUBTRACT_WRAPV (a, b, r))
+#define ckd_mul(r, a, b) ((bool) _GL_INT_MULTIPLY_WRAPV (a, b, r))
+
+#endif /* _GL_STDCKDINT_H */
diff -Naur ../orig/sed-4.9/lib/stddef.h ./lib/stddef.h
--- ../orig/sed-4.9/lib/stddef.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/stddef.h	2022-12-01 17:13:19.129986300 +0300
@@ -0,0 +1,148 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A substitute for POSIX 2008 <stddef.h>, for platforms that have issues.
+
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* Written by Eric Blake.  */
+
+/*
+ * POSIX 2008 <stddef.h> for platforms that have issues.
+ * <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stddef.h.html>
+ */
+
+#if __GNUC__ >= 3
+
+#endif
+
+
+#if defined __need_wchar_t || defined __need_size_t  \
+  || defined __need_ptrdiff_t || defined __need_NULL \
+  || defined __need_wint_t
+/* Special invocation convention inside gcc header files.  In
+   particular, gcc provides a version of <stddef.h> that blindly
+   redefines NULL even when __need_wint_t was defined, even though
+   wint_t is not normally provided by <stddef.h>.  Hence, we must
+   remember if special invocation has ever been used to obtain wint_t,
+   in which case we need to clean up NULL yet again.  */
+
+# if !(defined _GL_STDDEF_H && defined _GL_STDDEF_WINT_T)
+#  ifdef __need_wint_t
+#   define _GL_STDDEF_WINT_T
+#  endif
+#  include ""
+   /* On TinyCC, make sure that the macros that indicate the special invocation
+      convention get undefined.  */
+#  undef __need_wchar_t
+#  undef __need_size_t
+#  undef __need_ptrdiff_t
+#  undef __need_NULL
+#  undef __need_wint_t
+# endif
+
+#else
+/* Normal invocation convention.  */
+
+# ifndef _GL_STDDEF_H
+
+/* On AIX 7.2, with xlc in 64-bit mode, <stddef.h> defines max_align_t to a
+   type with alignment 4, but 'long' has alignment 8.  */
+#  if defined _AIX && defined __LP64__
+#   if !GNULIB_defined_max_align_t
+#    ifdef _MAX_ALIGN_T
+/* /usr/include/stddef.h has already defined max_align_t.  Override it.  */
+typedef long rpl_max_align_t;
+#     define max_align_t rpl_max_align_t
+#    else
+/* Prevent /usr/include/stddef.h from defining max_align_t.  */
+typedef long max_align_t;
+#     define _MAX_ALIGN_T
+#    endif
+#    define GNULIB_defined_max_align_t 1
+#   endif
+#  endif
+
+/* The include_next requires a split double-inclusion guard.  */
+
+#  include "C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\INCLUDE\stddef.h"
+
+/* On NetBSD 5.0, the definition of NULL lacks proper parentheses.  */
+#  if (0 \
+       && (!defined _GL_STDDEF_H || defined _GL_STDDEF_WINT_T))
+#   undef NULL
+#   ifdef __cplusplus
+   /* ISO C++ says that the macro NULL must expand to an integer constant
+      expression, hence '((void *) 0)' is not allowed in C++.  */
+#    if __GNUG__ >= 3
+    /* GNU C++ has a __null macro that behaves like an integer ('int' or
+       'long') but has the same size as a pointer.  Use that, to avoid
+       warnings.  */
+#     define NULL __null
+#    else
+#     define NULL 0L
+#    endif
+#   else
+#    define NULL ((void *) 0)
+#   endif
+#  endif
+
+#  ifndef _GL_STDDEF_H
+#   define _GL_STDDEF_H
+
+/* Some platforms lack wchar_t.  */
+#if !1
+# define wchar_t int
+#endif
+
+/* Some platforms lack max_align_t.  The check for _GCC_MAX_ALIGN_T is
+   a hack in case the configure-time test was done with g++ even though
+   we are currently compiling with gcc.
+   On MSVC, max_align_t is defined only in C++ mode, after <cstddef> was
+   included.  Its definition is good since it has an alignment of 8 (on x86
+   and x86_64).
+   Similarly on OS/2 kLIBC.  */
+#if (defined _MSC_VER || (defined __KLIBC__ && !defined __LIBCN__)) \
+    && defined __cplusplus
+# include <cstddef>
+#else
+# if ! (0 || (defined _GCC_MAX_ALIGN_T && !defined __clang__))
+#  if !GNULIB_defined_max_align_t
+/* On the x86, the maximum storage alignment of double, long, etc. is 4,
+   but GCC's C11 ABI for x86 says that max_align_t has an alignment of 8,
+   and the C11 standard allows this.  Work around this problem by
+   using __alignof__ (which returns 8 for double) rather than _Alignof
+   (which returns 4), and align each union member accordingly.  */
+#   if defined __GNUC__ || (__clang_major__ >= 4)
+#    define _GL_STDDEF_ALIGNAS(type) \
+       __attribute__ ((__aligned__ (__alignof__ (type))))
+#   else
+#    define _GL_STDDEF_ALIGNAS(type) /* */
+#   endif
+typedef union
+{
+  char *__p _GL_STDDEF_ALIGNAS (char *);
+  double __d _GL_STDDEF_ALIGNAS (double);
+  long double __ld _GL_STDDEF_ALIGNAS (long double);
+  long int __i _GL_STDDEF_ALIGNAS (long int);
+} rpl_max_align_t;
+#   define max_align_t rpl_max_align_t
+#   define GNULIB_defined_max_align_t 1
+#  endif
+# endif
+#endif
+
+#  endif /* _GL_STDDEF_H */
+# endif /* _GL_STDDEF_H */
+#endif /* __need_XXX */
diff -Naur ../orig/sed-4.9/lib/stdint.h ./lib/stdint.h
--- ../orig/sed-4.9/lib/stdint.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/stdint.h	2022-12-01 17:13:19.129986300 +0300
@@ -0,0 +1,741 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Copyright (C) 2001-2002, 2004-2022 Free Software Foundation, Inc.
+   Written by Paul Eggert, Bruno Haible, Sam Steingold, Peter Burwood.
+   This file is part of gnulib.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/*
+ * ISO C 99 <stdint.h> for platforms that lack it.
+ * <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdint.h.html>
+ */
+
+#ifndef _GL_STDINT_H
+
+#if __GNUC__ >= 3
+
+#endif
+
+
+/* When including a system file that in turn includes <inttypes.h>,
+   use the system <inttypes.h>, not our substitute.  This avoids
+   problems with (for example) VMS, whose <sys/bitypes.h> includes
+   <inttypes.h>.  */
+#define _GL_JUST_INCLUDE_SYSTEM_INTTYPES_H
+
+/* On Android (Bionic libc), <sys/types.h> includes this file before
+   having defined 'time_t'.  Therefore in this case avoid including
+   other system header files; just include the system's <stdint.h>.
+   Ideally we should test __BIONIC__ here, but it is only defined after
+   <sys/cdefs.h> has been included; hence test __ANDROID__ instead.  */
+#if defined __ANDROID__ && defined _GL_INCLUDING_SYS_TYPES_H
+# include ""
+#else
+
+/* Get those types that are already defined in other system include
+   files, so that we can "#define int8_t signed char" below without
+   worrying about a later system include file containing a "typedef
+   signed char int8_t;" that will get messed up by our macro.  Our
+   macros should all be consistent with the system versions, except
+   for the "fast" types and macros, which we recommend against using
+   in public interfaces due to compiler differences.  */
+
+#if 0
+# if defined __sgi && ! defined __c99
+   /* Bypass IRIX's <stdint.h> if in C89 mode, since it merely annoys users
+      with "This header file is to be used only for c99 mode compilations"
+      diagnostics.  */
+#  define __STDINT_H__
+# endif
+
+  /* Some pre-C++11 <stdint.h> implementations need this.  */
+# ifdef __cplusplus
+#  ifndef __STDC_CONSTANT_MACROS
+#   define __STDC_CONSTANT_MACROS 1
+#  endif
+#  ifndef __STDC_LIMIT_MACROS
+#   define __STDC_LIMIT_MACROS 1
+#  endif
+# endif
+
+  /* Other systems may have an incomplete or buggy <stdint.h>.
+     Include it before <inttypes.h>, since any "#include <stdint.h>"
+     in <inttypes.h> would reinclude us, skipping our contents because
+     _GL_STDINT_H is defined.
+     The include_next requires a split double-inclusion guard.  */
+# include "C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\INCLUDE\stdint.h"
+#endif
+
+#if ! defined _GL_STDINT_H && ! defined _GL_JUST_INCLUDE_SYSTEM_STDINT_H
+#define _GL_STDINT_H
+
+/* Get SCHAR_MIN, SCHAR_MAX, UCHAR_MAX, INT_MIN, INT_MAX,
+   LONG_MIN, LONG_MAX, ULONG_MAX, _GL_INTEGER_WIDTH.  */
+#include <limits.h>
+
+/* Override WINT_MIN and WINT_MAX if gnulib's <wchar.h> or <wctype.h> overrides
+   wint_t.  */
+#if 1
+# undef WINT_MIN
+# undef WINT_MAX
+# define WINT_MIN 0x0U
+# define WINT_MAX 0xffffffffU
+#endif
+
+#if ! 0
+
+/* <sys/types.h> defines some of the stdint.h types as well, on glibc,
+   IRIX 6.5, and OpenBSD 3.8 (via <machine/types.h>).
+   AIX 5.2 <sys/types.h> isn't needed and causes troubles.
+   Mac OS X 10.4.6 <sys/types.h> includes <stdint.h> (which is us), but
+   relies on the system <stdint.h> definitions, so include
+   <sys/types.h> after "".  */
+# if 1 && ! defined _AIX
+#  include <sys/types.h>
+# endif
+
+# if 0
+  /* In OpenBSD 3.8, <inttypes.h> includes <machine/types.h>, which defines
+     int{8,16,32,64}_t, uint{8,16,32,64}_t and __BIT_TYPES_DEFINED__.
+     <inttypes.h> also defines intptr_t and uintptr_t.  */
+#  include <inttypes.h>
+# elif 0
+  /* Solaris 7 <sys/inttypes.h> has the types except the *_fast*_t types, and
+     the macros except for *_FAST*_*, INTPTR_MIN, PTRDIFF_MIN, PTRDIFF_MAX.  */
+#  include <sys/inttypes.h>
+# endif
+
+# if 0 && ! defined __BIT_TYPES_DEFINED__
+  /* Linux libc4 >= 4.6.7 and libc5 have a <sys/bitypes.h> that defines
+     int{8,16,32,64}_t and __BIT_TYPES_DEFINED__.  In libc5 >= 5.2.2 it is
+     included by <sys/types.h>.  */
+#  include <sys/bitypes.h>
+# endif
+
+# undef _GL_JUST_INCLUDE_SYSTEM_INTTYPES_H
+
+/* Minimum and maximum values for an integer type under the usual assumption.
+   Return an unspecified value if BITS == 0, adding a check to pacify
+   picky compilers.  */
+
+/* These are separate macros, because if you try to merge these macros into
+   a single one, HP-UX cc rejects the resulting expression in constant
+   expressions.  */
+# define _STDINT_UNSIGNED_MIN(bits, zero) \
+    (zero)
+# define _STDINT_SIGNED_MIN(bits, zero) \
+    (~ _STDINT_MAX (1, bits, zero))
+
+# define _STDINT_MAX(signed, bits, zero) \
+    (((((zero) + 1) << ((bits) ? (bits) - 1 - (signed) : 0)) - 1) * 2 + 1)
+
+#if !GNULIB_defined_stdint_types
+
+/* 7.18.1.1. Exact-width integer types */
+
+/* Here we assume a standard architecture where the hardware integer
+   types have 8, 16, 32, optionally 64 bits.  */
+
+# undef int8_t
+# undef uint8_t
+typedef signed char gl_int8_t;
+typedef unsigned char gl_uint8_t;
+# define int8_t gl_int8_t
+# define uint8_t gl_uint8_t
+
+# undef int16_t
+# undef uint16_t
+typedef short int gl_int16_t;
+typedef unsigned short int gl_uint16_t;
+# define int16_t gl_int16_t
+# define uint16_t gl_uint16_t
+
+# undef int32_t
+# undef uint32_t
+typedef int gl_int32_t;
+typedef unsigned int gl_uint32_t;
+# define int32_t gl_int32_t
+# define uint32_t gl_uint32_t
+
+/* If the system defines INT64_MAX, assume int64_t works.  That way,
+   if the underlying platform defines int64_t to be a 64-bit long long
+   int, the code below won't mistakenly define it to be a 64-bit long
+   int, which would mess up C++ name mangling.  We must use #ifdef
+   rather than #if, to avoid an error with HP-UX 10.20 cc.  */
+
+# ifdef INT64_MAX
+#  define GL_INT64_T
+# else
+/* Do not undefine int64_t if gnulib is not being used with 64-bit
+   types, since otherwise it breaks platforms like Tandem/NSK.  */
+#  if LONG_MAX >> 31 >> 31 == 1
+#   undef int64_t
+typedef long int gl_int64_t;
+#   define int64_t gl_int64_t
+#   define GL_INT64_T
+#  elif defined _MSC_VER
+#   undef int64_t
+typedef __int64 gl_int64_t;
+#   define int64_t gl_int64_t
+#   define GL_INT64_T
+#  else
+#   undef int64_t
+typedef long long int gl_int64_t;
+#   define int64_t gl_int64_t
+#   define GL_INT64_T
+#  endif
+# endif
+
+# ifdef UINT64_MAX
+#  define GL_UINT64_T
+# else
+#  if ULONG_MAX >> 31 >> 31 >> 1 == 1
+#   undef uint64_t
+typedef unsigned long int gl_uint64_t;
+#   define uint64_t gl_uint64_t
+#   define GL_UINT64_T
+#  elif defined _MSC_VER
+#   undef uint64_t
+typedef unsigned __int64 gl_uint64_t;
+#   define uint64_t gl_uint64_t
+#   define GL_UINT64_T
+#  else
+#   undef uint64_t
+typedef unsigned long long int gl_uint64_t;
+#   define uint64_t gl_uint64_t
+#   define GL_UINT64_T
+#  endif
+# endif
+
+/* Avoid collision with Solaris 2.5.1 <pthread.h> etc.  */
+# define _UINT8_T
+# define _UINT32_T
+# define _UINT64_T
+
+
+/* 7.18.1.2. Minimum-width integer types */
+
+/* Here we assume a standard architecture where the hardware integer
+   types have 8, 16, 32, optionally 64 bits. Therefore the leastN_t types
+   are the same as the corresponding N_t types.  */
+
+# undef int_least8_t
+# undef uint_least8_t
+# undef int_least16_t
+# undef uint_least16_t
+# undef int_least32_t
+# undef uint_least32_t
+# undef int_least64_t
+# undef uint_least64_t
+# define int_least8_t int8_t
+# define uint_least8_t uint8_t
+# define int_least16_t int16_t
+# define uint_least16_t uint16_t
+# define int_least32_t int32_t
+# define uint_least32_t uint32_t
+# ifdef GL_INT64_T
+#  define int_least64_t int64_t
+# endif
+# ifdef GL_UINT64_T
+#  define uint_least64_t uint64_t
+# endif
+
+/* 7.18.1.3. Fastest minimum-width integer types */
+
+/* Note: Other <stdint.h> substitutes may define these types differently.
+   It is not recommended to use these types in public header files. */
+
+/* Here we assume a standard architecture where the hardware integer
+   types have 8, 16, 32, optionally 64 bits. Therefore the fastN_t types
+   are taken from the same list of types.  The following code normally
+   uses types consistent with glibc, as that lessens the chance of
+   incompatibility with older GNU hosts.  */
+
+# undef int_fast8_t
+# undef uint_fast8_t
+# undef int_fast16_t
+# undef uint_fast16_t
+# undef int_fast32_t
+# undef uint_fast32_t
+# undef int_fast64_t
+# undef uint_fast64_t
+typedef signed char gl_int_fast8_t;
+typedef unsigned char gl_uint_fast8_t;
+
+# ifdef __sun
+/* Define types compatible with SunOS 5.10, so that code compiled under
+   earlier SunOS versions works with code compiled under SunOS 5.10.  */
+typedef int gl_int_fast32_t;
+typedef unsigned int gl_uint_fast32_t;
+# else
+typedef long int gl_int_fast32_t;
+typedef unsigned long int gl_uint_fast32_t;
+# endif
+typedef gl_int_fast32_t gl_int_fast16_t;
+typedef gl_uint_fast32_t gl_uint_fast16_t;
+
+# define int_fast8_t gl_int_fast8_t
+# define uint_fast8_t gl_uint_fast8_t
+# define int_fast16_t gl_int_fast16_t
+# define uint_fast16_t gl_uint_fast16_t
+# define int_fast32_t gl_int_fast32_t
+# define uint_fast32_t gl_uint_fast32_t
+# ifdef GL_INT64_T
+#  define int_fast64_t int64_t
+# endif
+# ifdef GL_UINT64_T
+#  define uint_fast64_t uint64_t
+# endif
+
+/* 7.18.1.4. Integer types capable of holding object pointers */
+
+/* kLIBC's <stdint.h> defines _INTPTR_T_DECLARED and needs its own
+   definitions of intptr_t and uintptr_t (which use int and unsigned)
+   to avoid clashes with declarations of system functions like sbrk.
+   Similarly, MinGW WSL-5.4.1 <stdint.h> needs its own intptr_t and
+   uintptr_t to avoid conflicting declarations of system functions like
+   _findclose in <io.h>.  */
+# if !((defined __KLIBC__ && defined _INTPTR_T_DECLARED) \
+       || defined __MINGW32__)
+#  undef intptr_t
+#  undef uintptr_t
+#  ifdef _WIN64
+typedef long long int gl_intptr_t;
+typedef unsigned long long int gl_uintptr_t;
+#  else
+typedef long int gl_intptr_t;
+typedef unsigned long int gl_uintptr_t;
+#  endif
+#  define intptr_t gl_intptr_t
+#  define uintptr_t gl_uintptr_t
+# endif
+
+/* 7.18.1.5. Greatest-width integer types */
+
+/* Note: These types are compiler dependent. It may be unwise to use them in
+   public header files. */
+
+/* If the system defines INTMAX_MAX, assume that intmax_t works, and
+   similarly for UINTMAX_MAX and uintmax_t.  This avoids problems with
+   assuming one type where another is used by the system.  */
+
+# ifndef INTMAX_MAX
+#  undef INTMAX_C
+#  undef intmax_t
+#  if LONG_MAX >> 30 == 1
+typedef long long int gl_intmax_t;
+#   define intmax_t gl_intmax_t
+#  elif defined GL_INT64_T
+#   define intmax_t int64_t
+#  else
+typedef long int gl_intmax_t;
+#   define intmax_t gl_intmax_t
+#  endif
+# endif
+
+# ifndef UINTMAX_MAX
+#  undef UINTMAX_C
+#  undef uintmax_t
+#  if ULONG_MAX >> 31 == 1
+typedef unsigned long long int gl_uintmax_t;
+#   define uintmax_t gl_uintmax_t
+#  elif defined GL_UINT64_T
+#   define uintmax_t uint64_t
+#  else
+typedef unsigned long int gl_uintmax_t;
+#   define uintmax_t gl_uintmax_t
+#  endif
+# endif
+
+/* Verify that intmax_t and uintmax_t have the same size.  Too much code
+   breaks if this is not the case.  If this check fails, the reason is likely
+   to be found in the autoconf macros.  */
+typedef int _verify_intmax_size[sizeof (intmax_t) == sizeof (uintmax_t)
+                                ? 1 : -1];
+
+# define GNULIB_defined_stdint_types 1
+# endif /* !GNULIB_defined_stdint_types */
+
+/* 7.18.2. Limits of specified-width integer types */
+
+/* 7.18.2.1. Limits of exact-width integer types */
+
+/* Here we assume a standard architecture where the hardware integer
+   types have 8, 16, 32, optionally 64 bits.  */
+
+# undef INT8_MIN
+# undef INT8_MAX
+# undef UINT8_MAX
+# define INT8_MIN  (~ INT8_MAX)
+# define INT8_MAX  127
+# define UINT8_MAX  255
+
+# undef INT16_MIN
+# undef INT16_MAX
+# undef UINT16_MAX
+# define INT16_MIN  (~ INT16_MAX)
+# define INT16_MAX  32767
+# define UINT16_MAX  65535
+
+# undef INT32_MIN
+# undef INT32_MAX
+# undef UINT32_MAX
+# define INT32_MIN  (~ INT32_MAX)
+# define INT32_MAX  2147483647
+# define UINT32_MAX  4294967295U
+
+# if defined GL_INT64_T && ! defined INT64_MAX
+/* Prefer (- INTMAX_C (1) << 63) over (~ INT64_MAX) because SunPRO C 5.0
+   evaluates the latter incorrectly in preprocessor expressions.  */
+#  define INT64_MIN  (- INTMAX_C (1) << 63)
+#  define INT64_MAX  INTMAX_C (9223372036854775807)
+# endif
+
+# if defined GL_UINT64_T && ! defined UINT64_MAX
+#  define UINT64_MAX  UINTMAX_C (18446744073709551615)
+# endif
+
+/* 7.18.2.2. Limits of minimum-width integer types */
+
+/* Here we assume a standard architecture where the hardware integer
+   types have 8, 16, 32, optionally 64 bits. Therefore the leastN_t types
+   are the same as the corresponding N_t types.  */
+
+# undef INT_LEAST8_MIN
+# undef INT_LEAST8_MAX
+# undef UINT_LEAST8_MAX
+# define INT_LEAST8_MIN  INT8_MIN
+# define INT_LEAST8_MAX  INT8_MAX
+# define UINT_LEAST8_MAX  UINT8_MAX
+
+# undef INT_LEAST16_MIN
+# undef INT_LEAST16_MAX
+# undef UINT_LEAST16_MAX
+# define INT_LEAST16_MIN  INT16_MIN
+# define INT_LEAST16_MAX  INT16_MAX
+# define UINT_LEAST16_MAX  UINT16_MAX
+
+# undef INT_LEAST32_MIN
+# undef INT_LEAST32_MAX
+# undef UINT_LEAST32_MAX
+# define INT_LEAST32_MIN  INT32_MIN
+# define INT_LEAST32_MAX  INT32_MAX
+# define UINT_LEAST32_MAX  UINT32_MAX
+
+# undef INT_LEAST64_MIN
+# undef INT_LEAST64_MAX
+# ifdef GL_INT64_T
+#  define INT_LEAST64_MIN  INT64_MIN
+#  define INT_LEAST64_MAX  INT64_MAX
+# endif
+
+# undef UINT_LEAST64_MAX
+# ifdef GL_UINT64_T
+#  define UINT_LEAST64_MAX  UINT64_MAX
+# endif
+
+/* 7.18.2.3. Limits of fastest minimum-width integer types */
+
+/* Here we assume a standard architecture where the hardware integer
+   types have 8, 16, 32, optionally 64 bits. Therefore the fastN_t types
+   are taken from the same list of types.  */
+
+# undef INT_FAST8_MIN
+# undef INT_FAST8_MAX
+# undef UINT_FAST8_MAX
+# define INT_FAST8_MIN  SCHAR_MIN
+# define INT_FAST8_MAX  SCHAR_MAX
+# define UINT_FAST8_MAX  UCHAR_MAX
+
+# undef INT_FAST16_MIN
+# undef INT_FAST16_MAX
+# undef UINT_FAST16_MAX
+# define INT_FAST16_MIN  INT_FAST32_MIN
+# define INT_FAST16_MAX  INT_FAST32_MAX
+# define UINT_FAST16_MAX  UINT_FAST32_MAX
+
+# undef INT_FAST32_MIN
+# undef INT_FAST32_MAX
+# undef UINT_FAST32_MAX
+# ifdef __sun
+#  define INT_FAST32_MIN  INT_MIN
+#  define INT_FAST32_MAX  INT_MAX
+#  define UINT_FAST32_MAX  UINT_MAX
+# else
+#  define INT_FAST32_MIN  LONG_MIN
+#  define INT_FAST32_MAX  LONG_MAX
+#  define UINT_FAST32_MAX  ULONG_MAX
+# endif
+
+# undef INT_FAST64_MIN
+# undef INT_FAST64_MAX
+# ifdef GL_INT64_T
+#  define INT_FAST64_MIN  INT64_MIN
+#  define INT_FAST64_MAX  INT64_MAX
+# endif
+
+# undef UINT_FAST64_MAX
+# ifdef GL_UINT64_T
+#  define UINT_FAST64_MAX  UINT64_MAX
+# endif
+
+/* 7.18.2.4. Limits of integer types capable of holding object pointers */
+
+# undef INTPTR_MIN
+# undef INTPTR_MAX
+# undef UINTPTR_MAX
+# ifdef _WIN64
+#  define INTPTR_MIN  LLONG_MIN
+#  define INTPTR_MAX  LLONG_MAX
+#  define UINTPTR_MAX  ULLONG_MAX
+# else
+#  define INTPTR_MIN  LONG_MIN
+#  define INTPTR_MAX  LONG_MAX
+#  define UINTPTR_MAX  ULONG_MAX
+# endif
+
+/* 7.18.2.5. Limits of greatest-width integer types */
+
+# ifndef INTMAX_MAX
+#  undef INTMAX_MIN
+#  ifdef INT64_MAX
+#   define INTMAX_MIN  INT64_MIN
+#   define INTMAX_MAX  INT64_MAX
+#  else
+#   define INTMAX_MIN  INT32_MIN
+#   define INTMAX_MAX  INT32_MAX
+#  endif
+# endif
+
+# ifndef UINTMAX_MAX
+#  ifdef UINT64_MAX
+#   define UINTMAX_MAX  UINT64_MAX
+#  else
+#   define UINTMAX_MAX  UINT32_MAX
+#  endif
+# endif
+
+/* 7.18.3. Limits of other integer types */
+
+/* ptrdiff_t limits */
+# undef PTRDIFF_MIN
+# undef PTRDIFF_MAX
+# if 0
+#  ifdef _LP64
+#   define PTRDIFF_MIN  _STDINT_SIGNED_MIN (64, 0l)
+#   define PTRDIFF_MAX  _STDINT_MAX (1, 64, 0l)
+#  else
+#   define PTRDIFF_MIN  _STDINT_SIGNED_MIN (32, 0)
+#   define PTRDIFF_MAX  _STDINT_MAX (1, 32, 0)
+#  endif
+# else
+#  define PTRDIFF_MIN  \
+    _STDINT_SIGNED_MIN (32, 0)
+#  define PTRDIFF_MAX  \
+    _STDINT_MAX (1, 32, 0)
+# endif
+
+/* sig_atomic_t limits */
+# undef SIG_ATOMIC_MIN
+# undef SIG_ATOMIC_MAX
+# if 1
+#  define SIG_ATOMIC_MIN  \
+    _STDINT_SIGNED_MIN (32, 0)
+# else
+#  define SIG_ATOMIC_MIN  \
+    _STDINT_UNSIGNED_MIN (32, 0)
+# endif
+# define SIG_ATOMIC_MAX  \
+   _STDINT_MAX (1, 32, \
+                0)
+
+
+/* size_t limit */
+# undef SIZE_MAX
+# if 0
+#  ifdef _LP64
+#   define SIZE_MAX  _STDINT_MAX (0, 64, 0ul)
+#  else
+#   define SIZE_MAX  _STDINT_MAX (0, 32, 0ul)
+#  endif
+# else
+#  define SIZE_MAX  _STDINT_MAX (0, 32, 0u)
+# endif
+
+/* wchar_t limits */
+/* Get WCHAR_MIN, WCHAR_MAX.
+   This include is not on the top, above, because on OSF/1 4.0 we have a
+   sequence of nested includes
+   <wchar.h> -> <stdio.h> -> <getopt.h> -> <stdlib.h>, and the latter includes
+   <stdint.h> and assumes its types are already defined.  */
+# if 1 && ! (defined WCHAR_MIN && defined WCHAR_MAX)
+#  define _GL_JUST_INCLUDE_SYSTEM_WCHAR_H
+#  include <wchar.h>
+#  undef _GL_JUST_INCLUDE_SYSTEM_WCHAR_H
+# endif
+# undef WCHAR_MIN
+# undef WCHAR_MAX
+# if 0
+#  define WCHAR_MIN  \
+    _STDINT_SIGNED_MIN (16, 0)
+# else
+#  define WCHAR_MIN  \
+    _STDINT_UNSIGNED_MIN (16, 0)
+# endif
+# define WCHAR_MAX  \
+   _STDINT_MAX (0, 16, 0)
+
+/* wint_t limits */
+/* If gnulib's <wchar.h> or <wctype.h> overrides wint_t,  is not
+   accurate, therefore use the definitions from above.  */
+# if !1
+#  undef WINT_MIN
+#  undef WINT_MAX
+#  if 0
+#   define WINT_MIN  \
+     _STDINT_SIGNED_MIN (32, 0)
+#  else
+#   define WINT_MIN  \
+     _STDINT_UNSIGNED_MIN (32, 0)
+#  endif
+#  define WINT_MAX  \
+    _STDINT_MAX (0, 32, 0)
+# endif
+
+/* 7.18.4. Macros for integer constants */
+
+/* 7.18.4.1. Macros for minimum-width integer constants */
+/* According to ISO C 99 Technical Corrigendum 1 */
+
+/* Here we assume a standard architecture where the hardware integer
+   types have 8, 16, 32, optionally 64 bits, and int is 32 bits.  */
+
+# undef INT8_C
+# undef UINT8_C
+# define INT8_C(x) x
+# define UINT8_C(x) x
+
+# undef INT16_C
+# undef UINT16_C
+# define INT16_C(x) x
+# define UINT16_C(x) x
+
+# undef INT32_C
+# undef UINT32_C
+# define INT32_C(x) x
+# define UINT32_C(x) x ## U
+
+# undef INT64_C
+# undef UINT64_C
+# if LONG_MAX >> 31 >> 31 == 1
+#  define INT64_C(x) x##L
+# elif defined _MSC_VER
+#  define INT64_C(x) x##i64
+# else
+#  define INT64_C(x) x##LL
+# endif
+# if ULONG_MAX >> 31 >> 31 >> 1 == 1
+#  define UINT64_C(x) x##UL
+# elif defined _MSC_VER
+#  define UINT64_C(x) x##ui64
+# else
+#  define UINT64_C(x) x##ULL
+# endif
+
+/* 7.18.4.2. Macros for greatest-width integer constants */
+
+# ifndef INTMAX_C
+#  if LONG_MAX >> 30 == 1
+#   define INTMAX_C(x)   x##LL
+#  elif defined GL_INT64_T
+#   define INTMAX_C(x)   INT64_C(x)
+#  else
+#   define INTMAX_C(x)   x##L
+#  endif
+# endif
+
+# ifndef UINTMAX_C
+#  if ULONG_MAX >> 31 == 1
+#   define UINTMAX_C(x)  x##ULL
+#  elif defined GL_UINT64_T
+#   define UINTMAX_C(x)  UINT64_C(x)
+#  else
+#   define UINTMAX_C(x)  x##UL
+#  endif
+# endif
+
+#endif /* !0 */
+
+/* Macros specified by ISO/IEC TS 18661-1:2014.  */
+
+#if (!defined UINTMAX_WIDTH \
+     && (defined _GNU_SOURCE || defined __STDC_WANT_IEC_60559_BFP_EXT__))
+# ifdef INT8_MAX
+#  define INT8_WIDTH _GL_INTEGER_WIDTH (INT8_MIN, INT8_MAX)
+# endif
+# ifdef UINT8_MAX
+#  define UINT8_WIDTH _GL_INTEGER_WIDTH (0, UINT8_MAX)
+# endif
+# ifdef INT16_MAX
+#  define INT16_WIDTH _GL_INTEGER_WIDTH (INT16_MIN, INT16_MAX)
+# endif
+# ifdef UINT16_MAX
+#  define UINT16_WIDTH _GL_INTEGER_WIDTH (0, UINT16_MAX)
+# endif
+# ifdef INT32_MAX
+#  define INT32_WIDTH _GL_INTEGER_WIDTH (INT32_MIN, INT32_MAX)
+# endif
+# ifdef UINT32_MAX
+#  define UINT32_WIDTH _GL_INTEGER_WIDTH (0, UINT32_MAX)
+# endif
+# ifdef INT64_MAX
+#  define INT64_WIDTH _GL_INTEGER_WIDTH (INT64_MIN, INT64_MAX)
+# endif
+# ifdef UINT64_MAX
+#  define UINT64_WIDTH _GL_INTEGER_WIDTH (0, UINT64_MAX)
+# endif
+# define INT_LEAST8_WIDTH _GL_INTEGER_WIDTH (INT_LEAST8_MIN, INT_LEAST8_MAX)
+# define UINT_LEAST8_WIDTH _GL_INTEGER_WIDTH (0, UINT_LEAST8_MAX)
+# define INT_LEAST16_WIDTH _GL_INTEGER_WIDTH (INT_LEAST16_MIN, INT_LEAST16_MAX)
+# define UINT_LEAST16_WIDTH _GL_INTEGER_WIDTH (0, UINT_LEAST16_MAX)
+# define INT_LEAST32_WIDTH _GL_INTEGER_WIDTH (INT_LEAST32_MIN, INT_LEAST32_MAX)
+# define UINT_LEAST32_WIDTH _GL_INTEGER_WIDTH (0, UINT_LEAST32_MAX)
+# define INT_LEAST64_WIDTH _GL_INTEGER_WIDTH (INT_LEAST64_MIN, INT_LEAST64_MAX)
+# define UINT_LEAST64_WIDTH _GL_INTEGER_WIDTH (0, UINT_LEAST64_MAX)
+# define INT_FAST8_WIDTH _GL_INTEGER_WIDTH (INT_FAST8_MIN, INT_FAST8_MAX)
+# define UINT_FAST8_WIDTH _GL_INTEGER_WIDTH (0, UINT_FAST8_MAX)
+# define INT_FAST16_WIDTH _GL_INTEGER_WIDTH (INT_FAST16_MIN, INT_FAST16_MAX)
+# define UINT_FAST16_WIDTH _GL_INTEGER_WIDTH (0, UINT_FAST16_MAX)
+# define INT_FAST32_WIDTH _GL_INTEGER_WIDTH (INT_FAST32_MIN, INT_FAST32_MAX)
+# define UINT_FAST32_WIDTH _GL_INTEGER_WIDTH (0, UINT_FAST32_MAX)
+# define INT_FAST64_WIDTH _GL_INTEGER_WIDTH (INT_FAST64_MIN, INT_FAST64_MAX)
+# define UINT_FAST64_WIDTH _GL_INTEGER_WIDTH (0, UINT_FAST64_MAX)
+# define INTPTR_WIDTH _GL_INTEGER_WIDTH (INTPTR_MIN, INTPTR_MAX)
+# define UINTPTR_WIDTH _GL_INTEGER_WIDTH (0, UINTPTR_MAX)
+# define INTMAX_WIDTH _GL_INTEGER_WIDTH (INTMAX_MIN, INTMAX_MAX)
+# define UINTMAX_WIDTH _GL_INTEGER_WIDTH (0, UINTMAX_MAX)
+# define PTRDIFF_WIDTH _GL_INTEGER_WIDTH (PTRDIFF_MIN, PTRDIFF_MAX)
+# define SIZE_WIDTH _GL_INTEGER_WIDTH (0, SIZE_MAX)
+# define WCHAR_WIDTH _GL_INTEGER_WIDTH (WCHAR_MIN, WCHAR_MAX)
+# ifdef WINT_MAX
+#  define WINT_WIDTH _GL_INTEGER_WIDTH (WINT_MIN, WINT_MAX)
+# endif
+# ifdef SIG_ATOMIC_MAX
+#  define SIG_ATOMIC_WIDTH _GL_INTEGER_WIDTH (SIG_ATOMIC_MIN, SIG_ATOMIC_MAX)
+# endif
+#endif /* !WINT_WIDTH && (_GNU_SOURCE || __STDC_WANT_IEC_60559_BFP_EXT__) */
+
+#endif /* _GL_STDINT_H */
+#endif /* !(defined __ANDROID__ && ...) */
+#endif /* !defined _GL_STDINT_H && !defined _GL_JUST_INCLUDE_SYSTEM_STDINT_H */
diff -Naur ../orig/sed-4.9/lib/stdio.h ./lib/stdio.h
--- ../orig/sed-4.9/lib/stdio.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/stdio.h	2022-12-01 17:13:19.139986300 +0300
@@ -0,0 +1,2218 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A GNU-like <stdio.h>.
+
+   Copyright (C) 2004, 2007-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#if __GNUC__ >= 3
+
+#endif
+
+
+#if defined __need_FILE || defined __need___FILE || defined _GL_ALREADY_INCLUDING_STDIO_H
+/* Special invocation convention:
+   - Inside glibc header files.
+   - On OSF/1 5.1 we have a sequence of nested includes
+     <stdio.h> -> <getopt.h> -> <ctype.h> -> <sys/localedef.h> ->
+     <sys/lc_core.h> -> <nl_types.h> -> <mesg.h> -> <stdio.h>.
+     In this situation, the functions are not yet declared, therefore we cannot
+     provide the C++ aliases.  */
+
+#include ""
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_STDIO_H
+
+#define _GL_ALREADY_INCLUDING_STDIO_H
+
+/* The include_next requires a split double-inclusion guard.  */
+#include "C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\INCLUDE\stdio.h"
+
+#undef _GL_ALREADY_INCLUDING_STDIO_H
+
+#ifndef _GL_STDIO_H
+#define _GL_STDIO_H
+
+/* Get va_list.  Needed on many systems, including glibc 2.8.  */
+#include <stdarg.h>
+
+#include <stddef.h>
+
+/* Get off_t and ssize_t.  Needed on many systems, including glibc 2.8
+   and eglibc 2.11.2.
+   May also define off_t to a 64-bit type on native Windows.  */
+#include <sys/types.h>
+
+/* Solaris 10 and NetBSD 7.0 declare renameat in <unistd.h>, not in <stdio.h>.  */
+/* But in any case avoid namespace pollution on glibc systems.  */
+#if (0 || defined GNULIB_POSIXCHECK) && (defined __sun || defined __NetBSD__) \
+    && ! defined __GLIBC__
+# include <unistd.h>
+#endif
+
+/* Android 4.3 declares renameat in <sys/stat.h>, not in <stdio.h>.  */
+/* But in any case avoid namespace pollution on glibc systems.  */
+#if (0 || defined GNULIB_POSIXCHECK) && defined __ANDROID__ \
+    && ! defined __GLIBC__
+# include <sys/stat.h>
+#endif
+
+/* MSVC declares 'perror' in <stdlib.h>, not in <stdio.h>.  We must include
+   it before we  #define perror rpl_perror.  */
+/* But in any case avoid namespace pollution on glibc systems.  */
+#if (IN_SED_GNULIB_TESTS || defined GNULIB_POSIXCHECK) \
+    && (defined _WIN32 && ! defined __CYGWIN__) \
+    && ! defined __GLIBC__
+# include <stdlib.h>
+#endif
+
+/* MSVC declares 'remove' in <io.h>, not in <stdio.h>.  We must include
+   it before we  #define remove rpl_remove.  */
+/* MSVC declares 'rename' in <io.h>, not in <stdio.h>.  We must include
+   it before we  #define rename rpl_rename.  */
+/* But in any case avoid namespace pollution on glibc systems.  */
+#if (0 || 1 || defined GNULIB_POSIXCHECK) \
+    && (defined _WIN32 && ! defined __CYGWIN__) \
+    && ! defined __GLIBC__
+# include <io.h>
+#endif
+
+
+/* _GL_ATTRIBUTE_DEALLOC (F, I) declares that the function returns pointers
+   that can be freed by passing them as the Ith argument to the
+   function F.  */
+#ifndef _GL_ATTRIBUTE_DEALLOC
+# if __GNUC__ >= 11
+#  define _GL_ATTRIBUTE_DEALLOC(f, i) __attribute__ ((__malloc__ (f, i)))
+# else
+#  define _GL_ATTRIBUTE_DEALLOC(f, i)
+# endif
+#endif
+
+/* The __attribute__ feature is available in gcc versions 2.5 and later.
+   The __-protected variants of the attributes 'format' and 'printf' are
+   accepted by gcc versions 2.6.4 (effectively 2.7) and later.
+   We enable _GL_ATTRIBUTE_FORMAT only if these are supported too, because
+   gnulib and libintl do '#define printf __printf__' when they override
+   the 'printf' function.  */
+#ifndef _GL_ATTRIBUTE_FORMAT
+# if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7) || defined __clang__
+#  define _GL_ATTRIBUTE_FORMAT(spec) __attribute__ ((__format__ spec))
+# else
+#  define _GL_ATTRIBUTE_FORMAT(spec) /* empty */
+# endif
+#endif
+
+/* An __attribute__ __format__ specifier for a function that takes a format
+   string and arguments, where the format string directives are the ones
+   standardized by ISO C99 and POSIX.
+   _GL_ATTRIBUTE_SPEC_PRINTF_STANDARD  */
+/* __gnu_printf__ is supported in GCC >= 4.4.  */
+#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4)
+# define _GL_ATTRIBUTE_SPEC_PRINTF_STANDARD __gnu_printf__
+#else
+# define _GL_ATTRIBUTE_SPEC_PRINTF_STANDARD __printf__
+#endif
+
+/* An __attribute__ __format__ specifier for a function that takes a format
+   string and arguments, where the format string directives are the ones of the
+   system printf(), rather than the ones standardized by ISO C99 and POSIX.
+   _GL_ATTRIBUTE_SPEC_PRINTF_SYSTEM  */
+/* On mingw, Gnulib sets __USE_MINGW_ANSI_STDIO in order to get closer to
+   the standards.  The macro GNULIB_PRINTF_ATTRIBUTE_FLAVOR_GNU indicates
+   whether this change is effective.  On older mingw, it is not.  */
+#if GNULIB_PRINTF_ATTRIBUTE_FLAVOR_GNU
+# define _GL_ATTRIBUTE_SPEC_PRINTF_SYSTEM _GL_ATTRIBUTE_SPEC_PRINTF_STANDARD
+#else
+# define _GL_ATTRIBUTE_SPEC_PRINTF_SYSTEM __printf__
+#endif
+
+/* _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD
+   indicates to GCC that the function takes a format string and arguments,
+   where the format string directives are the ones standardized by ISO C99
+   and POSIX.  */
+#define _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD(formatstring_parameter, first_argument) \
+  _GL_ATTRIBUTE_FORMAT ((_GL_ATTRIBUTE_SPEC_PRINTF_STANDARD, formatstring_parameter, first_argument))
+
+/* _GL_ATTRIBUTE_FORMAT_PRINTF_SYSTEM is like _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD,
+   except that it indicates to GCC that the supported format string directives
+   are the ones of the system printf(), rather than the ones standardized by
+   ISO C99 and POSIX.  */
+#define _GL_ATTRIBUTE_FORMAT_PRINTF_SYSTEM(formatstring_parameter, first_argument) \
+  _GL_ATTRIBUTE_FORMAT ((_GL_ATTRIBUTE_SPEC_PRINTF_SYSTEM, formatstring_parameter, first_argument))
+
+/* _GL_ATTRIBUTE_FORMAT_SCANF
+   indicates to GCC that the function takes a format string and arguments,
+   where the format string directives are the ones standardized by ISO C99
+   and POSIX.  */
+#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4)
+# define _GL_ATTRIBUTE_FORMAT_SCANF(formatstring_parameter, first_argument) \
+   _GL_ATTRIBUTE_FORMAT ((__gnu_scanf__, formatstring_parameter, first_argument))
+#else
+# define _GL_ATTRIBUTE_FORMAT_SCANF(formatstring_parameter, first_argument) \
+   _GL_ATTRIBUTE_FORMAT ((__scanf__, formatstring_parameter, first_argument))
+#endif
+
+/* _GL_ATTRIBUTE_FORMAT_SCANF_SYSTEM is like _GL_ATTRIBUTE_FORMAT_SCANF,
+   except that it indicates to GCC that the supported format string directives
+   are the ones of the system scanf(), rather than the ones standardized by
+   ISO C99 and POSIX.  */
+#define _GL_ATTRIBUTE_FORMAT_SCANF_SYSTEM(formatstring_parameter, first_argument) \
+  _GL_ATTRIBUTE_FORMAT ((__scanf__, formatstring_parameter, first_argument))
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA (func, rettype, parameters);
+   is to be used when func is a Microsoft deprecated alias, on native Windows.
+   It declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to _func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_MDA (open, int, (const char *filename, int flags, ...));
+ */
+#define _GL_CXXALIAS_MDA(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_MDA (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#define _GL_CXXALIAS_MDA_CAST(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_CAST_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || defined __clang__
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype_gcc, rettype_clang, parameters_and_attributes, "message")
+   is like _GL_WARN_ON_USE (function, "message"), except that in C++ mode the
+   function is declared with the given prototype, consisting of return type,
+   parameters, and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if !defined __cplusplus
+#  define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+     _GL_WARN_ON_USE (function, msg)
+# else
+#  if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes \
+  __attribute__ ((__warning__ (msg)))
+#  elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_clang function parameters_and_attributes \
+  __attribute__ ((__diagnose_if__ (1, msg, "warning")))
+#  elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes
+#  else /* Unsupported.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  endif
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+/* Macros for stringification.  */
+#define _GL_STDIO_STRINGIZE(token) #token
+#define _GL_STDIO_MACROEXPAND_AND_STRINGIZE(token) _GL_STDIO_STRINGIZE(token)
+
+/* When also using extern inline, suppress the use of static inline in
+   standard headers of problematic Apple configurations, as Libc at
+   least through Libc-825.26 (2013-04-09) mishandles it; see, e.g.,
+   <https://lists.gnu.org/r/bug-gnulib/2012-12/msg00023.html>.
+   Perhaps Apple will fix this some day.  */
+#if (defined _GL_EXTERN_INLINE_IN_USE && defined __APPLE__ \
+     && defined __GNUC__ && defined __STDC__)
+# undef putc_unlocked
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define dprintf rpl_dprintf
+#  endif
+_GL_FUNCDECL_RPL (dprintf, int, (int fd, const char *restrict format, ...)
+                                _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (2, 3)
+                                _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (dprintf, int, (int fd, const char *restrict format, ...));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (dprintf, int, (int fd, const char *restrict format, ...)
+                                _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (2, 3)
+                                _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (dprintf, int, (int fd, const char *restrict format, ...));
+# endif
+_GL_CXXALIASWARN (dprintf);
+#elif defined GNULIB_POSIXCHECK
+# undef dprintf
+# if HAVE_RAW_DECL_DPRINTF
+_GL_WARN_ON_USE (dprintf, "dprintf is unportable - "
+                 "use gnulib module dprintf for portability");
+# endif
+#endif
+
+#if 0
+/* Close STREAM and its underlying file descriptor.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define fclose rpl_fclose
+#  endif
+_GL_FUNCDECL_RPL (fclose, int, (FILE *stream) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (fclose, int, (FILE *stream));
+# else
+_GL_CXXALIAS_SYS (fclose, int, (FILE *stream));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (fclose);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef fclose
+/* Assume fclose is always declared.  */
+_GL_WARN_ON_USE (fclose, "fclose is not always POSIX compliant - "
+                 "use gnulib module fclose for portable POSIX compliance");
+#endif
+
+#if 1
+/* On native Windows, map 'fcloseall' to '_fcloseall', so that -loldnames is
+   not required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::fcloseall on all platforms that have
+   it.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fcloseall
+#   define fcloseall _fcloseall
+#  endif
+_GL_CXXALIAS_MDA (fcloseall, int, (void));
+# else
+#  if 1
+#   if defined __FreeBSD__ || defined __DragonFly__
+_GL_CXXALIAS_SYS (fcloseall, void, (void));
+#   else
+_GL_CXXALIAS_SYS (fcloseall, int, (void));
+#   endif
+#  endif
+# endif
+# if (defined _WIN32 && !defined __CYGWIN__) || 1
+_GL_CXXALIASWARN (fcloseall);
+# endif
+#endif
+
+#if IN_SED_GNULIB_TESTS
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fdopen
+#   define fdopen rpl_fdopen
+#  endif
+_GL_FUNCDECL_RPL (fdopen, FILE *,
+                  (int fd, const char *mode)
+                  _GL_ARG_NONNULL ((2)) _GL_ATTRIBUTE_DEALLOC (fclose, 1));
+_GL_CXXALIAS_RPL (fdopen, FILE *, (int fd, const char *mode));
+# elif defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fdopen
+#   define fdopen _fdopen
+#  endif
+_GL_CXXALIAS_MDA (fdopen, FILE *, (int fd, const char *mode));
+# else
+#  if __GNUC__ >= 11
+/* For -Wmismatched-dealloc: Associate fdopen with fclose or rpl_fclose.  */
+_GL_FUNCDECL_SYS (fdopen, FILE *,
+                  (int fd, const char *mode)
+                  _GL_ARG_NONNULL ((2)) _GL_ATTRIBUTE_DEALLOC (fclose, 1));
+#  endif
+_GL_CXXALIAS_SYS (fdopen, FILE *, (int fd, const char *mode));
+# endif
+_GL_CXXALIASWARN (fdopen);
+#else
+# if 0 && __GNUC__ >= 11 && !defined fdopen
+/* For -Wmismatched-dealloc: Associate fdopen with fclose or rpl_fclose.  */
+_GL_FUNCDECL_SYS (fdopen, FILE *,
+                  (int fd, const char *mode)
+                  _GL_ARG_NONNULL ((2)) _GL_ATTRIBUTE_DEALLOC (fclose, 1));
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef fdopen
+/* Assume fdopen is always declared.  */
+_GL_WARN_ON_USE (fdopen, "fdopen on native Windows platforms is not POSIX compliant - "
+                 "use gnulib module fdopen for portability");
+# elif 1
+/* On native Windows, map 'fdopen' to '_fdopen', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::fdopen always.  */
+#  if defined _WIN32 && !defined __CYGWIN__
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef fdopen
+#    define fdopen _fdopen
+#   endif
+_GL_CXXALIAS_MDA (fdopen, FILE *, (int fd, const char *mode));
+#  else
+_GL_CXXALIAS_SYS (fdopen, FILE *, (int fd, const char *mode));
+#  endif
+_GL_CXXALIASWARN (fdopen);
+# endif
+#endif
+
+#if IN_SED_GNULIB_TESTS
+/* Flush all pending data on STREAM according to POSIX rules.  Both
+   output and seekable input streams are supported.
+   Note! LOSS OF DATA can occur if fflush is applied on an input stream
+   that is _not_seekable_ or on an update stream that is _not_seekable_
+   and in which the most recent operation was input.  Seekability can
+   be tested with lseek(fileno(fp),0,SEEK_CUR).  */
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define fflush rpl_fflush
+#  endif
+_GL_FUNCDECL_RPL (fflush, int, (FILE *gl_stream));
+_GL_CXXALIAS_RPL (fflush, int, (FILE *gl_stream));
+# else
+_GL_CXXALIAS_SYS (fflush, int, (FILE *gl_stream));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (fflush);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef fflush
+/* Assume fflush is always declared.  */
+_GL_WARN_ON_USE (fflush, "fflush is not always POSIX compliant - "
+                 "use gnulib module fflush for portable POSIX compliance");
+#endif
+
+#if 1
+# if 0 && 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fgetc
+#   define fgetc rpl_fgetc
+#  endif
+_GL_FUNCDECL_RPL (fgetc, int, (FILE *stream) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (fgetc, int, (FILE *stream));
+# else
+_GL_CXXALIAS_SYS (fgetc, int, (FILE *stream));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (fgetc);
+# endif
+#endif
+
+#if 1
+# if 0 && 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fgets
+#   define fgets rpl_fgets
+#  endif
+_GL_FUNCDECL_RPL (fgets, char *,
+                  (char *restrict s, int n, FILE *restrict stream)
+                  _GL_ARG_NONNULL ((1, 3)));
+_GL_CXXALIAS_RPL (fgets, char *,
+                  (char *restrict s, int n, FILE *restrict stream));
+# else
+_GL_CXXALIAS_SYS (fgets, char *,
+                  (char *restrict s, int n, FILE *restrict stream));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (fgets);
+# endif
+#endif
+
+#if 1
+/* On native Windows, map 'fileno' to '_fileno', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::fileno always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fileno
+#   define fileno _fileno
+#  endif
+_GL_CXXALIAS_MDA (fileno, int, (FILE *restrict stream));
+# else
+_GL_CXXALIAS_SYS (fileno, int, (FILE *restrict stream));
+# endif
+_GL_CXXALIASWARN (fileno);
+#endif
+
+#if IN_SED_GNULIB_TESTS
+# if (IN_SED_GNULIB_TESTS && 0) \
+     || (IN_SED_GNULIB_TESTS && 1)
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fopen
+#   define fopen rpl_fopen
+#  endif
+_GL_FUNCDECL_RPL (fopen, FILE *,
+                  (const char *restrict filename, const char *restrict mode)
+                  _GL_ARG_NONNULL ((1, 2)) _GL_ATTRIBUTE_DEALLOC (fclose, 1));
+_GL_CXXALIAS_RPL (fopen, FILE *,
+                  (const char *restrict filename, const char *restrict mode));
+# else
+#  if __GNUC__ >= 11
+/* For -Wmismatched-dealloc: Associate fopen with fclose or rpl_fclose.  */
+_GL_FUNCDECL_SYS (fopen, FILE *,
+                  (const char *restrict filename, const char *restrict mode)
+                  _GL_ARG_NONNULL ((1, 2)) _GL_ATTRIBUTE_DEALLOC (fclose, 1));
+#  endif
+_GL_CXXALIAS_SYS (fopen, FILE *,
+                  (const char *restrict filename, const char *restrict mode));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (fopen);
+# endif
+#else
+# if 0 && __GNUC__ >= 11 && !defined fopen
+/* For -Wmismatched-dealloc: Associate fopen with fclose or rpl_fclose.  */
+_GL_FUNCDECL_SYS (fopen, FILE *,
+                  (const char *restrict filename, const char *restrict mode)
+                  _GL_ARG_NONNULL ((1, 2)) _GL_ATTRIBUTE_DEALLOC (fclose, 1));
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef fopen
+/* Assume fopen is always declared.  */
+_GL_WARN_ON_USE (fopen, "fopen on native Windows platforms is not POSIX compliant - "
+                 "use gnulib module fopen for portability");
+# endif
+#endif
+
+#if 0 || 1
+# if (0 && 0) \
+     || (1 && 0 && (0 || 0))
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define fprintf rpl_fprintf
+#  endif
+#  define GNULIB_overrides_fprintf 1
+#  if 0 || 0
+_GL_FUNCDECL_RPL (fprintf, int,
+                  (FILE *restrict fp, const char *restrict format, ...)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (2, 3)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  else
+_GL_FUNCDECL_RPL (fprintf, int,
+                  (FILE *restrict fp, const char *restrict format, ...)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF_SYSTEM (2, 3)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_RPL (fprintf, int,
+                  (FILE *restrict fp, const char *restrict format, ...));
+# else
+_GL_CXXALIAS_SYS (fprintf, int,
+                  (FILE *restrict fp, const char *restrict format, ...));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (fprintf);
+# endif
+#endif
+#if !0 && defined GNULIB_POSIXCHECK
+# if !GNULIB_overrides_fprintf
+#  undef fprintf
+# endif
+/* Assume fprintf is always declared.  */
+_GL_WARN_ON_USE (fprintf, "fprintf is not always POSIX compliant - "
+                 "use gnulib module fprintf-posix for portable "
+                 "POSIX compliance");
+#endif
+
+#if IN_SED_GNULIB_TESTS
+/* Discard all pending buffered I/O data on STREAM.
+   STREAM must not be wide-character oriented.
+   When discarding pending output, the file position is set back to where it
+   was before the write calls.  When discarding pending input, the file
+   position is advanced to match the end of the previously read input.
+   Return 0 if successful.  Upon error, return -1 and set errno.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define fpurge rpl_fpurge
+#  endif
+_GL_FUNCDECL_RPL (fpurge, int, (FILE *gl_stream) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (fpurge, int, (FILE *gl_stream));
+# else
+#  if !0
+_GL_FUNCDECL_SYS (fpurge, int, (FILE *gl_stream) _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (fpurge, int, (FILE *gl_stream));
+# endif
+_GL_CXXALIASWARN (fpurge);
+#elif defined GNULIB_POSIXCHECK
+# undef fpurge
+# if HAVE_RAW_DECL_FPURGE
+_GL_WARN_ON_USE (fpurge, "fpurge is not always present - "
+                 "use gnulib module fpurge for portability");
+# endif
+#endif
+
+#if 1
+# if 0 && (0 || 0)
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fputc
+#   define fputc rpl_fputc
+#  endif
+_GL_FUNCDECL_RPL (fputc, int, (int c, FILE *stream) _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (fputc, int, (int c, FILE *stream));
+# else
+_GL_CXXALIAS_SYS (fputc, int, (int c, FILE *stream));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (fputc);
+# endif
+#endif
+
+#if 1
+# if 0 && (0 || 0)
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fputs
+#   define fputs rpl_fputs
+#  endif
+_GL_FUNCDECL_RPL (fputs, int,
+                  (const char *restrict string, FILE *restrict stream)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (fputs, int,
+                  (const char *restrict string, FILE *restrict stream));
+# else
+_GL_CXXALIAS_SYS (fputs, int,
+                  (const char *restrict string, FILE *restrict stream));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (fputs);
+# endif
+#endif
+
+#if 1
+# if 0 && 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fread
+#   define fread rpl_fread
+#  endif
+_GL_FUNCDECL_RPL (fread, size_t,
+                  (void *restrict ptr, size_t s, size_t n,
+                   FILE *restrict stream)
+                  _GL_ARG_NONNULL ((4)));
+_GL_CXXALIAS_RPL (fread, size_t,
+                  (void *restrict ptr, size_t s, size_t n,
+                   FILE *restrict stream));
+# else
+_GL_CXXALIAS_SYS (fread, size_t,
+                  (void *restrict ptr, size_t s, size_t n,
+                   FILE *restrict stream));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (fread);
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef freopen
+#   define freopen rpl_freopen
+#  endif
+_GL_FUNCDECL_RPL (freopen, FILE *,
+                  (const char *restrict filename, const char *restrict mode,
+                   FILE *restrict stream)
+                  _GL_ARG_NONNULL ((2, 3)));
+_GL_CXXALIAS_RPL (freopen, FILE *,
+                  (const char *restrict filename, const char *restrict mode,
+                   FILE *restrict stream));
+# else
+_GL_CXXALIAS_SYS (freopen, FILE *,
+                  (const char *restrict filename, const char *restrict mode,
+                   FILE *restrict stream));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (freopen);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef freopen
+/* Assume freopen is always declared.  */
+_GL_WARN_ON_USE (freopen,
+                 "freopen on native Windows platforms is not POSIX compliant - "
+                 "use gnulib module freopen for portability");
+#endif
+
+#if 1
+# if 0 && 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fscanf
+#   define fscanf rpl_fscanf
+#  endif
+_GL_FUNCDECL_RPL (fscanf, int,
+                  (FILE *restrict stream, const char *restrict format, ...)
+                  _GL_ATTRIBUTE_FORMAT_SCANF_SYSTEM (2, 3)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (fscanf, int,
+                  (FILE *restrict stream, const char *restrict format, ...));
+# else
+_GL_CXXALIAS_SYS (fscanf, int,
+                  (FILE *restrict stream, const char *restrict format, ...));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (fscanf);
+# endif
+#endif
+
+
+/* Set up the following warnings, based on which modules are in use.
+   GNU Coding Standards discourage the use of fseek, since it imposes
+   an arbitrary limitation on some 32-bit hosts.  Remember that the
+   fseek module depends on the fseeko module, so we only have three
+   cases to consider:
+
+   1. The developer is not using either module.  Issue a warning under
+   GNULIB_POSIXCHECK for both functions, to remind them that both
+   functions have bugs on some systems.  _GL_NO_LARGE_FILES has no
+   impact on this warning.
+
+   2. The developer is using both modules.  They may be unaware of the
+   arbitrary limitations of fseek, so issue a warning under
+   GNULIB_POSIXCHECK.  On the other hand, they may be using both
+   modules intentionally, so the developer can define
+   _GL_NO_LARGE_FILES in the compilation units where the use of fseek
+   is safe, to silence the warning.
+
+   3. The developer is using the fseeko module, but not fseek.  Gnulib
+   guarantees that fseek will still work around platform bugs in that
+   case, but we presume that the developer is aware of the pitfalls of
+   fseek and was trying to avoid it, so issue a warning even when
+   GNULIB_POSIXCHECK is undefined.  Again, _GL_NO_LARGE_FILES can be
+   defined to silence the warning in particular compilation units.
+   In C++ compilations with GNULIB_NAMESPACE, in order to avoid that
+   fseek gets defined as a macro, it is recommended that the developer
+   uses the fseek module, even if he is not calling the fseek function.
+
+   Most gnulib clients that perform stream operations should fall into
+   category 3.  */
+
+#if IN_SED_GNULIB_TESTS
+# if defined GNULIB_POSIXCHECK && !defined _GL_NO_LARGE_FILES
+#  define _GL_FSEEK_WARN /* Category 2, above.  */
+#  undef fseek
+# endif
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fseek
+#   define fseek rpl_fseek
+#  endif
+_GL_FUNCDECL_RPL (fseek, int, (FILE *fp, long offset, int whence)
+                              _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (fseek, int, (FILE *fp, long offset, int whence));
+# else
+_GL_CXXALIAS_SYS (fseek, int, (FILE *fp, long offset, int whence));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (fseek);
+# endif
+#endif
+
+#if IN_SED_GNULIB_TESTS
+# if !IN_SED_GNULIB_TESTS && !defined _GL_NO_LARGE_FILES
+#  define _GL_FSEEK_WARN /* Category 3, above.  */
+#  undef fseek
+# endif
+# if 0
+/* Provide an fseeko function that is aware of a preceding fflush(), and which
+   detects pipes.  */
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fseeko
+#   define fseeko rpl_fseeko
+#  endif
+_GL_FUNCDECL_RPL (fseeko, int, (FILE *fp, off_t offset, int whence)
+                               _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (fseeko, int, (FILE *fp, off_t offset, int whence));
+# else
+#  if ! 0
+_GL_FUNCDECL_SYS (fseeko, int, (FILE *fp, off_t offset, int whence)
+                               _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (fseeko, int, (FILE *fp, off_t offset, int whence));
+# endif
+_GL_CXXALIASWARN (fseeko);
+#elif defined GNULIB_POSIXCHECK
+# define _GL_FSEEK_WARN /* Category 1, above.  */
+# undef fseek
+# undef fseeko
+# if HAVE_RAW_DECL_FSEEKO
+_GL_WARN_ON_USE (fseeko, "fseeko is unportable - "
+                 "use gnulib module fseeko for portability");
+# endif
+#endif
+
+#ifdef _GL_FSEEK_WARN
+# undef _GL_FSEEK_WARN
+/* Here, either fseek is undefined (but C89 guarantees that it is
+   declared), or it is defined as rpl_fseek (declared above).  */
+_GL_WARN_ON_USE (fseek, "fseek cannot handle files larger than 4 GB "
+                 "on 32-bit platforms - "
+                 "use fseeko function for handling of large files");
+#endif
+
+
+/* ftell, ftello.  See the comments on fseek/fseeko.  */
+
+#if IN_SED_GNULIB_TESTS
+# if defined GNULIB_POSIXCHECK && !defined _GL_NO_LARGE_FILES
+#  define _GL_FTELL_WARN /* Category 2, above.  */
+#  undef ftell
+# endif
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef ftell
+#   define ftell rpl_ftell
+#  endif
+_GL_FUNCDECL_RPL (ftell, long, (FILE *fp) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (ftell, long, (FILE *fp));
+# else
+_GL_CXXALIAS_SYS (ftell, long, (FILE *fp));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (ftell);
+# endif
+#endif
+
+#if IN_SED_GNULIB_TESTS
+# if !IN_SED_GNULIB_TESTS && !defined _GL_NO_LARGE_FILES
+#  define _GL_FTELL_WARN /* Category 3, above.  */
+#  undef ftell
+# endif
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef ftello
+#   define ftello rpl_ftello
+#  endif
+_GL_FUNCDECL_RPL (ftello, off_t, (FILE *fp) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (ftello, off_t, (FILE *fp));
+# else
+#  if ! 0
+_GL_FUNCDECL_SYS (ftello, off_t, (FILE *fp) _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (ftello, off_t, (FILE *fp));
+# endif
+_GL_CXXALIASWARN (ftello);
+#elif defined GNULIB_POSIXCHECK
+# define _GL_FTELL_WARN /* Category 1, above.  */
+# undef ftell
+# undef ftello
+# if HAVE_RAW_DECL_FTELLO
+_GL_WARN_ON_USE (ftello, "ftello is unportable - "
+                 "use gnulib module ftello for portability");
+# endif
+#endif
+
+#ifdef _GL_FTELL_WARN
+# undef _GL_FTELL_WARN
+/* Here, either ftell is undefined (but C89 guarantees that it is
+   declared), or it is defined as rpl_ftell (declared above).  */
+_GL_WARN_ON_USE (ftell, "ftell cannot handle files larger than 4 GB "
+                 "on 32-bit platforms - "
+                 "use ftello function for handling of large files");
+#endif
+
+
+#if 1
+# if 0 && (0 || 0)
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fwrite
+#   define fwrite rpl_fwrite
+#  endif
+_GL_FUNCDECL_RPL (fwrite, size_t,
+                  (const void *restrict ptr, size_t s, size_t n,
+                   FILE *restrict stream)
+                  _GL_ARG_NONNULL ((1, 4)));
+_GL_CXXALIAS_RPL (fwrite, size_t,
+                  (const void *restrict ptr, size_t s, size_t n,
+                   FILE *restrict stream));
+# else
+_GL_CXXALIAS_SYS (fwrite, size_t,
+                  (const void *restrict ptr, size_t s, size_t n,
+                   FILE *restrict stream));
+
+/* Work around bug 11959 when fortifying glibc 2.4 through 2.15
+   <https://sourceware.org/bugzilla/show_bug.cgi?id=11959>,
+   which sometimes causes an unwanted diagnostic for fwrite calls.
+   This affects only function declaration attributes under certain
+   versions of gcc and clang, and is not needed for C++.  */
+#  if (0 < __USE_FORTIFY_LEVEL                                          \
+       && __GLIBC__ == 2 && 4 <= __GLIBC_MINOR__ && __GLIBC_MINOR__ <= 15 \
+       && 3 < __GNUC__ + (4 <= __GNUC_MINOR__)                          \
+       && !defined __cplusplus)
+#   undef fwrite
+#   undef fwrite_unlocked
+extern size_t __REDIRECT (rpl_fwrite,
+                          (const void *__restrict, size_t, size_t,
+                           FILE *__restrict),
+                          fwrite);
+extern size_t __REDIRECT (rpl_fwrite_unlocked,
+                          (const void *__restrict, size_t, size_t,
+                           FILE *__restrict),
+                          fwrite_unlocked);
+#   define fwrite rpl_fwrite
+#   define fwrite_unlocked rpl_fwrite_unlocked
+#  endif
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (fwrite);
+# endif
+#endif
+
+#if 1
+# if 0 && 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getc
+#   define getc rpl_fgetc
+#  endif
+_GL_FUNCDECL_RPL (fgetc, int, (FILE *stream) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL_1 (getc, rpl_fgetc, int, (FILE *stream));
+# else
+_GL_CXXALIAS_SYS (getc, int, (FILE *stream));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (getc);
+# endif
+#endif
+
+#if 1
+# if 0 && 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getchar
+#   define getchar rpl_getchar
+#  endif
+_GL_FUNCDECL_RPL (getchar, int, (void));
+_GL_CXXALIAS_RPL (getchar, int, (void));
+# else
+_GL_CXXALIAS_SYS (getchar, int, (void));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (getchar);
+# endif
+#endif
+
+#if 1
+/* Read input, up to (and including) the next occurrence of DELIMITER, from
+   STREAM, store it in *LINEPTR (and NUL-terminate it).
+   *LINEPTR is a pointer returned from malloc (or NULL), pointing to *LINESIZE
+   bytes of space.  It is realloc'd as necessary.
+   Return the number of bytes read and stored at *LINEPTR (not including the
+   NUL terminator), or -1 on error or EOF.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getdelim
+#   define getdelim rpl_getdelim
+#  endif
+_GL_FUNCDECL_RPL (getdelim, ssize_t,
+                  (char **restrict lineptr, size_t *restrict linesize,
+                   int delimiter,
+                   FILE *restrict stream)
+                  _GL_ARG_NONNULL ((1, 2, 4)));
+_GL_CXXALIAS_RPL (getdelim, ssize_t,
+                  (char **restrict lineptr, size_t *restrict linesize,
+                   int delimiter,
+                   FILE *restrict stream));
+# else
+#  if !0
+_GL_FUNCDECL_SYS (getdelim, ssize_t,
+                  (char **restrict lineptr, size_t *restrict linesize,
+                   int delimiter,
+                   FILE *restrict stream)
+                  _GL_ARG_NONNULL ((1, 2, 4)));
+#  endif
+_GL_CXXALIAS_SYS (getdelim, ssize_t,
+                  (char **restrict lineptr, size_t *restrict linesize,
+                   int delimiter,
+                   FILE *restrict stream));
+# endif
+_GL_CXXALIASWARN (getdelim);
+#elif defined GNULIB_POSIXCHECK
+# undef getdelim
+# if HAVE_RAW_DECL_GETDELIM
+_GL_WARN_ON_USE (getdelim, "getdelim is unportable - "
+                 "use gnulib module getdelim for portability");
+# endif
+#endif
+
+#if 0
+/* Read a line, up to (and including) the next newline, from STREAM, store it
+   in *LINEPTR (and NUL-terminate it).
+   *LINEPTR is a pointer returned from malloc (or NULL), pointing to *LINESIZE
+   bytes of space.  It is realloc'd as necessary.
+   Return the number of bytes read and stored at *LINEPTR (not including the
+   NUL terminator), or -1 on error or EOF.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getline
+#   define getline rpl_getline
+#  endif
+_GL_FUNCDECL_RPL (getline, ssize_t,
+                  (char **restrict lineptr, size_t *restrict linesize,
+                   FILE *restrict stream)
+                  _GL_ARG_NONNULL ((1, 2, 3)));
+_GL_CXXALIAS_RPL (getline, ssize_t,
+                  (char **restrict lineptr, size_t *restrict linesize,
+                   FILE *restrict stream));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (getline, ssize_t,
+                  (char **restrict lineptr, size_t *restrict linesize,
+                   FILE *restrict stream)
+                  _GL_ARG_NONNULL ((1, 2, 3)));
+#  endif
+_GL_CXXALIAS_SYS (getline, ssize_t,
+                  (char **restrict lineptr, size_t *restrict linesize,
+                   FILE *restrict stream));
+# endif
+# if 1
+_GL_CXXALIASWARN (getline);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef getline
+# if HAVE_RAW_DECL_GETLINE
+_GL_WARN_ON_USE (getline, "getline is unportable - "
+                 "use gnulib module getline for portability");
+# endif
+#endif
+
+/* It is very rare that the developer ever has full control of stdin,
+   so any use of gets warrants an unconditional warning; besides, C11
+   removed it.  */
+#undef gets
+#if HAVE_RAW_DECL_GETS && !defined __cplusplus
+_GL_WARN_ON_USE (gets, "gets is a security hole - use fgets instead");
+#endif
+
+#if 1
+/* On native Windows, map 'getw' to '_getw', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::getw always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getw
+#   define getw _getw
+#  endif
+_GL_CXXALIAS_MDA (getw, int, (FILE *restrict stream));
+# else
+_GL_CXXALIAS_SYS (getw, int, (FILE *restrict stream));
+# endif
+_GL_CXXALIASWARN (getw);
+#endif
+
+#if 0 || 0
+struct obstack;
+/* Grow an obstack with formatted output.  Return the number of
+   bytes added to OBS.  No trailing nul byte is added, and the
+   object should be closed with obstack_finish before use.  Upon
+   memory allocation error, call obstack_alloc_failed_handler.  Upon
+   other error, return -1.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define obstack_printf rpl_obstack_printf
+#  endif
+_GL_FUNCDECL_RPL (obstack_printf, int,
+                  (struct obstack *obs, const char *format, ...)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (2, 3)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (obstack_printf, int,
+                  (struct obstack *obs, const char *format, ...));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (obstack_printf, int,
+                  (struct obstack *obs, const char *format, ...)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (2, 3)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (obstack_printf, int,
+                  (struct obstack *obs, const char *format, ...));
+# endif
+_GL_CXXALIASWARN (obstack_printf);
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define obstack_vprintf rpl_obstack_vprintf
+#  endif
+_GL_FUNCDECL_RPL (obstack_vprintf, int,
+                  (struct obstack *obs, const char *format, va_list args)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (2, 0)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (obstack_vprintf, int,
+                  (struct obstack *obs, const char *format, va_list args));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (obstack_vprintf, int,
+                  (struct obstack *obs, const char *format, va_list args)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (2, 0)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (obstack_vprintf, int,
+                  (struct obstack *obs, const char *format, va_list args));
+# endif
+_GL_CXXALIASWARN (obstack_vprintf);
+#endif
+
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (pclose, int, (FILE *stream) _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (pclose, int, (FILE *stream));
+_GL_CXXALIASWARN (pclose);
+#elif defined GNULIB_POSIXCHECK
+# undef pclose
+# if HAVE_RAW_DECL_PCLOSE
+_GL_WARN_ON_USE (pclose, "pclose is unportable - "
+                 "use gnulib module pclose for more portability");
+# endif
+#endif
+
+#if IN_SED_GNULIB_TESTS
+/* Print a message to standard error, describing the value of ERRNO,
+   (if STRING is not NULL and not empty) prefixed with STRING and ": ",
+   and terminated with a newline.  */
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define perror rpl_perror
+#  endif
+_GL_FUNCDECL_RPL (perror, void, (const char *string));
+_GL_CXXALIAS_RPL (perror, void, (const char *string));
+# else
+_GL_CXXALIAS_SYS (perror, void, (const char *string));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (perror);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef perror
+/* Assume perror is always declared.  */
+_GL_WARN_ON_USE (perror, "perror is not always POSIX compliant - "
+                 "use gnulib module perror for portability");
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef popen
+#   define popen rpl_popen
+#  endif
+_GL_FUNCDECL_RPL (popen, FILE *,
+                  (const char *cmd, const char *mode)
+                  _GL_ARG_NONNULL ((1, 2)) _GL_ATTRIBUTE_DEALLOC (pclose, 1));
+_GL_CXXALIAS_RPL (popen, FILE *, (const char *cmd, const char *mode));
+# else
+#  if !1 || __GNUC__ >= 11
+_GL_FUNCDECL_SYS (popen, FILE *,
+                  (const char *cmd, const char *mode)
+                  _GL_ARG_NONNULL ((1, 2)) _GL_ATTRIBUTE_DEALLOC (pclose, 1));
+#  endif
+_GL_CXXALIAS_SYS (popen, FILE *, (const char *cmd, const char *mode));
+# endif
+_GL_CXXALIASWARN (popen);
+#else
+# if 0 && __GNUC__ >= 11 && !defined popen
+/* For -Wmismatched-dealloc: Associate popen with pclose or rpl_pclose.  */
+_GL_FUNCDECL_SYS (popen, FILE *,
+                  (const char *cmd, const char *mode)
+                  _GL_ARG_NONNULL ((1, 2)) _GL_ATTRIBUTE_DEALLOC (pclose, 1));
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef popen
+#  if HAVE_RAW_DECL_POPEN
+_GL_WARN_ON_USE (popen, "popen is buggy on some platforms - "
+                 "use gnulib module popen or pipe for more portability");
+#  endif
+# endif
+#endif
+
+#if 0 || 1
+# if (0 && 0) \
+     || (1 && 0 && (0 || 0))
+#  if defined __GNUC__ || defined __clang__
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+/* Don't break __attribute__((format(printf,M,N))).  */
+#    define printf __printf__
+#   endif
+#   if 0 || 0
+_GL_FUNCDECL_RPL_1 (__printf__, int,
+                    (const char *restrict format, ...)
+                    __asm__ (
+                             _GL_STDIO_MACROEXPAND_AND_STRINGIZE(rpl_printf))
+                    _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (1, 2)
+                    _GL_ARG_NONNULL ((1)));
+#   else
+_GL_FUNCDECL_RPL_1 (__printf__, int,
+                    (const char *restrict format, ...)
+                    __asm__ (
+                             _GL_STDIO_MACROEXPAND_AND_STRINGIZE(rpl_printf))
+                    _GL_ATTRIBUTE_FORMAT_PRINTF_SYSTEM (1, 2)
+                    _GL_ARG_NONNULL ((1)));
+#   endif
+_GL_CXXALIAS_RPL_1 (printf, __printf__, int, (const char *format, ...));
+#  else
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    define printf rpl_printf
+#   endif
+_GL_FUNCDECL_RPL (printf, int,
+                  (const char *restrict format, ...)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (1, 2)
+                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (printf, int, (const char *restrict format, ...));
+#  endif
+#  define GNULIB_overrides_printf 1
+# else
+_GL_CXXALIAS_SYS (printf, int, (const char *restrict format, ...));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (printf);
+# endif
+#endif
+#if !0 && defined GNULIB_POSIXCHECK
+# if !GNULIB_overrides_printf
+#  undef printf
+# endif
+/* Assume printf is always declared.  */
+_GL_WARN_ON_USE (printf, "printf is not always POSIX compliant - "
+                 "use gnulib module printf-posix for portable "
+                 "POSIX compliance");
+#endif
+
+#if 1
+# if 0 && (0 || 0)
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef putc
+#   define putc rpl_fputc
+#  endif
+_GL_FUNCDECL_RPL (fputc, int, (int c, FILE *stream) _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL_1 (putc, rpl_fputc, int, (int c, FILE *stream));
+# else
+_GL_CXXALIAS_SYS (putc, int, (int c, FILE *stream));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (putc);
+# endif
+#endif
+
+#if 1
+# if 0 && (0 || 0)
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef putchar
+#   define putchar rpl_putchar
+#  endif
+_GL_FUNCDECL_RPL (putchar, int, (int c));
+_GL_CXXALIAS_RPL (putchar, int, (int c));
+# else
+_GL_CXXALIAS_SYS (putchar, int, (int c));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (putchar);
+# endif
+#endif
+
+#if 1
+# if 0 && (0 || 0)
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef puts
+#   define puts rpl_puts
+#  endif
+_GL_FUNCDECL_RPL (puts, int, (const char *string) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (puts, int, (const char *string));
+# else
+_GL_CXXALIAS_SYS (puts, int, (const char *string));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (puts);
+# endif
+#endif
+
+#if 1
+/* On native Windows, map 'putw' to '_putw', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::putw always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef putw
+#   define putw _putw
+#  endif
+_GL_CXXALIAS_MDA (putw, int, (int w, FILE *restrict stream));
+# else
+_GL_CXXALIAS_SYS (putw, int, (int w, FILE *restrict stream));
+# endif
+_GL_CXXALIASWARN (putw);
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef remove
+#   define remove rpl_remove
+#  endif
+_GL_FUNCDECL_RPL (remove, int, (const char *name) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (remove, int, (const char *name));
+# else
+_GL_CXXALIAS_SYS (remove, int, (const char *name));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (remove);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef remove
+/* Assume remove is always declared.  */
+_GL_WARN_ON_USE (remove, "remove cannot handle directories on some platforms - "
+                 "use gnulib module remove for more portability");
+#endif
+
+#if 1
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef rename
+#   define rename rpl_rename
+#  endif
+_GL_FUNCDECL_RPL (rename, int,
+                  (const char *old_filename, const char *new_filename)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (rename, int,
+                  (const char *old_filename, const char *new_filename));
+# else
+_GL_CXXALIAS_SYS (rename, int,
+                  (const char *old_filename, const char *new_filename));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (rename);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef rename
+/* Assume rename is always declared.  */
+_GL_WARN_ON_USE (rename, "rename is buggy on some platforms - "
+                 "use gnulib module rename for more portability");
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef renameat
+#   define renameat rpl_renameat
+#  endif
+_GL_FUNCDECL_RPL (renameat, int,
+                  (int fd1, char const *file1, int fd2, char const *file2)
+                  _GL_ARG_NONNULL ((2, 4)));
+_GL_CXXALIAS_RPL (renameat, int,
+                  (int fd1, char const *file1, int fd2, char const *file2));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (renameat, int,
+                  (int fd1, char const *file1, int fd2, char const *file2)
+                  _GL_ARG_NONNULL ((2, 4)));
+#  endif
+_GL_CXXALIAS_SYS (renameat, int,
+                  (int fd1, char const *file1, int fd2, char const *file2));
+# endif
+_GL_CXXALIASWARN (renameat);
+#elif defined GNULIB_POSIXCHECK
+# undef renameat
+# if HAVE_RAW_DECL_RENAMEAT
+_GL_WARN_ON_USE (renameat, "renameat is not portable - "
+                 "use gnulib module renameat for portability");
+# endif
+#endif
+
+#if 1
+# if 0 && 0
+#  if defined __GNUC__ || defined __clang__
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef scanf
+/* Don't break __attribute__((format(scanf,M,N))).  */
+#    define scanf __scanf__
+#   endif
+_GL_FUNCDECL_RPL_1 (__scanf__, int,
+                    (const char *restrict format, ...)
+                    __asm__ (
+                             _GL_STDIO_MACROEXPAND_AND_STRINGIZE(rpl_scanf))
+                    _GL_ATTRIBUTE_FORMAT_SCANF_SYSTEM (1, 2)
+                    _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL_1 (scanf, __scanf__, int, (const char *restrict format, ...));
+#  else
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef scanf
+#    define scanf rpl_scanf
+#   endif
+_GL_FUNCDECL_RPL (scanf, int, (const char *restrict format, ...)
+                              _GL_ATTRIBUTE_FORMAT_SCANF_SYSTEM (1, 2)
+                              _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (scanf, int, (const char *restrict format, ...));
+#  endif
+# else
+_GL_CXXALIAS_SYS (scanf, int, (const char *restrict format, ...));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (scanf);
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define snprintf rpl_snprintf
+#  endif
+#  define GNULIB_overrides_snprintf 1
+_GL_FUNCDECL_RPL (snprintf, int,
+                  (char *restrict str, size_t size,
+                   const char *restrict format, ...)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (3, 4)
+                  _GL_ARG_NONNULL ((3)));
+_GL_CXXALIAS_RPL (snprintf, int,
+                  (char *restrict str, size_t size,
+                   const char *restrict format, ...));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (snprintf, int,
+                  (char *restrict str, size_t size,
+                   const char *restrict format, ...)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (3, 4)
+                  _GL_ARG_NONNULL ((3)));
+#  endif
+_GL_CXXALIAS_SYS (snprintf, int,
+                  (char *restrict str, size_t size,
+                   const char *restrict format, ...));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (snprintf);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef snprintf
+# if HAVE_RAW_DECL_SNPRINTF
+_GL_WARN_ON_USE (snprintf, "snprintf is unportable - "
+                 "use gnulib module snprintf for portability");
+# endif
+#endif
+
+/* Some people would argue that all sprintf uses should be warned about
+   (for example, OpenBSD issues a link warning for it),
+   since it can cause security holes due to buffer overruns.
+   However, we believe that sprintf can be used safely, and is more
+   efficient than snprintf in those safe cases; and as proof of our
+   belief, we use sprintf in several gnulib modules.  So this header
+   intentionally avoids adding a warning to sprintf except when
+   GNULIB_POSIXCHECK is defined.  */
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define sprintf rpl_sprintf
+#  endif
+#  define GNULIB_overrides_sprintf 1
+_GL_FUNCDECL_RPL (sprintf, int,
+                  (char *restrict str, const char *restrict format, ...)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (2, 3)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (sprintf, int,
+                  (char *restrict str, const char *restrict format, ...));
+# else
+_GL_CXXALIAS_SYS (sprintf, int,
+                  (char *restrict str, const char *restrict format, ...));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (sprintf);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef sprintf
+/* Assume sprintf is always declared.  */
+_GL_WARN_ON_USE (sprintf, "sprintf is not always POSIX compliant - "
+                 "use gnulib module sprintf-posix for portable "
+                 "POSIX compliance");
+#endif
+
+#if 1
+/* On native Windows, map 'tempnam' to '_tempnam', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::tempnam always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef tempnam
+#   define tempnam _tempnam
+#  endif
+_GL_CXXALIAS_MDA (tempnam, char *, (const char *dir, const char *prefix));
+# else
+_GL_CXXALIAS_SYS (tempnam, char *, (const char *dir, const char *prefix));
+# endif
+_GL_CXXALIASWARN (tempnam);
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define tmpfile rpl_tmpfile
+#  endif
+_GL_FUNCDECL_RPL (tmpfile, FILE *, (void)
+                                   _GL_ATTRIBUTE_DEALLOC (fclose, 1));
+_GL_CXXALIAS_RPL (tmpfile, FILE *, (void));
+# else
+#  if __GNUC__ >= 11
+/* For -Wmismatched-dealloc: Associate tmpfile with fclose or rpl_fclose.  */
+_GL_FUNCDECL_SYS (tmpfile, FILE *, (void)
+                                   _GL_ATTRIBUTE_DEALLOC (fclose, 1));
+#  endif
+_GL_CXXALIAS_SYS (tmpfile, FILE *, (void));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (tmpfile);
+# endif
+#else
+# if 0 && __GNUC__ >= 11 && !defined tmpfile
+/* For -Wmismatched-dealloc: Associate tmpfile with fclose or rpl_fclose.  */
+_GL_FUNCDECL_SYS (tmpfile, FILE *, (void)
+                                   _GL_ATTRIBUTE_DEALLOC (fclose, 1));
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef tmpfile
+#  if HAVE_RAW_DECL_TMPFILE
+_GL_WARN_ON_USE (tmpfile, "tmpfile is not usable on mingw - "
+                 "use gnulib module tmpfile for portability");
+#  endif
+# endif
+#endif
+
+#if 0
+/* Write formatted output to a string dynamically allocated with malloc().
+   If the memory allocation succeeds, store the address of the string in
+   *RESULT and return the number of resulting bytes, excluding the trailing
+   NUL.  Upon memory allocation error, or some other error, return -1.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define asprintf rpl_asprintf
+#  endif
+#  define GNULIB_overrides_asprintf
+_GL_FUNCDECL_RPL (asprintf, int,
+                  (char **result, const char *format, ...)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (2, 3)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (asprintf, int,
+                  (char **result, const char *format, ...));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (asprintf, int,
+                  (char **result, const char *format, ...)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (2, 3)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (asprintf, int,
+                  (char **result, const char *format, ...));
+# endif
+_GL_CXXALIASWARN (asprintf);
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define vasprintf rpl_vasprintf
+#  endif
+#  define GNULIB_overrides_vasprintf 1
+_GL_FUNCDECL_RPL (vasprintf, int,
+                  (char **result, const char *format, va_list args)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (2, 0)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (vasprintf, int,
+                  (char **result, const char *format, va_list args));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (vasprintf, int,
+                  (char **result, const char *format, va_list args)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (2, 0)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (vasprintf, int,
+                  (char **result, const char *format, va_list args));
+# endif
+_GL_CXXALIASWARN (vasprintf);
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define vdprintf rpl_vdprintf
+#  endif
+_GL_FUNCDECL_RPL (vdprintf, int,
+                  (int fd, const char *restrict format, va_list args)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (2, 0)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (vdprintf, int,
+                  (int fd, const char *restrict format, va_list args));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (vdprintf, int,
+                  (int fd, const char *restrict format, va_list args)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (2, 0)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+/* Need to cast, because on Solaris, the third parameter will likely be
+                                                    __va_list args.  */
+_GL_CXXALIAS_SYS_CAST (vdprintf, int,
+                       (int fd, const char *restrict format, va_list args));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (vdprintf);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef vdprintf
+# if HAVE_RAW_DECL_VDPRINTF
+_GL_WARN_ON_USE (vdprintf, "vdprintf is unportable - "
+                 "use gnulib module vdprintf for portability");
+# endif
+#endif
+
+#if 0 || 1
+# if (0 && 0) \
+     || (1 && 0 && (0 || 0))
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define vfprintf rpl_vfprintf
+#  endif
+#  define GNULIB_overrides_vfprintf 1
+#  if 0
+_GL_FUNCDECL_RPL (vfprintf, int,
+                  (FILE *restrict fp,
+                   const char *restrict format, va_list args)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (2, 0)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  else
+_GL_FUNCDECL_RPL (vfprintf, int,
+                  (FILE *restrict fp,
+                   const char *restrict format, va_list args)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF_SYSTEM (2, 0)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_RPL (vfprintf, int,
+                  (FILE *restrict fp,
+                   const char *restrict format, va_list args));
+# else
+/* Need to cast, because on Solaris, the third parameter is
+                                                      __va_list args
+   and GCC's fixincludes did not change this to __gnuc_va_list.  */
+_GL_CXXALIAS_SYS_CAST (vfprintf, int,
+                       (FILE *restrict fp,
+                        const char *restrict format, va_list args));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (vfprintf);
+# endif
+#endif
+#if !0 && defined GNULIB_POSIXCHECK
+# if !GNULIB_overrides_vfprintf
+#  undef vfprintf
+# endif
+/* Assume vfprintf is always declared.  */
+_GL_WARN_ON_USE (vfprintf, "vfprintf is not always POSIX compliant - "
+                 "use gnulib module vfprintf-posix for portable "
+                      "POSIX compliance");
+#endif
+
+#if 0
+# if 0 && 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef vfscanf
+#   define vfscanf rpl_vfscanf
+#  endif
+_GL_FUNCDECL_RPL (vfscanf, int,
+                  (FILE *restrict stream,
+                   const char *restrict format, va_list args)
+                  _GL_ATTRIBUTE_FORMAT_SCANF_SYSTEM (2, 0)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (vfscanf, int,
+                  (FILE *restrict stream,
+                   const char *restrict format, va_list args));
+# else
+_GL_CXXALIAS_SYS (vfscanf, int,
+                  (FILE *restrict stream,
+                   const char *restrict format, va_list args));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (vfscanf);
+# endif
+#endif
+
+#if 0 || 1
+# if (0 && 0) \
+     || (1 && 0 && (0 || 0))
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define vprintf rpl_vprintf
+#  endif
+#  define GNULIB_overrides_vprintf 1
+#  if 0 || 0
+_GL_FUNCDECL_RPL (vprintf, int, (const char *restrict format, va_list args)
+                                _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (1, 0)
+                                _GL_ARG_NONNULL ((1)));
+#  else
+_GL_FUNCDECL_RPL (vprintf, int, (const char *restrict format, va_list args)
+                                _GL_ATTRIBUTE_FORMAT_PRINTF_SYSTEM (1, 0)
+                                _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_RPL (vprintf, int, (const char *restrict format, va_list args));
+# else
+/* Need to cast, because on Solaris, the second parameter is
+                                                          __va_list args
+   and GCC's fixincludes did not change this to __gnuc_va_list.  */
+_GL_CXXALIAS_SYS_CAST (vprintf, int,
+                       (const char *restrict format, va_list args));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (vprintf);
+# endif
+#endif
+#if !0 && defined GNULIB_POSIXCHECK
+# if !GNULIB_overrides_vprintf
+#  undef vprintf
+# endif
+/* Assume vprintf is always declared.  */
+_GL_WARN_ON_USE (vprintf, "vprintf is not always POSIX compliant - "
+                 "use gnulib module vprintf-posix for portable "
+                 "POSIX compliance");
+#endif
+
+#if 0
+# if 0 && 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef vscanf
+#   define vscanf rpl_vscanf
+#  endif
+_GL_FUNCDECL_RPL (vscanf, int, (const char *restrict format, va_list args)
+                               _GL_ATTRIBUTE_FORMAT_SCANF_SYSTEM (1, 0)
+                               _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (vscanf, int, (const char *restrict format, va_list args));
+# else
+_GL_CXXALIAS_SYS (vscanf, int, (const char *restrict format, va_list args));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (vscanf);
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define vsnprintf rpl_vsnprintf
+#  endif
+#  define GNULIB_overrides_vsnprintf 1
+_GL_FUNCDECL_RPL (vsnprintf, int,
+                  (char *restrict str, size_t size,
+                   const char *restrict format, va_list args)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (3, 0)
+                  _GL_ARG_NONNULL ((3)));
+_GL_CXXALIAS_RPL (vsnprintf, int,
+                  (char *restrict str, size_t size,
+                   const char *restrict format, va_list args));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (vsnprintf, int,
+                  (char *restrict str, size_t size,
+                   const char *restrict format, va_list args)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (3, 0)
+                  _GL_ARG_NONNULL ((3)));
+#  endif
+_GL_CXXALIAS_SYS (vsnprintf, int,
+                  (char *restrict str, size_t size,
+                   const char *restrict format, va_list args));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (vsnprintf);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef vsnprintf
+# if HAVE_RAW_DECL_VSNPRINTF
+_GL_WARN_ON_USE (vsnprintf, "vsnprintf is unportable - "
+                 "use gnulib module vsnprintf for portability");
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define vsprintf rpl_vsprintf
+#  endif
+#  define GNULIB_overrides_vsprintf 1
+_GL_FUNCDECL_RPL (vsprintf, int,
+                  (char *restrict str,
+                   const char *restrict format, va_list args)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF_STANDARD (2, 0)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (vsprintf, int,
+                  (char *restrict str,
+                   const char *restrict format, va_list args));
+# else
+/* Need to cast, because on Solaris, the third parameter is
+                                                       __va_list args
+   and GCC's fixincludes did not change this to __gnuc_va_list.  */
+_GL_CXXALIAS_SYS_CAST (vsprintf, int,
+                       (char *restrict str,
+                        const char *restrict format, va_list args));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (vsprintf);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef vsprintf
+/* Assume vsprintf is always declared.  */
+_GL_WARN_ON_USE (vsprintf, "vsprintf is not always POSIX compliant - "
+                 "use gnulib module vsprintf-posix for portable "
+                      "POSIX compliance");
+#endif
+
+#endif /* _GL_STDIO_H */
+#endif /* _GL_STDIO_H */
+#endif
diff -Naur ../orig/sed-4.9/lib/stdlib.h ./lib/stdlib.h
--- ../orig/sed-4.9/lib/stdlib.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/stdlib.h	2022-12-01 17:13:19.139986300 +0300
@@ -0,0 +1,2115 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A GNU-like <stdlib.h>.
+
+   Copyright (C) 1995, 2001-2004, 2006-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#if __GNUC__ >= 3
+
+#endif
+
+
+#if defined __need_system_stdlib_h || defined __need_malloc_and_calloc
+/* Special invocation conventions inside some gnulib header files,
+   and inside some glibc header files, respectively.  */
+
+#include "C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\INCLUDE\stdlib.h"
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_STDLIB_H
+
+/* The include_next requires a split double-inclusion guard.  */
+#include "C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\INCLUDE\stdlib.h"
+
+#ifndef _GL_STDLIB_H
+#define _GL_STDLIB_H
+
+/* NetBSD 5.0 mis-defines NULL.  */
+#include <stddef.h>
+
+/* MirBSD 10 defines WEXITSTATUS in <sys/wait.h>, not in <stdlib.h>.  */
+#if 0 && !defined WEXITSTATUS
+# include <sys/wait.h>
+#endif
+
+/* Solaris declares getloadavg() in <sys/loadavg.h>.  */
+#if (0 || defined GNULIB_POSIXCHECK) && 0
+/* OpenIndiana has a bug: <sys/time.h> must be included before
+   <sys/loadavg.h>.  */
+# include <sys/time.h>
+# include <sys/loadavg.h>
+#endif
+
+/* Native Windows platforms declare _mktemp() in <io.h>.  */
+#if defined _WIN32 && !defined __CYGWIN__
+# include <io.h>
+#endif
+
+#if 0
+
+/* OSF/1 5.1 declares 'struct random_data' in <random.h>, which is included
+   from <stdlib.h> if _REENTRANT is defined.  Include it whenever we need
+   'struct random_data'.  */
+# if 1
+#  include <random.h>
+# endif
+
+# if !1 || 0 || !1
+#  include <stdint.h>
+# endif
+
+# if !1
+/* Define 'struct random_data'.
+   But allow multiple gnulib generated <stdlib.h> replacements to coexist.  */
+#  if !GNULIB_defined_struct_random_data
+struct random_data
+{
+  int32_t *fptr;                /* Front pointer.  */
+  int32_t *rptr;                /* Rear pointer.  */
+  int32_t *state;               /* Array of state values.  */
+  int rand_type;                /* Type of random number generator.  */
+  int rand_deg;                 /* Degree of random number generator.  */
+  int rand_sep;                 /* Distance between front and rear.  */
+  int32_t *end_ptr;             /* Pointer behind state table.  */
+};
+#   define GNULIB_defined_struct_random_data 1
+#  endif
+# endif
+#endif
+
+#if (0 || 0 || 1 || 0 || 0 || defined GNULIB_POSIXCHECK) && ! defined __GLIBC__ && !(defined _WIN32 && ! defined __CYGWIN__)
+/* On Mac OS X 10.3, only <unistd.h> declares mkstemp.  */
+/* On Mac OS X 10.5, only <unistd.h> declares mkstemps.  */
+/* On Mac OS X 10.13, only <unistd.h> declares mkostemp and mkostemps.  */
+/* On Cygwin 1.7.1, only <unistd.h> declares getsubopt.  */
+/* But avoid namespace pollution on glibc systems and native Windows.  */
+# include <unistd.h>
+#endif
+
+/* _GL_ATTRIBUTE_DEALLOC (F, I) declares that the function returns pointers
+   that can be freed by passing them as the Ith argument to the
+   function F.  */
+#ifndef _GL_ATTRIBUTE_DEALLOC
+# if __GNUC__ >= 11
+#  define _GL_ATTRIBUTE_DEALLOC(f, i) __attribute__ ((__malloc__ (f, i)))
+# else
+#  define _GL_ATTRIBUTE_DEALLOC(f, i)
+# endif
+#endif
+
+/* _GL_ATTRIBUTE_DEALLOC_FREE declares that the function returns pointers that
+   can be freed via 'free'; it can be used only after declaring 'free'.  */
+/* Applies to: functions.  Cannot be used on inline functions.  */
+#ifndef _GL_ATTRIBUTE_DEALLOC_FREE
+# define _GL_ATTRIBUTE_DEALLOC_FREE _GL_ATTRIBUTE_DEALLOC (free, 1)
+#endif
+
+/* _GL_ATTRIBUTE_MALLOC declares that the function returns a pointer to freshly
+   allocated memory.  */
+/* Applies to: functions.  */
+#ifndef _GL_ATTRIBUTE_MALLOC
+# if __GNUC__ >= 3 || defined __clang__
+#  define _GL_ATTRIBUTE_MALLOC __attribute__ ((__malloc__))
+# else
+#  define _GL_ATTRIBUTE_MALLOC
+# endif
+#endif
+
+/* The __attribute__ feature is available in gcc versions 2.5 and later.
+   The attribute __pure__ was added in gcc 2.96.  */
+#ifndef _GL_ATTRIBUTE_PURE
+# if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96) || defined __clang__
+#  define _GL_ATTRIBUTE_PURE __attribute__ ((__pure__))
+# else
+#  define _GL_ATTRIBUTE_PURE /* empty */
+# endif
+#endif
+
+/* The definition of _Noreturn is copied here.  */
+/* A C macro for declaring that a function does not return.
+   Copyright (C) 2011-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _Noreturn
+# if (defined __cplusplus \
+      && ((201103 <= __cplusplus && !(__GNUC__ == 4 && __GNUC_MINOR__ == 7)) \
+          || (defined _MSC_VER && 1900 <= _MSC_VER)) \
+      && 0)
+    /* [[noreturn]] is not practically usable, because with it the syntax
+         extern _Noreturn void func (...);
+       would not be valid; such a declaration would only be valid with 'extern'
+       and '_Noreturn' swapped, or without the 'extern' keyword.  However, some
+       AIX system header files and several gnulib header files use precisely
+       this syntax with 'extern'.  */
+#  define _Noreturn [[noreturn]]
+# elif ((!defined __cplusplus || defined __clang__) \
+        && (201112 <= (defined __STDC_VERSION__ ? __STDC_VERSION__ : 0) \
+            || (!defined __STRICT_ANSI__ \
+                && (4 < __GNUC__ + (7 <= __GNUC_MINOR__) \
+                    || (defined __apple_build_version__ \
+                        ? 6000000 <= __apple_build_version__ \
+                        : 3 < __clang_major__ + (5 <= __clang_minor__))))))
+   /* _Noreturn works as-is.  */
+# elif (2 < __GNUC__ + (8 <= __GNUC_MINOR__) || defined __clang__ \
+        || 0x5110 <= __SUNPRO_C)
+#  define _Noreturn __attribute__ ((__noreturn__))
+# elif 1200 <= (defined _MSC_VER ? _MSC_VER : 0)
+#  define _Noreturn __declspec (noreturn)
+# else
+#  define _Noreturn
+# endif
+#endif
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA (func, rettype, parameters);
+   is to be used when func is a Microsoft deprecated alias, on native Windows.
+   It declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to _func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_MDA (open, int, (const char *filename, int flags, ...));
+ */
+#define _GL_CXXALIAS_MDA(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_MDA (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#define _GL_CXXALIAS_MDA_CAST(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_CAST_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || defined __clang__
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype_gcc, rettype_clang, parameters_and_attributes, "message")
+   is like _GL_WARN_ON_USE (function, "message"), except that in C++ mode the
+   function is declared with the given prototype, consisting of return type,
+   parameters, and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if !defined __cplusplus
+#  define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+     _GL_WARN_ON_USE (function, msg)
+# else
+#  if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes \
+  __attribute__ ((__warning__ (msg)))
+#  elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_clang function parameters_and_attributes \
+  __attribute__ ((__diagnose_if__ (1, msg, "warning")))
+#  elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes
+#  else /* Unsupported.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  endif
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+
+/* Some systems do not define EXIT_*, despite otherwise supporting C89.  */
+#ifndef EXIT_SUCCESS
+# define EXIT_SUCCESS 0
+#endif
+/* Tandem/NSK and other platforms that define EXIT_FAILURE as -1 interfere
+   with proper operation of xargs.  */
+#ifndef EXIT_FAILURE
+# define EXIT_FAILURE 1
+#elif EXIT_FAILURE != 1
+# undef EXIT_FAILURE
+# define EXIT_FAILURE 1
+#endif
+
+
+#if 0
+/* Terminate the current process with the given return code, without running
+   the 'atexit' handlers.  */
+# if !1
+_GL_FUNCDECL_SYS (_Exit, _Noreturn void, (int status));
+# endif
+_GL_CXXALIAS_SYS (_Exit, void, (int status));
+_GL_CXXALIASWARN (_Exit);
+#elif defined GNULIB_POSIXCHECK
+# undef _Exit
+# if HAVE_RAW_DECL__EXIT
+_GL_WARN_ON_USE (_Exit, "_Exit is unportable - "
+                 "use gnulib module _Exit for portability");
+# endif
+#endif
+
+
+#if 1
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef free
+#   define free rpl_free
+#  endif
+#  if defined __cplusplus && (__GLIBC__ + (__GLIBC_MINOR__ >= 14) > 2)
+_GL_FUNCDECL_RPL (free, void, (void *ptr) throw ());
+#  else
+_GL_FUNCDECL_RPL (free, void, (void *ptr));
+#  endif
+_GL_CXXALIAS_RPL (free, void, (void *ptr));
+# else
+_GL_CXXALIAS_SYS (free, void, (void *ptr));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (free);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef free
+/* Assume free is always declared.  */
+_GL_WARN_ON_USE (free, "free is not future POSIX compliant everywhere - "
+                 "use gnulib module free for portability");
+#endif
+
+
+/* Allocate memory with indefinite extent and specified alignment.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef aligned_alloc
+#   define aligned_alloc rpl_aligned_alloc
+#  endif
+_GL_FUNCDECL_RPL (aligned_alloc, void *,
+                  (size_t alignment, size_t size)
+                  _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC_FREE);
+_GL_CXXALIAS_RPL (aligned_alloc, void *, (size_t alignment, size_t size));
+# else
+#  if 1
+#   if __GNUC__ >= 11
+/* For -Wmismatched-dealloc: Associate aligned_alloc with free or rpl_free.  */
+_GL_FUNCDECL_SYS (aligned_alloc, void *,
+                  (size_t alignment, size_t size)
+                  _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC_FREE);
+#   endif
+_GL_CXXALIAS_SYS (aligned_alloc, void *, (size_t alignment, size_t size));
+#  endif
+# endif
+# if (__GLIBC__ >= 2) && 1
+_GL_CXXALIASWARN (aligned_alloc);
+# endif
+#else
+# if 1 && __GNUC__ >= 11 && !defined aligned_alloc
+/* For -Wmismatched-dealloc: Associate aligned_alloc with free or rpl_free.  */
+_GL_FUNCDECL_SYS (aligned_alloc, void *,
+                  (size_t alignment, size_t size)
+                  _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC_FREE);
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef aligned_alloc
+#  if HAVE_RAW_DECL_ALIGNED_ALLOC
+_GL_WARN_ON_USE (aligned_alloc, "aligned_alloc is not portable - "
+                 "use gnulib module aligned_alloc for portability");
+#  endif
+# endif
+#endif
+
+#if 0
+/* Parse a signed decimal integer.
+   Returns the value of the integer.  Errors are not detected.  */
+# if !1
+_GL_FUNCDECL_SYS (atoll, long long, (const char *string)
+                                    _GL_ATTRIBUTE_PURE
+                                    _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (atoll, long long, (const char *string));
+_GL_CXXALIASWARN (atoll);
+#elif defined GNULIB_POSIXCHECK
+# undef atoll
+# if HAVE_RAW_DECL_ATOLL
+_GL_WARN_ON_USE (atoll, "atoll is unportable - "
+                 "use gnulib module atoll for portability");
+# endif
+#endif
+
+#if 1
+# if (1 && 1) \
+     || (1 && 1)
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef calloc
+#   define calloc rpl_calloc
+#  endif
+_GL_FUNCDECL_RPL (calloc, void *,
+                  (size_t nmemb, size_t size)
+                  _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC_FREE);
+_GL_CXXALIAS_RPL (calloc, void *, (size_t nmemb, size_t size));
+# else
+#  if __GNUC__ >= 11
+/* For -Wmismatched-dealloc: Associate calloc with free or rpl_free.  */
+_GL_FUNCDECL_SYS (calloc, void *,
+                  (size_t nmemb, size_t size)
+                  _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC_FREE);
+#  endif
+_GL_CXXALIAS_SYS (calloc, void *, (size_t nmemb, size_t size));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (calloc);
+# endif
+#else
+# if 1 && __GNUC__ >= 11 && !defined calloc
+/* For -Wmismatched-dealloc: Associate calloc with free or rpl_free.  */
+_GL_FUNCDECL_SYS (calloc, void *,
+                  (size_t nmemb, size_t size)
+                  _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC_FREE);
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef calloc
+/* Assume calloc is always declared.  */
+_GL_WARN_ON_USE (calloc, "calloc is not POSIX compliant everywhere - "
+                 "use gnulib module calloc-posix for portability");
+# endif
+#endif
+
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define canonicalize_file_name rpl_canonicalize_file_name
+#  endif
+_GL_FUNCDECL_RPL (canonicalize_file_name, char *,
+                  (const char *name)
+                  _GL_ARG_NONNULL ((1))
+                  _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC_FREE);
+_GL_CXXALIAS_RPL (canonicalize_file_name, char *, (const char *name));
+# else
+#  if !0 || __GNUC__ >= 11
+_GL_FUNCDECL_SYS (canonicalize_file_name, char *,
+                  (const char *name)
+                  _GL_ARG_NONNULL ((1))
+                  _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC_FREE);
+#  endif
+_GL_CXXALIAS_SYS (canonicalize_file_name, char *, (const char *name));
+# endif
+# ifndef GNULIB_defined_canonicalize_file_name
+#  define GNULIB_defined_canonicalize_file_name \
+     (!0 || 0)
+# endif
+_GL_CXXALIASWARN (canonicalize_file_name);
+#else
+# if 1 && __GNUC__ >= 11 && !defined canonicalize_file_name
+/* For -Wmismatched-dealloc: Associate canonicalize_file_name with free or
+   rpl_free.  */
+_GL_FUNCDECL_SYS (canonicalize_file_name, char *,
+                  (const char *name)
+                  _GL_ARG_NONNULL ((1))
+                  _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC_FREE);
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef canonicalize_file_name
+#  if HAVE_RAW_DECL_CANONICALIZE_FILE_NAME
+_GL_WARN_ON_USE (canonicalize_file_name,
+                 "canonicalize_file_name is unportable - "
+                 "use gnulib module canonicalize-lgpl for portability");
+#  endif
+# endif
+#endif
+
+#if 1
+/* On native Windows, map 'ecvt' to '_ecvt', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::ecvt on all platforms that have
+   it.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef ecvt
+#   define ecvt _ecvt
+#  endif
+_GL_CXXALIAS_MDA (ecvt, char *,
+                  (double number, int ndigits, int *decptp, int *signp));
+# else
+#  if 1
+_GL_CXXALIAS_SYS (ecvt, char *,
+                  (double number, int ndigits, int *decptp, int *signp));
+#  endif
+# endif
+# if (defined _WIN32 && !defined __CYGWIN__) || 1
+_GL_CXXALIASWARN (ecvt);
+# endif
+#endif
+
+#if 1
+/* On native Windows, map 'fcvt' to '_fcvt', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::fcvt on all platforms that have
+   it.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fcvt
+#   define fcvt _fcvt
+#  endif
+_GL_CXXALIAS_MDA (fcvt, char *,
+                  (double number, int ndigits, int *decptp, int *signp));
+# else
+#  if 1
+_GL_CXXALIAS_SYS (fcvt, char *,
+                  (double number, int ndigits, int *decptp, int *signp));
+#  endif
+# endif
+# if (defined _WIN32 && !defined __CYGWIN__) || 1
+_GL_CXXALIASWARN (fcvt);
+# endif
+#endif
+
+#if 1
+/* On native Windows, map 'gcvt' to '_gcvt', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::gcvt on all platforms that have
+   it.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef gcvt
+#   define gcvt _gcvt
+#  endif
+_GL_CXXALIAS_MDA (gcvt, char *, (double number, int ndigits, char *buf));
+# else
+#  if 1
+_GL_CXXALIAS_SYS (gcvt, char *, (double number, int ndigits, char *buf));
+#  endif
+# endif
+# if (defined _WIN32 && !defined __CYGWIN__) || 1
+_GL_CXXALIASWARN (gcvt);
+# endif
+#endif
+
+#if 0
+/* Store max(NELEM,3) load average numbers in LOADAVG[].
+   The three numbers are the load average of the last 1 minute, the last 5
+   minutes, and the last 15 minutes, respectively.
+   LOADAVG is an array of NELEM numbers.  */
+# if !1
+_GL_FUNCDECL_SYS (getloadavg, int, (double loadavg[], int nelem)
+                                   _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (getloadavg, int, (double loadavg[], int nelem));
+_GL_CXXALIASWARN (getloadavg);
+#elif defined GNULIB_POSIXCHECK
+# undef getloadavg
+# if HAVE_RAW_DECL_GETLOADAVG
+_GL_WARN_ON_USE (getloadavg, "getloadavg is not portable - "
+                 "use gnulib module getloadavg for portability");
+# endif
+#endif
+
+#if 0
+/* Assuming *OPTIONP is a comma separated list of elements of the form
+   "token" or "token=value", getsubopt parses the first of these elements.
+   If the first element refers to a "token" that is member of the given
+   NULL-terminated array of tokens:
+     - It replaces the comma with a NUL byte, updates *OPTIONP to point past
+       the first option and the comma, sets *VALUEP to the value of the
+       element (or NULL if it doesn't contain an "=" sign),
+     - It returns the index of the "token" in the given array of tokens.
+   Otherwise it returns -1, and *OPTIONP and *VALUEP are undefined.
+   For more details see the POSIX specification.
+   https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsubopt.html */
+# if !1
+_GL_FUNCDECL_SYS (getsubopt, int,
+                  (char **optionp, char *const *tokens, char **valuep)
+                  _GL_ARG_NONNULL ((1, 2, 3)));
+# endif
+_GL_CXXALIAS_SYS (getsubopt, int,
+                  (char **optionp, char *const *tokens, char **valuep));
+_GL_CXXALIASWARN (getsubopt);
+#elif defined GNULIB_POSIXCHECK
+# undef getsubopt
+# if HAVE_RAW_DECL_GETSUBOPT
+_GL_WARN_ON_USE (getsubopt, "getsubopt is unportable - "
+                 "use gnulib module getsubopt for portability");
+# endif
+#endif
+
+#if 0
+/* Change the ownership and access permission of the slave side of the
+   pseudo-terminal whose master side is specified by FD.  */
+# if !1
+_GL_FUNCDECL_SYS (grantpt, int, (int fd));
+# endif
+_GL_CXXALIAS_SYS (grantpt, int, (int fd));
+_GL_CXXALIASWARN (grantpt);
+#elif defined GNULIB_POSIXCHECK
+# undef grantpt
+# if HAVE_RAW_DECL_GRANTPT
+_GL_WARN_ON_USE (grantpt, "grantpt is not portable - "
+                 "use gnulib module grantpt for portability");
+# endif
+#endif
+
+/* If _GL_USE_STDLIB_ALLOC is nonzero, the including module does not
+   rely on GNU or POSIX semantics for malloc and realloc (for example,
+   by never specifying a zero size), so it does not need malloc or
+   realloc to be redefined.  */
+#if 1
+# if (1 && 1) \
+     || (1 && 1)
+#  if !((defined __cplusplus && defined GNULIB_NAMESPACE) \
+        || _GL_USE_STDLIB_ALLOC)
+#   undef malloc
+#   define malloc rpl_malloc
+#  endif
+_GL_FUNCDECL_RPL (malloc, void *,
+                  (size_t size)
+                  _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC_FREE);
+_GL_CXXALIAS_RPL (malloc, void *, (size_t size));
+# else
+#  if __GNUC__ >= 11
+/* For -Wmismatched-dealloc: Associate malloc with free or rpl_free.  */
+_GL_FUNCDECL_SYS (malloc, void *,
+                  (size_t size)
+                  _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC_FREE);
+#  endif
+_GL_CXXALIAS_SYS (malloc, void *, (size_t size));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (malloc);
+# endif
+#else
+# if 1 && __GNUC__ >= 11 && !defined malloc
+/* For -Wmismatched-dealloc: Associate malloc with free or rpl_free.  */
+_GL_FUNCDECL_SYS (malloc, void *,
+                  (size_t size)
+                  _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC_FREE);
+# endif
+# if defined GNULIB_POSIXCHECK && !_GL_USE_STDLIB_ALLOC
+#  undef malloc
+/* Assume malloc is always declared.  */
+_GL_WARN_ON_USE (malloc, "malloc is not POSIX compliant everywhere - "
+                 "use gnulib module malloc-posix for portability");
+# endif
+#endif
+
+/* Convert a multibyte character to a wide character.  */
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbtowc
+#   define mbtowc rpl_mbtowc
+#  endif
+_GL_FUNCDECL_RPL (mbtowc, int,
+                  (wchar_t *restrict pwc, const char *restrict s, size_t n));
+_GL_CXXALIAS_RPL (mbtowc, int,
+                  (wchar_t *restrict pwc, const char *restrict s, size_t n));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (mbtowc, int,
+                  (wchar_t *restrict pwc, const char *restrict s, size_t n));
+#  endif
+_GL_CXXALIAS_SYS (mbtowc, int,
+                  (wchar_t *restrict pwc, const char *restrict s, size_t n));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (mbtowc);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef mbtowc
+# if HAVE_RAW_DECL_MBTOWC
+_GL_WARN_ON_USE (mbtowc, "mbtowc is not portable - "
+                 "use gnulib module mbtowc for portability");
+# endif
+#endif
+
+#if 0
+/* Create a unique temporary directory from TEMPLATE.
+   The last six characters of TEMPLATE must be "XXXXXX";
+   they are replaced with a string that makes the directory name unique.
+   Returns TEMPLATE, or a null pointer if it cannot get a unique name.
+   The directory is created mode 700.  */
+# if !1
+_GL_FUNCDECL_SYS (mkdtemp, char *, (char * /*template*/) _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (mkdtemp, char *, (char * /*template*/));
+_GL_CXXALIASWARN (mkdtemp);
+#elif defined GNULIB_POSIXCHECK
+# undef mkdtemp
+# if HAVE_RAW_DECL_MKDTEMP
+_GL_WARN_ON_USE (mkdtemp, "mkdtemp is unportable - "
+                 "use gnulib module mkdtemp for portability");
+# endif
+#endif
+
+#if 1
+/* Create a unique temporary file from TEMPLATE.
+   The last six characters of TEMPLATE must be "XXXXXX";
+   they are replaced with a string that makes the file name unique.
+   The flags are a bitmask, possibly including O_CLOEXEC (defined in <fcntl.h>)
+   and O_TEXT, O_BINARY (defined in "binary-io.h").
+   The file is then created, with the specified flags, ensuring it didn't exist
+   before.
+   The file is created read-write (mask at least 0600 & ~umask), but it may be
+   world-readable and world-writable (mask 0666 & ~umask), depending on the
+   implementation.
+   Returns the open file descriptor if successful, otherwise -1 and errno
+   set.  */
+# if !0
+_GL_FUNCDECL_SYS (mkostemp, int, (char * /*template*/, int /*flags*/)
+                                 _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (mkostemp, int, (char * /*template*/, int /*flags*/));
+_GL_CXXALIASWARN (mkostemp);
+#elif defined GNULIB_POSIXCHECK
+# undef mkostemp
+# if HAVE_RAW_DECL_MKOSTEMP
+_GL_WARN_ON_USE (mkostemp, "mkostemp is unportable - "
+                 "use gnulib module mkostemp for portability");
+# endif
+#endif
+
+#if 0
+/* Create a unique temporary file from TEMPLATE.
+   The last six characters of TEMPLATE before a suffix of length
+   SUFFIXLEN must be "XXXXXX";
+   they are replaced with a string that makes the file name unique.
+   The flags are a bitmask, possibly including O_CLOEXEC (defined in <fcntl.h>)
+   and O_TEXT, O_BINARY (defined in "binary-io.h").
+   The file is then created, with the specified flags, ensuring it didn't exist
+   before.
+   The file is created read-write (mask at least 0600 & ~umask), but it may be
+   world-readable and world-writable (mask 0666 & ~umask), depending on the
+   implementation.
+   Returns the open file descriptor if successful, otherwise -1 and errno
+   set.  */
+# if !1
+_GL_FUNCDECL_SYS (mkostemps, int,
+                  (char * /*template*/, int /*suffixlen*/, int /*flags*/)
+                  _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (mkostemps, int,
+                  (char * /*template*/, int /*suffixlen*/, int /*flags*/));
+_GL_CXXALIASWARN (mkostemps);
+#elif defined GNULIB_POSIXCHECK
+# undef mkostemps
+# if HAVE_RAW_DECL_MKOSTEMPS
+_GL_WARN_ON_USE (mkostemps, "mkostemps is unportable - "
+                 "use gnulib module mkostemps for portability");
+# endif
+#endif
+
+#if 0
+/* Create a unique temporary file from TEMPLATE.
+   The last six characters of TEMPLATE must be "XXXXXX";
+   they are replaced with a string that makes the file name unique.
+   The file is then created, ensuring it didn't exist before.
+   The file is created read-write (mask at least 0600 & ~umask), but it may be
+   world-readable and world-writable (mask 0666 & ~umask), depending on the
+   implementation.
+   Returns the open file descriptor if successful, otherwise -1 and errno
+   set.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define mkstemp rpl_mkstemp
+#  endif
+_GL_FUNCDECL_RPL (mkstemp, int, (char * /*template*/) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mkstemp, int, (char * /*template*/));
+# else
+#  if ! 1
+_GL_FUNCDECL_SYS (mkstemp, int, (char * /*template*/) _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (mkstemp, int, (char * /*template*/));
+# endif
+_GL_CXXALIASWARN (mkstemp);
+#elif defined GNULIB_POSIXCHECK
+# undef mkstemp
+# if HAVE_RAW_DECL_MKSTEMP
+_GL_WARN_ON_USE (mkstemp, "mkstemp is unportable - "
+                 "use gnulib module mkstemp for portability");
+# endif
+#endif
+
+#if 0
+/* Create a unique temporary file from TEMPLATE.
+   The last six characters of TEMPLATE prior to a suffix of length
+   SUFFIXLEN must be "XXXXXX";
+   they are replaced with a string that makes the file name unique.
+   The file is then created, ensuring it didn't exist before.
+   The file is created read-write (mask at least 0600 & ~umask), but it may be
+   world-readable and world-writable (mask 0666 & ~umask), depending on the
+   implementation.
+   Returns the open file descriptor if successful, otherwise -1 and errno
+   set.  */
+# if !1
+_GL_FUNCDECL_SYS (mkstemps, int, (char * /*template*/, int /*suffixlen*/)
+                                 _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (mkstemps, int, (char * /*template*/, int /*suffixlen*/));
+_GL_CXXALIASWARN (mkstemps);
+#elif defined GNULIB_POSIXCHECK
+# undef mkstemps
+# if HAVE_RAW_DECL_MKSTEMPS
+_GL_WARN_ON_USE (mkstemps, "mkstemps is unportable - "
+                 "use gnulib module mkstemps for portability");
+# endif
+#endif
+
+#if 1
+/* On native Windows, map 'mktemp' to '_mktemp', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::mktemp always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mktemp
+#   define mktemp _mktemp
+#  endif
+_GL_CXXALIAS_MDA (mktemp, char *, (char * /*template*/));
+# else
+_GL_CXXALIAS_SYS (mktemp, char *, (char * /*template*/));
+# endif
+_GL_CXXALIASWARN (mktemp);
+#endif
+
+/* Allocate memory with indefinite extent and specified alignment.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef posix_memalign
+#   define posix_memalign rpl_posix_memalign
+#  endif
+_GL_FUNCDECL_RPL (posix_memalign, int,
+                  (void **memptr, size_t alignment, size_t size)
+                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (posix_memalign, int,
+                  (void **memptr, size_t alignment, size_t size));
+# else
+#  if 1
+_GL_CXXALIAS_SYS (posix_memalign, int,
+                  (void **memptr, size_t alignment, size_t size));
+#  endif
+# endif
+# if 1
+_GL_CXXALIASWARN (posix_memalign);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef posix_memalign
+# if HAVE_RAW_DECL_POSIX_MEMALIGN
+_GL_WARN_ON_USE (posix_memalign, "posix_memalign is not portable - "
+                 "use gnulib module posix_memalign for portability");
+# endif
+#endif
+
+#if 0
+/* Return an FD open to the master side of a pseudo-terminal.  Flags should
+   include O_RDWR, and may also include O_NOCTTY.  */
+# if !1
+_GL_FUNCDECL_SYS (posix_openpt, int, (int flags));
+# endif
+_GL_CXXALIAS_SYS (posix_openpt, int, (int flags));
+_GL_CXXALIASWARN (posix_openpt);
+#elif defined GNULIB_POSIXCHECK
+# undef posix_openpt
+# if HAVE_RAW_DECL_POSIX_OPENPT
+_GL_WARN_ON_USE (posix_openpt, "posix_openpt is not portable - "
+                 "use gnulib module posix_openpt for portability");
+# endif
+#endif
+
+#if 0
+/* Return the pathname of the pseudo-terminal slave associated with
+   the master FD is open on, or NULL on errors.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef ptsname
+#   define ptsname rpl_ptsname
+#  endif
+_GL_FUNCDECL_RPL (ptsname, char *, (int fd));
+_GL_CXXALIAS_RPL (ptsname, char *, (int fd));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (ptsname, char *, (int fd));
+#  endif
+_GL_CXXALIAS_SYS (ptsname, char *, (int fd));
+# endif
+_GL_CXXALIASWARN (ptsname);
+#elif defined GNULIB_POSIXCHECK
+# undef ptsname
+# if HAVE_RAW_DECL_PTSNAME
+_GL_WARN_ON_USE (ptsname, "ptsname is not portable - "
+                 "use gnulib module ptsname for portability");
+# endif
+#endif
+
+#if 0
+/* Set the pathname of the pseudo-terminal slave associated with
+   the master FD is open on and return 0, or set errno and return
+   non-zero on errors.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef ptsname_r
+#   define ptsname_r rpl_ptsname_r
+#  endif
+_GL_FUNCDECL_RPL (ptsname_r, int, (int fd, char *buf, size_t len));
+_GL_CXXALIAS_RPL (ptsname_r, int, (int fd, char *buf, size_t len));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (ptsname_r, int, (int fd, char *buf, size_t len));
+#  endif
+_GL_CXXALIAS_SYS (ptsname_r, int, (int fd, char *buf, size_t len));
+# endif
+# ifndef GNULIB_defined_ptsname_r
+#  define GNULIB_defined_ptsname_r (!1 || 0)
+# endif
+_GL_CXXALIASWARN (ptsname_r);
+#elif defined GNULIB_POSIXCHECK
+# undef ptsname_r
+# if HAVE_RAW_DECL_PTSNAME_R
+_GL_WARN_ON_USE (ptsname_r, "ptsname_r is not portable - "
+                 "use gnulib module ptsname_r for portability");
+# endif
+#endif
+
+#if IN_SED_GNULIB_TESTS
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef putenv
+#   define putenv rpl_putenv
+#  endif
+_GL_FUNCDECL_RPL (putenv, int, (char *string) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (putenv, int, (char *string));
+# elif defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef putenv
+#   define putenv _putenv
+#  endif
+_GL_CXXALIAS_MDA (putenv, int, (char *string));
+# else
+_GL_CXXALIAS_SYS (putenv, int, (char *string));
+# endif
+_GL_CXXALIASWARN (putenv);
+#elif 1
+/* On native Windows, map 'putenv' to '_putenv', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::putenv always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef putenv
+#   define putenv _putenv
+#  endif
+/* Need to cast, because on mingw, the parameter is either
+   'const char *string' or 'char *string'.  */
+_GL_CXXALIAS_MDA_CAST (putenv, int, (char *string));
+# else
+_GL_CXXALIAS_SYS (putenv, int, (char *string));
+# endif
+_GL_CXXALIASWARN (putenv);
+#endif
+
+#if 0
+/* Sort an array of NMEMB elements, starting at address BASE, each element
+   occupying SIZE bytes, in ascending order according to the comparison
+   function COMPARE.  */
+# ifdef __cplusplus
+extern "C" {
+# endif
+# if !GNULIB_defined_qsort_r_fn_types
+typedef int (*_gl_qsort_r_compar_fn) (void const *, void const *, void *);
+#  define GNULIB_defined_qsort_r_fn_types 1
+# endif
+# ifdef __cplusplus
+}
+# endif
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef qsort_r
+#   define qsort_r rpl_qsort_r
+#  endif
+_GL_FUNCDECL_RPL (qsort_r, void, (void *base, size_t nmemb, size_t size,
+                                  _gl_qsort_r_compar_fn compare,
+                                  void *arg) _GL_ARG_NONNULL ((1, 4)));
+_GL_CXXALIAS_RPL (qsort_r, void, (void *base, size_t nmemb, size_t size,
+                                  _gl_qsort_r_compar_fn compare,
+                                  void *arg));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (qsort_r, void, (void *base, size_t nmemb, size_t size,
+                                  _gl_qsort_r_compar_fn compare,
+                                  void *arg) _GL_ARG_NONNULL ((1, 4)));
+#  endif
+_GL_CXXALIAS_SYS (qsort_r, void, (void *base, size_t nmemb, size_t size,
+                                  _gl_qsort_r_compar_fn compare,
+                                  void *arg));
+# endif
+_GL_CXXALIASWARN (qsort_r);
+#elif defined GNULIB_POSIXCHECK
+# undef qsort_r
+# if HAVE_RAW_DECL_QSORT_R
+_GL_WARN_ON_USE (qsort_r, "qsort_r is not portable - "
+                 "use gnulib module qsort_r for portability");
+# endif
+#endif
+
+
+#if 0
+# if !1
+#  ifndef RAND_MAX
+#   define RAND_MAX 2147483647
+#  endif
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef random
+#   define random rpl_random
+#  endif
+_GL_FUNCDECL_RPL (random, long, (void));
+_GL_CXXALIAS_RPL (random, long, (void));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (random, long, (void));
+#  endif
+/* Need to cast, because on Haiku, the return type is
+                               int.  */
+_GL_CXXALIAS_SYS_CAST (random, long, (void));
+# endif
+_GL_CXXALIASWARN (random);
+#elif defined GNULIB_POSIXCHECK
+# undef random
+# if HAVE_RAW_DECL_RANDOM
+_GL_WARN_ON_USE (random, "random is unportable - "
+                 "use gnulib module random for portability");
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef srandom
+#   define srandom rpl_srandom
+#  endif
+_GL_FUNCDECL_RPL (srandom, void, (unsigned int seed));
+_GL_CXXALIAS_RPL (srandom, void, (unsigned int seed));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (srandom, void, (unsigned int seed));
+#  endif
+/* Need to cast, because on FreeBSD, the first parameter is
+                                       unsigned long seed.  */
+_GL_CXXALIAS_SYS_CAST (srandom, void, (unsigned int seed));
+# endif
+_GL_CXXALIASWARN (srandom);
+#elif defined GNULIB_POSIXCHECK
+# undef srandom
+# if HAVE_RAW_DECL_SRANDOM
+_GL_WARN_ON_USE (srandom, "srandom is unportable - "
+                 "use gnulib module random for portability");
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef initstate
+#   define initstate rpl_initstate
+#  endif
+_GL_FUNCDECL_RPL (initstate, char *,
+                  (unsigned int seed, char *buf, size_t buf_size)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (initstate, char *,
+                  (unsigned int seed, char *buf, size_t buf_size));
+# else
+#  if !1 || !1
+_GL_FUNCDECL_SYS (initstate, char *,
+                  (unsigned int seed, char *buf, size_t buf_size)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+/* Need to cast, because on FreeBSD, the first parameter is
+                        unsigned long seed.  */
+_GL_CXXALIAS_SYS_CAST (initstate, char *,
+                       (unsigned int seed, char *buf, size_t buf_size));
+# endif
+_GL_CXXALIASWARN (initstate);
+#elif defined GNULIB_POSIXCHECK
+# undef initstate
+# if HAVE_RAW_DECL_INITSTATE
+_GL_WARN_ON_USE (initstate, "initstate is unportable - "
+                 "use gnulib module random for portability");
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef setstate
+#   define setstate rpl_setstate
+#  endif
+_GL_FUNCDECL_RPL (setstate, char *, (char *arg_state) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (setstate, char *, (char *arg_state));
+# else
+#  if !1 || !1
+_GL_FUNCDECL_SYS (setstate, char *, (char *arg_state) _GL_ARG_NONNULL ((1)));
+#  endif
+/* Need to cast, because on Mac OS X 10.13, HP-UX, Solaris the first parameter
+   is                                     const char *arg_state.  */
+_GL_CXXALIAS_SYS_CAST (setstate, char *, (char *arg_state));
+# endif
+_GL_CXXALIASWARN (setstate);
+#elif defined GNULIB_POSIXCHECK
+# undef setstate
+# if HAVE_RAW_DECL_SETSTATE
+_GL_WARN_ON_USE (setstate, "setstate is unportable - "
+                 "use gnulib module random for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef random_r
+#   define random_r rpl_random_r
+#  endif
+_GL_FUNCDECL_RPL (random_r, int, (struct random_data *buf, int32_t *result)
+                                 _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (random_r, int, (struct random_data *buf, int32_t *result));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (random_r, int, (struct random_data *buf, int32_t *result)
+                                 _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (random_r, int, (struct random_data *buf, int32_t *result));
+# endif
+_GL_CXXALIASWARN (random_r);
+#elif defined GNULIB_POSIXCHECK
+# undef random_r
+# if HAVE_RAW_DECL_RANDOM_R
+_GL_WARN_ON_USE (random_r, "random_r is unportable - "
+                 "use gnulib module random_r for portability");
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef srandom_r
+#   define srandom_r rpl_srandom_r
+#  endif
+_GL_FUNCDECL_RPL (srandom_r, int,
+                  (unsigned int seed, struct random_data *rand_state)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (srandom_r, int,
+                  (unsigned int seed, struct random_data *rand_state));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (srandom_r, int,
+                  (unsigned int seed, struct random_data *rand_state)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (srandom_r, int,
+                  (unsigned int seed, struct random_data *rand_state));
+# endif
+_GL_CXXALIASWARN (srandom_r);
+#elif defined GNULIB_POSIXCHECK
+# undef srandom_r
+# if HAVE_RAW_DECL_SRANDOM_R
+_GL_WARN_ON_USE (srandom_r, "srandom_r is unportable - "
+                 "use gnulib module random_r for portability");
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef initstate_r
+#   define initstate_r rpl_initstate_r
+#  endif
+_GL_FUNCDECL_RPL (initstate_r, int,
+                  (unsigned int seed, char *buf, size_t buf_size,
+                   struct random_data *rand_state)
+                  _GL_ARG_NONNULL ((2, 4)));
+_GL_CXXALIAS_RPL (initstate_r, int,
+                  (unsigned int seed, char *buf, size_t buf_size,
+                   struct random_data *rand_state));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (initstate_r, int,
+                  (unsigned int seed, char *buf, size_t buf_size,
+                   struct random_data *rand_state)
+                  _GL_ARG_NONNULL ((2, 4)));
+#  endif
+/* Need to cast, because on Haiku, the third parameter is
+                                                     unsigned long buf_size.  */
+_GL_CXXALIAS_SYS_CAST (initstate_r, int,
+                       (unsigned int seed, char *buf, size_t buf_size,
+                        struct random_data *rand_state));
+# endif
+_GL_CXXALIASWARN (initstate_r);
+#elif defined GNULIB_POSIXCHECK
+# undef initstate_r
+# if HAVE_RAW_DECL_INITSTATE_R
+_GL_WARN_ON_USE (initstate_r, "initstate_r is unportable - "
+                 "use gnulib module random_r for portability");
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef setstate_r
+#   define setstate_r rpl_setstate_r
+#  endif
+_GL_FUNCDECL_RPL (setstate_r, int,
+                  (char *arg_state, struct random_data *rand_state)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (setstate_r, int,
+                  (char *arg_state, struct random_data *rand_state));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (setstate_r, int,
+                  (char *arg_state, struct random_data *rand_state)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+/* Need to cast, because on Haiku, the first parameter is
+                        void *arg_state.  */
+_GL_CXXALIAS_SYS_CAST (setstate_r, int,
+                       (char *arg_state, struct random_data *rand_state));
+# endif
+_GL_CXXALIASWARN (setstate_r);
+#elif defined GNULIB_POSIXCHECK
+# undef setstate_r
+# if HAVE_RAW_DECL_SETSTATE_R
+_GL_WARN_ON_USE (setstate_r, "setstate_r is unportable - "
+                 "use gnulib module random_r for portability");
+# endif
+#endif
+
+
+#if 1
+# if (1 && 1) \
+     || (1 && 0)
+#  if !((defined __cplusplus && defined GNULIB_NAMESPACE) \
+        || _GL_USE_STDLIB_ALLOC)
+#   undef realloc
+#   define realloc rpl_realloc
+#  endif
+_GL_FUNCDECL_RPL (realloc, void *, (void *ptr, size_t size)
+                                   _GL_ATTRIBUTE_DEALLOC_FREE);
+_GL_CXXALIAS_RPL (realloc, void *, (void *ptr, size_t size));
+# else
+#  if __GNUC__ >= 11
+/* For -Wmismatched-dealloc: Associate realloc with free or rpl_free.  */
+_GL_FUNCDECL_SYS (realloc, void *, (void *ptr, size_t size)
+                                   _GL_ATTRIBUTE_DEALLOC_FREE);
+#  endif
+_GL_CXXALIAS_SYS (realloc, void *, (void *ptr, size_t size));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (realloc);
+# endif
+#else
+# if 1 && __GNUC__ >= 11 && !defined realloc
+/* For -Wmismatched-dealloc: Associate realloc with free or rpl_free.  */
+_GL_FUNCDECL_SYS (realloc, void *, (void *ptr, size_t size)
+                                   _GL_ATTRIBUTE_DEALLOC_FREE);
+# endif
+# if defined GNULIB_POSIXCHECK && !_GL_USE_STDLIB_ALLOC
+#  undef realloc
+/* Assume realloc is always declared.  */
+_GL_WARN_ON_USE (realloc, "realloc is not POSIX compliant everywhere - "
+                 "use gnulib module realloc-posix for portability");
+# endif
+#endif
+
+
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef reallocarray
+#   define reallocarray rpl_reallocarray
+#  endif
+_GL_FUNCDECL_RPL (reallocarray, void *,
+                  (void *ptr, size_t nmemb, size_t size));
+_GL_CXXALIAS_RPL (reallocarray, void *,
+                  (void *ptr, size_t nmemb, size_t size));
+# else
+#  if ! 0
+_GL_FUNCDECL_SYS (reallocarray, void *,
+                  (void *ptr, size_t nmemb, size_t size));
+#  endif
+_GL_CXXALIAS_SYS (reallocarray, void *,
+                  (void *ptr, size_t nmemb, size_t size));
+# endif
+_GL_CXXALIASWARN (reallocarray);
+#elif defined GNULIB_POSIXCHECK
+# undef reallocarray
+# if HAVE_RAW_DECL_REALLOCARRAY
+_GL_WARN_ON_USE (reallocarray, "reallocarray is not portable - "
+                 "use gnulib module reallocarray for portability");
+# endif
+#endif
+
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define realpath rpl_realpath
+#  endif
+_GL_FUNCDECL_RPL (realpath, char *,
+                  (const char *restrict name, char *restrict resolved)
+                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (realpath, char *,
+                  (const char *restrict name, char *restrict resolved));
+# else
+#  if !0
+_GL_FUNCDECL_SYS (realpath, char *,
+                  (const char *restrict name, char *restrict resolved)
+                  _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (realpath, char *,
+                  (const char *restrict name, char *restrict resolved));
+# endif
+_GL_CXXALIASWARN (realpath);
+#elif defined GNULIB_POSIXCHECK
+# undef realpath
+# if HAVE_RAW_DECL_REALPATH
+_GL_WARN_ON_USE (realpath, "realpath is unportable - use gnulib module "
+                 "canonicalize or canonicalize-lgpl for portability");
+# endif
+#endif
+
+#if 0
+/* Test a user response to a question.
+   Return 1 if it is affirmative, 0 if it is negative, or -1 if not clear.  */
+# if !1
+_GL_FUNCDECL_SYS (rpmatch, int, (const char *response) _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (rpmatch, int, (const char *response));
+_GL_CXXALIASWARN (rpmatch);
+#elif defined GNULIB_POSIXCHECK
+# undef rpmatch
+# if HAVE_RAW_DECL_RPMATCH
+_GL_WARN_ON_USE (rpmatch, "rpmatch is unportable - "
+                 "use gnulib module rpmatch for portability");
+# endif
+#endif
+
+#if 0
+/* Look up NAME in the environment, returning 0 in insecure situations.  */
+# if !1
+_GL_FUNCDECL_SYS (secure_getenv, char *,
+                  (char const *name) _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (secure_getenv, char *, (char const *name));
+_GL_CXXALIASWARN (secure_getenv);
+#elif defined GNULIB_POSIXCHECK
+# undef secure_getenv
+# if HAVE_RAW_DECL_SECURE_GETENV
+_GL_WARN_ON_USE (secure_getenv, "secure_getenv is unportable - "
+                 "use gnulib module secure_getenv for portability");
+# endif
+#endif
+
+#if IN_SED_GNULIB_TESTS
+/* Set NAME to VALUE in the environment.
+   If REPLACE is nonzero, overwrite an existing value.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef setenv
+#   define setenv rpl_setenv
+#  endif
+_GL_FUNCDECL_RPL (setenv, int,
+                  (const char *name, const char *value, int replace)
+                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (setenv, int,
+                  (const char *name, const char *value, int replace));
+# else
+#  if !0
+_GL_FUNCDECL_SYS (setenv, int,
+                  (const char *name, const char *value, int replace)
+                  _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (setenv, int,
+                  (const char *name, const char *value, int replace));
+# endif
+# if !(0 && !0)
+_GL_CXXALIASWARN (setenv);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef setenv
+# if HAVE_RAW_DECL_SETENV
+_GL_WARN_ON_USE (setenv, "setenv is unportable - "
+                 "use gnulib module setenv for portability");
+# endif
+#endif
+
+#if 0
+ /* Parse a double from STRING, updating ENDP if appropriate.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strtod rpl_strtod
+#  endif
+#  define GNULIB_defined_strtod_function 1
+_GL_FUNCDECL_RPL (strtod, double,
+                  (const char *restrict str, char **restrict endp)
+                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strtod, double,
+                  (const char *restrict str, char **restrict endp));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (strtod, double,
+                  (const char *restrict str, char **restrict endp)
+                  _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (strtod, double,
+                  (const char *restrict str, char **restrict endp));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (strtod);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strtod
+# if HAVE_RAW_DECL_STRTOD
+_GL_WARN_ON_USE (strtod, "strtod is unportable - "
+                 "use gnulib module strtod for portability");
+# endif
+#endif
+
+#if 0
+ /* Parse a 'long double' from STRING, updating ENDP if appropriate.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strtold rpl_strtold
+#  endif
+#  define GNULIB_defined_strtold_function 1
+_GL_FUNCDECL_RPL (strtold, long double,
+                  (const char *restrict str, char **restrict endp)
+                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strtold, long double,
+                  (const char *restrict str, char **restrict endp));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (strtold, long double,
+                  (const char *restrict str, char **restrict endp)
+                  _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (strtold, long double,
+                  (const char *restrict str, char **restrict endp));
+# endif
+_GL_CXXALIASWARN (strtold);
+#elif defined GNULIB_POSIXCHECK
+# undef strtold
+# if HAVE_RAW_DECL_STRTOLD
+_GL_WARN_ON_USE (strtold, "strtold is unportable - "
+                 "use gnulib module strtold for portability");
+# endif
+#endif
+
+#if 0
+/* Parse a signed integer whose textual representation starts at STRING.
+   The integer is expected to be in base BASE (2 <= BASE <= 36); if BASE == 0,
+   it may be decimal or octal (with prefix "0") or hexadecimal (with prefix
+   "0x").
+   If ENDPTR is not NULL, the address of the first byte after the integer is
+   stored in *ENDPTR.
+   Upon overflow, the return value is LONG_MAX or LONG_MIN, and errno is set
+   to ERANGE.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strtol rpl_strtol
+#  endif
+#  define GNULIB_defined_strtol_function 1
+_GL_FUNCDECL_RPL (strtol, long,
+                  (const char *restrict string, char **restrict endptr,
+                   int base)
+                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strtol, long,
+                  (const char *restrict string, char **restrict endptr,
+                   int base));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (strtol, long,
+                  (const char *restrict string, char **restrict endptr,
+                   int base)
+                  _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (strtol, long,
+                  (const char *restrict string, char **restrict endptr,
+                   int base));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (strtol);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strtol
+# if HAVE_RAW_DECL_STRTOL
+_GL_WARN_ON_USE (strtol, "strtol is unportable - "
+                 "use gnulib module strtol for portability");
+# endif
+#endif
+
+#if 0
+/* Parse a signed integer whose textual representation starts at STRING.
+   The integer is expected to be in base BASE (2 <= BASE <= 36); if BASE == 0,
+   it may be decimal or octal (with prefix "0") or hexadecimal (with prefix
+   "0x").
+   If ENDPTR is not NULL, the address of the first byte after the integer is
+   stored in *ENDPTR.
+   Upon overflow, the return value is LLONG_MAX or LLONG_MIN, and errno is set
+   to ERANGE.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strtoll rpl_strtoll
+#  endif
+#  define GNULIB_defined_strtoll_function 1
+_GL_FUNCDECL_RPL (strtoll, long long,
+                  (const char *restrict string, char **restrict endptr,
+                   int base)
+                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strtoll, long long,
+                  (const char *restrict string, char **restrict endptr,
+                   int base));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (strtoll, long long,
+                  (const char *restrict string, char **restrict endptr,
+                   int base)
+                  _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (strtoll, long long,
+                  (const char *restrict string, char **restrict endptr,
+                   int base));
+# endif
+_GL_CXXALIASWARN (strtoll);
+#elif defined GNULIB_POSIXCHECK
+# undef strtoll
+# if HAVE_RAW_DECL_STRTOLL
+_GL_WARN_ON_USE (strtoll, "strtoll is unportable - "
+                 "use gnulib module strtoll for portability");
+# endif
+#endif
+
+#if 0
+/* Parse an unsigned integer whose textual representation starts at STRING.
+   The integer is expected to be in base BASE (2 <= BASE <= 36); if BASE == 0,
+   it may be decimal or octal (with prefix "0") or hexadecimal (with prefix
+   "0x").
+   If ENDPTR is not NULL, the address of the first byte after the integer is
+   stored in *ENDPTR.
+   Upon overflow, the return value is ULONG_MAX, and errno is set to ERANGE.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strtoul rpl_strtoul
+#  endif
+#  define GNULIB_defined_strtoul_function 1
+_GL_FUNCDECL_RPL (strtoul, unsigned long,
+                  (const char *restrict string, char **restrict endptr,
+                   int base)
+                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strtoul, unsigned long,
+                  (const char *restrict string, char **restrict endptr,
+                   int base));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (strtoul, unsigned long,
+                  (const char *restrict string, char **restrict endptr,
+                   int base)
+                  _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (strtoul, unsigned long,
+                  (const char *restrict string, char **restrict endptr,
+                   int base));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (strtoul);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strtoul
+# if HAVE_RAW_DECL_STRTOUL
+_GL_WARN_ON_USE (strtoul, "strtoul is unportable - "
+                 "use gnulib module strtoul for portability");
+# endif
+#endif
+
+#if 0
+/* Parse an unsigned integer whose textual representation starts at STRING.
+   The integer is expected to be in base BASE (2 <= BASE <= 36); if BASE == 0,
+   it may be decimal or octal (with prefix "0") or hexadecimal (with prefix
+   "0x").
+   If ENDPTR is not NULL, the address of the first byte after the integer is
+   stored in *ENDPTR.
+   Upon overflow, the return value is ULLONG_MAX, and errno is set to
+   ERANGE.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strtoull rpl_strtoull
+#  endif
+#  define GNULIB_defined_strtoull_function 1
+_GL_FUNCDECL_RPL (strtoull, unsigned long long,
+                  (const char *restrict string, char **restrict endptr,
+                   int base)
+                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strtoull, unsigned long long,
+                  (const char *restrict string, char **restrict endptr,
+                   int base));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (strtoull, unsigned long long,
+                  (const char *restrict string, char **restrict endptr,
+                   int base)
+                  _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (strtoull, unsigned long long,
+                  (const char *restrict string, char **restrict endptr,
+                   int base));
+# endif
+_GL_CXXALIASWARN (strtoull);
+#elif defined GNULIB_POSIXCHECK
+# undef strtoull
+# if HAVE_RAW_DECL_STRTOULL
+_GL_WARN_ON_USE (strtoull, "strtoull is unportable - "
+                 "use gnulib module strtoull for portability");
+# endif
+#endif
+
+#if 0
+/* Unlock the slave side of the pseudo-terminal whose master side is specified
+   by FD, so that it can be opened.  */
+# if !1
+_GL_FUNCDECL_SYS (unlockpt, int, (int fd));
+# endif
+_GL_CXXALIAS_SYS (unlockpt, int, (int fd));
+_GL_CXXALIASWARN (unlockpt);
+#elif defined GNULIB_POSIXCHECK
+# undef unlockpt
+# if HAVE_RAW_DECL_UNLOCKPT
+_GL_WARN_ON_USE (unlockpt, "unlockpt is not portable - "
+                 "use gnulib module unlockpt for portability");
+# endif
+#endif
+
+#if IN_SED_GNULIB_TESTS
+/* Remove the variable NAME from the environment.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef unsetenv
+#   define unsetenv rpl_unsetenv
+#  endif
+_GL_FUNCDECL_RPL (unsetenv, int, (const char *name) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (unsetenv, int, (const char *name));
+# else
+#  if !0
+_GL_FUNCDECL_SYS (unsetenv, int, (const char *name) _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (unsetenv, int, (const char *name));
+# endif
+# if !(0 && !0)
+_GL_CXXALIASWARN (unsetenv);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef unsetenv
+# if HAVE_RAW_DECL_UNSETENV
+_GL_WARN_ON_USE (unsetenv, "unsetenv is unportable - "
+                 "use gnulib module unsetenv for portability");
+# endif
+#endif
+
+/* Convert a wide character to a multibyte character.  */
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wctomb
+#   define wctomb rpl_wctomb
+#  endif
+_GL_FUNCDECL_RPL (wctomb, int, (char *s, wchar_t wc));
+_GL_CXXALIAS_RPL (wctomb, int, (char *s, wchar_t wc));
+# else
+_GL_CXXALIAS_SYS (wctomb, int, (char *s, wchar_t wc));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wctomb);
+# endif
+#endif
+
+
+#endif /* _GL_STDLIB_H */
+#endif /* _GL_STDLIB_H */
+#endif
diff -Naur ../orig/sed-4.9/lib/string.h ./lib/string.h
--- ../orig/sed-4.9/lib/string.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/string.h	2022-12-01 17:14:00.202628600 +0300
@@ -0,0 +1,1805 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A GNU-like <string.h>.
+
+   Copyright (C) 1995-1996, 2001-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#if __GNUC__ >= 3
+
+#endif
+
+
+#if defined _GL_ALREADY_INCLUDING_STRING_H
+/* Special invocation convention:
+   - On OS X/NetBSD we have a sequence of nested includes
+       <string.h> -> <strings.h> -> "string.h"
+     In this situation system _chk variants due to -D_FORTIFY_SOURCE
+     might be used after any replacements defined here.  */
+
+#include ""
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_STRING_H
+
+#define _GL_ALREADY_INCLUDING_STRING_H
+
+/* The include_next requires a split double-inclusion guard.  */
+#include "C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\INCLUDE\string.h"
+
+#undef _GL_ALREADY_INCLUDING_STRING_H
+
+#ifndef _GL_STRING_H
+#define _GL_STRING_H
+
+/* NetBSD 5.0 mis-defines NULL.  */
+#include <stddef.h>
+
+/* MirBSD defines mbslen as a macro.  */
+#if 0 && defined __MirBSD__
+# include <wchar.h>
+#endif
+
+/* NetBSD 5.0 declares strsignal in <unistd.h>, not in <string.h>.  */
+/* But in any case avoid namespace pollution on glibc systems.  */
+#if (0 || defined GNULIB_POSIXCHECK) && defined __NetBSD__ \
+    && ! defined __GLIBC__
+# include <unistd.h>
+#endif
+
+/* AIX 7.2 declares ffsl and ffsll in <strings.h>, not in <string.h>.  */
+/* But in any case avoid namespace pollution on glibc systems.  */
+#if ((0 || 0 || defined GNULIB_POSIXCHECK) \
+     && defined _AIX) \
+    && ! defined __GLIBC__
+# include <strings.h>
+#endif
+
+/* _GL_ATTRIBUTE_DEALLOC (F, I) declares that the function returns pointers
+   that can be freed by passing them as the Ith argument to the
+   function F.  */
+#ifndef _GL_ATTRIBUTE_DEALLOC
+# if __GNUC__ >= 11
+#  define _GL_ATTRIBUTE_DEALLOC(f, i) __attribute__ ((__malloc__ (f, i)))
+# else
+#  define _GL_ATTRIBUTE_DEALLOC(f, i)
+# endif
+#endif
+
+/* _GL_ATTRIBUTE_DEALLOC_FREE declares that the function returns pointers that
+   can be freed via 'free'; it can be used only after declaring 'free'.  */
+/* Applies to: functions.  Cannot be used on inline functions.  */
+#ifndef _GL_ATTRIBUTE_DEALLOC_FREE
+# define _GL_ATTRIBUTE_DEALLOC_FREE _GL_ATTRIBUTE_DEALLOC (free, 1)
+#endif
+
+/* _GL_ATTRIBUTE_MALLOC declares that the function returns a pointer to freshly
+   allocated memory.  */
+/* Applies to: functions.  */
+#ifndef _GL_ATTRIBUTE_MALLOC
+# if __GNUC__ >= 3 || defined __clang__
+#  define _GL_ATTRIBUTE_MALLOC __attribute__ ((__malloc__))
+# else
+#  define _GL_ATTRIBUTE_MALLOC
+# endif
+#endif
+
+/* The __attribute__ feature is available in gcc versions 2.5 and later.
+   The attribute __pure__ was added in gcc 2.96.  */
+#ifndef _GL_ATTRIBUTE_PURE
+# if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96) || defined __clang__
+#  define _GL_ATTRIBUTE_PURE __attribute__ ((__pure__))
+# else
+#  define _GL_ATTRIBUTE_PURE /* empty */
+# endif
+#endif
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA (func, rettype, parameters);
+   is to be used when func is a Microsoft deprecated alias, on native Windows.
+   It declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to _func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_MDA (open, int, (const char *filename, int flags, ...));
+ */
+#define _GL_CXXALIAS_MDA(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_MDA (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#define _GL_CXXALIAS_MDA_CAST(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_CAST_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || defined __clang__
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype_gcc, rettype_clang, parameters_and_attributes, "message")
+   is like _GL_WARN_ON_USE (function, "message"), except that in C++ mode the
+   function is declared with the given prototype, consisting of return type,
+   parameters, and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if !defined __cplusplus
+#  define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+     _GL_WARN_ON_USE (function, msg)
+# else
+#  if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes \
+  __attribute__ ((__warning__ (msg)))
+#  elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_clang function parameters_and_attributes \
+  __attribute__ ((__diagnose_if__ (1, msg, "warning")))
+#  elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes
+#  else /* Unsupported.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  endif
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+/* Make _GL_ATTRIBUTE_DEALLOC_FREE work, even though <stdlib.h> may not have
+   been included yet.  */
+#if 1
+# if (1 && !defined free \
+      && !(defined __cplusplus && defined GNULIB_NAMESPACE))
+/* We can't do '#define free rpl_free' here.  */
+_GL_EXTERN_C void rpl_free (void *);
+#  undef _GL_ATTRIBUTE_DEALLOC_FREE
+#  define _GL_ATTRIBUTE_DEALLOC_FREE _GL_ATTRIBUTE_DEALLOC (rpl_free, 1)
+# else
+#  if defined _MSC_VER && !defined free
+_GL_EXTERN_C
+#   if defined _DLL
+     __declspec (dllimport)
+#   endif
+     void __cdecl free (void *);
+#  else
+#   if defined __cplusplus && (__GLIBC__ + (__GLIBC_MINOR__ >= 14) > 2)
+_GL_EXTERN_C void free (void *) throw ();
+#   else
+_GL_EXTERN_C void free (void *);
+#   endif
+#  endif
+# endif
+#else
+# if defined _MSC_VER && !defined free
+_GL_EXTERN_C
+#   if defined _DLL
+     __declspec (dllimport)
+#   endif
+     void __cdecl free (void *);
+# else
+#  if defined __cplusplus && (__GLIBC__ + (__GLIBC_MINOR__ >= 14) > 2)
+_GL_EXTERN_C void free (void *) throw ();
+#  else
+_GL_EXTERN_C void free (void *);
+#  endif
+# endif
+#endif
+
+/* Clear a block of memory.  The compiler will not delete a call to
+   this function, even if the block is dead after the call.  */
+#if IN_SED_GNULIB_TESTS
+# if ! 0
+_GL_FUNCDECL_SYS (explicit_bzero, void,
+                  (void *__dest, size_t __n) _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (explicit_bzero, void, (void *__dest, size_t __n));
+_GL_CXXALIASWARN (explicit_bzero);
+#elif defined GNULIB_POSIXCHECK
+# undef explicit_bzero
+# if HAVE_RAW_DECL_EXPLICIT_BZERO
+_GL_WARN_ON_USE (explicit_bzero, "explicit_bzero is unportable - "
+                 "use gnulib module explicit_bzero for portability");
+# endif
+#endif
+
+/* Find the index of the least-significant set bit.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (ffsl, int, (long int i));
+# endif
+_GL_CXXALIAS_SYS (ffsl, int, (long int i));
+_GL_CXXALIASWARN (ffsl);
+#elif defined GNULIB_POSIXCHECK
+# undef ffsl
+# if HAVE_RAW_DECL_FFSL
+_GL_WARN_ON_USE (ffsl, "ffsl is not portable - use the ffsl module");
+# endif
+#endif
+
+
+/* Find the index of the least-significant set bit.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define ffsll rpl_ffsll
+#  endif
+_GL_FUNCDECL_RPL (ffsll, int, (long long int i));
+_GL_CXXALIAS_RPL (ffsll, int, (long long int i));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (ffsll, int, (long long int i));
+#  endif
+_GL_CXXALIAS_SYS (ffsll, int, (long long int i));
+# endif
+_GL_CXXALIASWARN (ffsll);
+#elif defined GNULIB_POSIXCHECK
+# undef ffsll
+# if HAVE_RAW_DECL_FFSLL
+_GL_WARN_ON_USE (ffsll, "ffsll is not portable - use the ffsll module");
+# endif
+#endif
+
+
+#if 1
+/* On native Windows, map 'memccpy' to '_memccpy', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::memccpy always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef memccpy
+#   define memccpy _memccpy
+#  endif
+_GL_CXXALIAS_MDA (memccpy, void *,
+                  (void *dest, const void *src, int c, size_t n));
+# else
+_GL_CXXALIAS_SYS (memccpy, void *,
+                  (void *dest, const void *src, int c, size_t n));
+# endif
+_GL_CXXALIASWARN (memccpy);
+#endif
+
+
+/* Return the first instance of C within N bytes of S, or NULL.  */
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef memchr
+#   define memchr rpl_memchr
+#  endif
+_GL_FUNCDECL_RPL (memchr, void *, (void const *__s, int __c, size_t __n)
+                                  _GL_ATTRIBUTE_PURE
+                                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (memchr, void *, (void const *__s, int __c, size_t __n));
+# else
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C" { const void * std::memchr (const void *, int, size_t); }
+       extern "C++" { void * std::memchr (void *, int, size_t); }  */
+_GL_CXXALIAS_SYS_CAST2 (memchr,
+                        void *, (void const *__s, int __c, size_t __n),
+                        void const *, (void const *__s, int __c, size_t __n));
+# endif
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4) \
+         || defined __clang__)
+_GL_CXXALIASWARN1 (memchr, void *, (void *__s, int __c, size_t __n) throw ());
+_GL_CXXALIASWARN1 (memchr, void const *,
+                   (void const *__s, int __c, size_t __n) throw ());
+# elif __GLIBC__ >= 2
+_GL_CXXALIASWARN (memchr);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef memchr
+/* Assume memchr is always declared.  */
+_GL_WARN_ON_USE (memchr, "memchr has platform-specific bugs - "
+                 "use gnulib module memchr for portability" );
+#endif
+
+/* Return the first occurrence of NEEDLE in HAYSTACK.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define memmem rpl_memmem
+#  endif
+_GL_FUNCDECL_RPL (memmem, void *,
+                  (void const *__haystack, size_t __haystack_len,
+                   void const *__needle, size_t __needle_len)
+                  _GL_ATTRIBUTE_PURE
+                  _GL_ARG_NONNULL ((1, 3)));
+_GL_CXXALIAS_RPL (memmem, void *,
+                  (void const *__haystack, size_t __haystack_len,
+                   void const *__needle, size_t __needle_len));
+# else
+#  if ! 1
+_GL_FUNCDECL_SYS (memmem, void *,
+                  (void const *__haystack, size_t __haystack_len,
+                   void const *__needle, size_t __needle_len)
+                  _GL_ATTRIBUTE_PURE
+                  _GL_ARG_NONNULL ((1, 3)));
+#  endif
+_GL_CXXALIAS_SYS (memmem, void *,
+                  (void const *__haystack, size_t __haystack_len,
+                   void const *__needle, size_t __needle_len));
+# endif
+_GL_CXXALIASWARN (memmem);
+#elif defined GNULIB_POSIXCHECK
+# undef memmem
+# if HAVE_RAW_DECL_MEMMEM
+_GL_WARN_ON_USE (memmem, "memmem is unportable and often quadratic - "
+                 "use gnulib module memmem-simple for portability, "
+                 "and module memmem for speed" );
+# endif
+#endif
+
+/* Copy N bytes of SRC to DEST, return pointer to bytes after the
+   last written byte.  */
+#if 1
+# if ! 0
+_GL_FUNCDECL_SYS (mempcpy, void *,
+                  (void *__dest, void const *__src,
+                   size_t __n)
+                  _GL_ARG_NONNULL ((1, 2)));
+# endif
+_GL_CXXALIAS_SYS (mempcpy, void *,
+                  (void *__dest, void const *__src,
+                   size_t __n));
+_GL_CXXALIASWARN (mempcpy);
+#elif defined GNULIB_POSIXCHECK
+# undef mempcpy
+# if HAVE_RAW_DECL_MEMPCPY
+_GL_WARN_ON_USE (mempcpy, "mempcpy is unportable - "
+                 "use gnulib module mempcpy for portability");
+# endif
+#endif
+
+/* Search backwards through a block for a byte (specified as an int).  */
+#if 1
+# if ! 0
+_GL_FUNCDECL_SYS (memrchr, void *, (void const *, int, size_t)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1)));
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" { const void * std::memrchr (const void *, int, size_t); }
+       extern "C++" { void * std::memrchr (void *, int, size_t); }  */
+_GL_CXXALIAS_SYS_CAST2 (memrchr,
+                        void *, (void const *, int, size_t),
+                        void const *, (void const *, int, size_t));
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4) \
+         || defined __clang__)
+_GL_CXXALIASWARN1 (memrchr, void *, (void *, int, size_t) throw ());
+_GL_CXXALIASWARN1 (memrchr, void const *, (void const *, int, size_t) throw ());
+# else
+_GL_CXXALIASWARN (memrchr);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef memrchr
+# if HAVE_RAW_DECL_MEMRCHR
+_GL_WARN_ON_USE (memrchr, "memrchr is unportable - "
+                 "use gnulib module memrchr for portability");
+# endif
+#endif
+
+/* Find the first occurrence of C in S.  More efficient than
+   memchr(S,C,N), at the expense of undefined behavior if C does not
+   occur within N bytes.  */
+#if 1
+# if ! 0
+_GL_FUNCDECL_SYS (rawmemchr, void *, (void const *__s, int __c_in)
+                                     _GL_ATTRIBUTE_PURE
+                                     _GL_ARG_NONNULL ((1)));
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" { const void * std::rawmemchr (const void *, int); }
+       extern "C++" { void * std::rawmemchr (void *, int); }  */
+_GL_CXXALIAS_SYS_CAST2 (rawmemchr,
+                        void *, (void const *__s, int __c_in),
+                        void const *, (void const *__s, int __c_in));
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4) \
+         || defined __clang__)
+_GL_CXXALIASWARN1 (rawmemchr, void *, (void *__s, int __c_in) throw ());
+_GL_CXXALIASWARN1 (rawmemchr, void const *,
+                   (void const *__s, int __c_in) throw ());
+# else
+_GL_CXXALIASWARN (rawmemchr);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef rawmemchr
+# if HAVE_RAW_DECL_RAWMEMCHR
+_GL_WARN_ON_USE (rawmemchr, "rawmemchr is unportable - "
+                 "use gnulib module rawmemchr for portability");
+# endif
+#endif
+
+/* Copy SRC to DST, returning the address of the terminating '\0' in DST.  */
+#if 0
+# if ! 1
+_GL_FUNCDECL_SYS (stpcpy, char *,
+                  (char *__dst, char const *__src)
+                  _GL_ARG_NONNULL ((1, 2)));
+# endif
+_GL_CXXALIAS_SYS (stpcpy, char *,
+                  (char *__dst, char const *__src));
+_GL_CXXALIASWARN (stpcpy);
+#elif defined GNULIB_POSIXCHECK
+# undef stpcpy
+# if HAVE_RAW_DECL_STPCPY
+_GL_WARN_ON_USE (stpcpy, "stpcpy is unportable - "
+                 "use gnulib module stpcpy for portability");
+# endif
+#endif
+
+/* Copy no more than N bytes of SRC to DST, returning a pointer past the
+   last non-NUL byte written into DST.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef stpncpy
+#   define stpncpy rpl_stpncpy
+#  endif
+_GL_FUNCDECL_RPL (stpncpy, char *,
+                  (char *__dst, char const *__src,
+                   size_t __n)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (stpncpy, char *,
+                  (char *__dst, char const *__src,
+                   size_t __n));
+# else
+#  if ! 1
+_GL_FUNCDECL_SYS (stpncpy, char *,
+                  (char *__dst, char const *__src,
+                   size_t __n)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (stpncpy, char *,
+                  (char *__dst, char const *__src,
+                   size_t __n));
+# endif
+_GL_CXXALIASWARN (stpncpy);
+#elif defined GNULIB_POSIXCHECK
+# undef stpncpy
+# if HAVE_RAW_DECL_STPNCPY
+_GL_WARN_ON_USE (stpncpy, "stpncpy is unportable - "
+                 "use gnulib module stpncpy for portability");
+# endif
+#endif
+
+#if defined GNULIB_POSIXCHECK
+/* strchr() does not work with multibyte strings if the locale encoding is
+   GB18030 and the character to be searched is a digit.  */
+# undef strchr
+/* Assume strchr is always declared.  */
+_GL_WARN_ON_USE_CXX (strchr,
+                     const char *, char *, (const char *, int),
+                     "strchr cannot work correctly on character strings "
+                     "in some multibyte locales - "
+                     "use mbschr if you care about internationalization");
+#endif
+
+/* Find the first occurrence of C in S or the final NUL byte.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strchrnul rpl_strchrnul
+#  endif
+_GL_FUNCDECL_RPL (strchrnul, char *, (const char *__s, int __c_in)
+                                     _GL_ATTRIBUTE_PURE
+                                     _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strchrnul, char *,
+                  (const char *str, int ch));
+# else
+#  if ! 1
+_GL_FUNCDECL_SYS (strchrnul, char *, (char const *__s, int __c_in)
+                                     _GL_ATTRIBUTE_PURE
+                                     _GL_ARG_NONNULL ((1)));
+#  endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" { const char * std::strchrnul (const char *, int); }
+       extern "C++" { char * std::strchrnul (char *, int); }  */
+_GL_CXXALIAS_SYS_CAST2 (strchrnul,
+                        char *, (char const *__s, int __c_in),
+                        char const *, (char const *__s, int __c_in));
+# endif
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4) \
+         || defined __clang__)
+_GL_CXXALIASWARN1 (strchrnul, char *, (char *__s, int __c_in) throw ());
+_GL_CXXALIASWARN1 (strchrnul, char const *,
+                   (char const *__s, int __c_in) throw ());
+# else
+_GL_CXXALIASWARN (strchrnul);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strchrnul
+# if HAVE_RAW_DECL_STRCHRNUL
+_GL_WARN_ON_USE (strchrnul, "strchrnul is unportable - "
+                 "use gnulib module strchrnul for portability");
+# endif
+#endif
+
+/* Duplicate S, returning an identical malloc'd string.  */
+#if IN_SED_GNULIB_TESTS
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strdup
+#   define strdup rpl_strdup
+#  endif
+_GL_FUNCDECL_RPL (strdup, char *,
+                  (char const *__s)
+                  _GL_ARG_NONNULL ((1))
+                  _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC_FREE);
+_GL_CXXALIAS_RPL (strdup, char *, (char const *__s));
+# elif defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strdup
+#   define strdup _strdup
+#  endif
+_GL_CXXALIAS_MDA (strdup, char *, (char const *__s));
+# else
+#  if defined __cplusplus && defined GNULIB_NAMESPACE && defined strdup
+    /* strdup exists as a function and as a macro.  Get rid of the macro.  */
+#   undef strdup
+#  endif
+#  if (!1 || __GNUC__ >= 11) && !defined strdup
+_GL_FUNCDECL_SYS (strdup, char *,
+                  (char const *__s)
+                  _GL_ARG_NONNULL ((1))
+                  _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC_FREE);
+#  endif
+_GL_CXXALIAS_SYS (strdup, char *, (char const *__s));
+# endif
+_GL_CXXALIASWARN (strdup);
+#else
+# if __GNUC__ >= 11 && !defined strdup
+/* For -Wmismatched-dealloc: Associate strdup with free or rpl_free.  */
+_GL_FUNCDECL_SYS (strdup, char *,
+                  (char const *__s)
+                  _GL_ARG_NONNULL ((1))
+                  _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC_FREE);
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef strdup
+#  if HAVE_RAW_DECL_STRDUP
+_GL_WARN_ON_USE (strdup, "strdup is unportable - "
+                 "use gnulib module strdup for portability");
+#  endif
+# elif 1
+/* On native Windows, map 'creat' to '_creat', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::strdup always.  */
+#  if defined _WIN32 && !defined __CYGWIN__
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef strdup
+#    define strdup _strdup
+#   endif
+_GL_CXXALIAS_MDA (strdup, char *, (char const *__s));
+#  else
+#   if defined __cplusplus && defined GNULIB_NAMESPACE && defined strdup
+#    undef strdup
+#   endif
+_GL_CXXALIAS_SYS (strdup, char *, (char const *__s));
+#  endif
+_GL_CXXALIASWARN (strdup);
+# endif
+#endif
+
+/* Append no more than N characters from SRC onto DEST.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strncat
+#   define strncat rpl_strncat
+#  endif
+_GL_FUNCDECL_RPL (strncat, char *,
+                  (char *dest, const char *src, size_t n)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (strncat, char *,
+                  (char *dest, const char *src, size_t n));
+# else
+_GL_CXXALIAS_SYS (strncat, char *,
+                  (char *dest, const char *src, size_t n));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (strncat);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strncat
+# if HAVE_RAW_DECL_STRNCAT
+_GL_WARN_ON_USE (strncat, "strncat is unportable - "
+                 "use gnulib module strncat for portability");
+# endif
+#endif
+
+/* Return a newly allocated copy of at most N bytes of STRING.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strndup
+#   define strndup rpl_strndup
+#  endif
+_GL_FUNCDECL_RPL (strndup, char *,
+                  (char const *__s, size_t __n)
+                  _GL_ARG_NONNULL ((1))
+                  _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC_FREE);
+_GL_CXXALIAS_RPL (strndup, char *, (char const *__s, size_t __n));
+# else
+#  if !1 || (__GNUC__ >= 11 && !defined strndup)
+_GL_FUNCDECL_SYS (strndup, char *,
+                  (char const *__s, size_t __n)
+                  _GL_ARG_NONNULL ((1))
+                  _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC_FREE);
+#  endif
+_GL_CXXALIAS_SYS (strndup, char *, (char const *__s, size_t __n));
+# endif
+_GL_CXXALIASWARN (strndup);
+#else
+# if __GNUC__ >= 11 && !defined strndup
+/* For -Wmismatched-dealloc: Associate strndup with free or rpl_free.  */
+_GL_FUNCDECL_SYS (strndup, char *,
+                  (char const *__s, size_t __n)
+                  _GL_ARG_NONNULL ((1))
+                  _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC_FREE);
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef strndup
+#  if HAVE_RAW_DECL_STRNDUP
+_GL_WARN_ON_USE (strndup, "strndup is unportable - "
+                 "use gnulib module strndup for portability");
+#  endif
+# endif
+#endif
+
+/* Find the length (number of bytes) of STRING, but scan at most
+   MAXLEN bytes.  If no '\0' terminator is found in that many bytes,
+   return MAXLEN.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strnlen
+#   define strnlen rpl_strnlen
+#  endif
+_GL_FUNCDECL_RPL (strnlen, size_t, (char const *__s, size_t __maxlen)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strnlen, size_t, (char const *__s, size_t __maxlen));
+# else
+#  if ! 1
+_GL_FUNCDECL_SYS (strnlen, size_t, (char const *__s, size_t __maxlen)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (strnlen, size_t, (char const *__s, size_t __maxlen));
+# endif
+_GL_CXXALIASWARN (strnlen);
+#elif defined GNULIB_POSIXCHECK
+# undef strnlen
+# if HAVE_RAW_DECL_STRNLEN
+_GL_WARN_ON_USE (strnlen, "strnlen is unportable - "
+                 "use gnulib module strnlen for portability");
+# endif
+#endif
+
+#if defined GNULIB_POSIXCHECK
+/* strcspn() assumes the second argument is a list of single-byte characters.
+   Even in this simple case, it does not work with multibyte strings if the
+   locale encoding is GB18030 and one of the characters to be searched is a
+   digit.  */
+# undef strcspn
+/* Assume strcspn is always declared.  */
+_GL_WARN_ON_USE (strcspn, "strcspn cannot work correctly on character strings "
+                 "in multibyte locales - "
+                 "use mbscspn if you care about internationalization");
+#endif
+
+/* Find the first occurrence in S of any character in ACCEPT.  */
+#if 0
+# if ! 1
+_GL_FUNCDECL_SYS (strpbrk, char *, (char const *__s, char const *__accept)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1, 2)));
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C" { const char * strpbrk (const char *, const char *); }
+       extern "C++" { char * strpbrk (char *, const char *); }  */
+_GL_CXXALIAS_SYS_CAST2 (strpbrk,
+                        char *, (char const *__s, char const *__accept),
+                        const char *, (char const *__s, char const *__accept));
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4) \
+         || defined __clang__)
+_GL_CXXALIASWARN1 (strpbrk, char *, (char *__s, char const *__accept) throw ());
+_GL_CXXALIASWARN1 (strpbrk, char const *,
+                   (char const *__s, char const *__accept) throw ());
+# elif __GLIBC__ >= 2
+_GL_CXXALIASWARN (strpbrk);
+# endif
+# if defined GNULIB_POSIXCHECK
+/* strpbrk() assumes the second argument is a list of single-byte characters.
+   Even in this simple case, it does not work with multibyte strings if the
+   locale encoding is GB18030 and one of the characters to be searched is a
+   digit.  */
+#  undef strpbrk
+_GL_WARN_ON_USE_CXX (strpbrk,
+                     const char *, char *, (const char *, const char *),
+                     "strpbrk cannot work correctly on character strings "
+                     "in multibyte locales - "
+                     "use mbspbrk if you care about internationalization");
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strpbrk
+# if HAVE_RAW_DECL_STRPBRK
+_GL_WARN_ON_USE_CXX (strpbrk,
+                     const char *, char *, (const char *, const char *),
+                     "strpbrk is unportable - "
+                     "use gnulib module strpbrk for portability");
+# endif
+#endif
+
+#if defined GNULIB_POSIXCHECK
+/* strspn() assumes the second argument is a list of single-byte characters.
+   Even in this simple case, it cannot work with multibyte strings.  */
+# undef strspn
+/* Assume strspn is always declared.  */
+_GL_WARN_ON_USE (strspn, "strspn cannot work correctly on character strings "
+                 "in multibyte locales - "
+                 "use mbsspn if you care about internationalization");
+#endif
+
+#if defined GNULIB_POSIXCHECK
+/* strrchr() does not work with multibyte strings if the locale encoding is
+   GB18030 and the character to be searched is a digit.  */
+# undef strrchr
+/* Assume strrchr is always declared.  */
+_GL_WARN_ON_USE_CXX (strrchr,
+                     const char *, char *, (const char *, int),
+                     "strrchr cannot work correctly on character strings "
+                     "in some multibyte locales - "
+                     "use mbsrchr if you care about internationalization");
+#endif
+
+/* Search the next delimiter (char listed in DELIM) starting at *STRINGP.
+   If one is found, overwrite it with a NUL, and advance *STRINGP
+   to point to the next char after it.  Otherwise, set *STRINGP to NULL.
+   If *STRINGP was already NULL, nothing happens.
+   Return the old value of *STRINGP.
+
+   This is a variant of strtok() that is multithread-safe and supports
+   empty fields.
+
+   Caveat: It modifies the original string.
+   Caveat: These functions cannot be used on constant strings.
+   Caveat: The identity of the delimiting character is lost.
+   Caveat: It doesn't work with multibyte strings unless all of the delimiter
+           characters are ASCII characters < 0x30.
+
+   See also strtok_r().  */
+#if 0
+# if ! 1
+_GL_FUNCDECL_SYS (strsep, char *,
+                  (char **__stringp, char const *__delim)
+                  _GL_ARG_NONNULL ((1, 2)));
+# endif
+_GL_CXXALIAS_SYS (strsep, char *,
+                  (char **__stringp, char const *__delim));
+_GL_CXXALIASWARN (strsep);
+# if defined GNULIB_POSIXCHECK
+#  undef strsep
+_GL_WARN_ON_USE (strsep, "strsep cannot work correctly on character strings "
+                 "in multibyte locales - "
+                 "use mbssep if you care about internationalization");
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strsep
+# if HAVE_RAW_DECL_STRSEP
+_GL_WARN_ON_USE (strsep, "strsep is unportable - "
+                 "use gnulib module strsep for portability");
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strstr rpl_strstr
+#  endif
+_GL_FUNCDECL_RPL (strstr, char *, (const char *haystack, const char *needle)
+                                  _GL_ATTRIBUTE_PURE
+                                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (strstr, char *, (const char *haystack, const char *needle));
+# else
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" { const char * strstr (const char *, const char *); }
+       extern "C++" { char * strstr (char *, const char *); }  */
+_GL_CXXALIAS_SYS_CAST2 (strstr,
+                        char *, (const char *haystack, const char *needle),
+                        const char *, (const char *haystack, const char *needle));
+# endif
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4) \
+         || defined __clang__)
+_GL_CXXALIASWARN1 (strstr, char *,
+                   (char *haystack, const char *needle) throw ());
+_GL_CXXALIASWARN1 (strstr, const char *,
+                   (const char *haystack, const char *needle) throw ());
+# elif __GLIBC__ >= 2
+_GL_CXXALIASWARN (strstr);
+# endif
+#elif defined GNULIB_POSIXCHECK
+/* strstr() does not work with multibyte strings if the locale encoding is
+   different from UTF-8:
+   POSIX says that it operates on "strings", and "string" in POSIX is defined
+   as a sequence of bytes, not of characters.  */
+# undef strstr
+/* Assume strstr is always declared.  */
+_GL_WARN_ON_USE (strstr, "strstr is quadratic on many systems, and cannot "
+                 "work correctly on character strings in most "
+                 "multibyte locales - "
+                 "use mbsstr if you care about internationalization, "
+                 "or use strstr if you care about speed");
+#endif
+
+/* Find the first occurrence of NEEDLE in HAYSTACK, using case-insensitive
+   comparison.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strcasestr rpl_strcasestr
+#  endif
+_GL_FUNCDECL_RPL (strcasestr, char *,
+                  (const char *haystack, const char *needle)
+                  _GL_ATTRIBUTE_PURE
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (strcasestr, char *,
+                  (const char *haystack, const char *needle));
+# else
+#  if ! 1
+_GL_FUNCDECL_SYS (strcasestr, char *,
+                  (const char *haystack, const char *needle)
+                  _GL_ATTRIBUTE_PURE
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" { const char * strcasestr (const char *, const char *); }
+       extern "C++" { char * strcasestr (char *, const char *); }  */
+_GL_CXXALIAS_SYS_CAST2 (strcasestr,
+                        char *, (const char *haystack, const char *needle),
+                        const char *, (const char *haystack, const char *needle));
+# endif
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4) \
+         || defined __clang__)
+_GL_CXXALIASWARN1 (strcasestr, char *,
+                   (char *haystack, const char *needle) throw ());
+_GL_CXXALIASWARN1 (strcasestr, const char *,
+                   (const char *haystack, const char *needle) throw ());
+# else
+_GL_CXXALIASWARN (strcasestr);
+# endif
+#elif defined GNULIB_POSIXCHECK
+/* strcasestr() does not work with multibyte strings:
+   It is a glibc extension, and glibc implements it only for unibyte
+   locales.  */
+# undef strcasestr
+# if HAVE_RAW_DECL_STRCASESTR
+_GL_WARN_ON_USE (strcasestr, "strcasestr does work correctly on character "
+                 "strings in multibyte locales - "
+                 "use mbscasestr if you care about "
+                 "internationalization, or use c-strcasestr if you want "
+                 "a locale independent function");
+# endif
+#endif
+
+/* Parse S into tokens separated by characters in DELIM.
+   If S is NULL, the saved pointer in SAVE_PTR is used as
+   the next starting point.  For example:
+        char s[] = "-abc-=-def";
+        char *sp;
+        x = strtok_r(s, "-", &sp);      // x = "abc", sp = "=-def"
+        x = strtok_r(NULL, "-=", &sp);  // x = "def", sp = NULL
+        x = strtok_r(NULL, "=", &sp);   // x = NULL
+                // s = "abc\0-def\0"
+
+   This is a variant of strtok() that is multithread-safe.
+
+   For the POSIX documentation for this function, see:
+   https://pubs.opengroup.org/onlinepubs/9699919799/functions/strtok.html
+
+   Caveat: It modifies the original string.
+   Caveat: These functions cannot be used on constant strings.
+   Caveat: The identity of the delimiting character is lost.
+   Caveat: It doesn't work with multibyte strings unless all of the delimiter
+           characters are ASCII characters < 0x30.
+
+   See also strsep().  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strtok_r
+#   define strtok_r rpl_strtok_r
+#  endif
+_GL_FUNCDECL_RPL (strtok_r, char *,
+                  (char *s, char const *delim,
+                   char **save_ptr)
+                  _GL_ARG_NONNULL ((2, 3)));
+_GL_CXXALIAS_RPL (strtok_r, char *,
+                  (char *s, char const *delim,
+                   char **save_ptr));
+# else
+#  if 0 || defined GNULIB_POSIXCHECK
+#   undef strtok_r
+#  endif
+#  if ! 1
+_GL_FUNCDECL_SYS (strtok_r, char *,
+                  (char *s, char const *delim,
+                   char **save_ptr)
+                  _GL_ARG_NONNULL ((2, 3)));
+#  endif
+_GL_CXXALIAS_SYS (strtok_r, char *,
+                  (char *s, char const *delim,
+                   char **save_ptr));
+# endif
+_GL_CXXALIASWARN (strtok_r);
+# if defined GNULIB_POSIXCHECK
+_GL_WARN_ON_USE (strtok_r, "strtok_r cannot work correctly on character "
+                 "strings in multibyte locales - "
+                 "use mbstok_r if you care about internationalization");
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strtok_r
+# if HAVE_RAW_DECL_STRTOK_R
+_GL_WARN_ON_USE (strtok_r, "strtok_r is unportable - "
+                 "use gnulib module strtok_r for portability");
+# endif
+#endif
+
+
+/* The following functions are not specified by POSIX.  They are gnulib
+   extensions.  */
+
+#if 0
+/* Return the number of multibyte characters in the character string STRING.
+   This considers multibyte characters, unlike strlen, which counts bytes.  */
+# ifdef __MirBSD__  /* MirBSD defines mbslen as a macro.  Override it.  */
+#  undef mbslen
+# endif
+# if 0  /* AIX, OSF/1, MirBSD define mbslen already in libc.  */
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define mbslen rpl_mbslen
+#  endif
+_GL_FUNCDECL_RPL (mbslen, size_t, (const char *string)
+                                  _GL_ATTRIBUTE_PURE
+                                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mbslen, size_t, (const char *string));
+# else
+_GL_FUNCDECL_SYS (mbslen, size_t, (const char *string)
+                                  _GL_ATTRIBUTE_PURE
+                                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_SYS (mbslen, size_t, (const char *string));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (mbslen);
+# endif
+#endif
+
+#if 0
+/* Return the number of multibyte characters in the character string starting
+   at STRING and ending at STRING + LEN.  */
+_GL_EXTERN_C size_t mbsnlen (const char *string, size_t len)
+     _GL_ATTRIBUTE_PURE
+     _GL_ARG_NONNULL ((1));
+#endif
+
+#if 0
+/* Locate the first single-byte character C in the character string STRING,
+   and return a pointer to it.  Return NULL if C is not found in STRING.
+   Unlike strchr(), this function works correctly in multibyte locales with
+   encodings such as GB18030.  */
+# if defined __hpux
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define mbschr rpl_mbschr /* avoid collision with HP-UX function */
+#  endif
+_GL_FUNCDECL_RPL (mbschr, char *, (const char *string, int c)
+                                  _GL_ATTRIBUTE_PURE
+                                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mbschr, char *, (const char *string, int c));
+# else
+_GL_FUNCDECL_SYS (mbschr, char *, (const char *string, int c)
+                                  _GL_ATTRIBUTE_PURE
+                                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_SYS (mbschr, char *, (const char *string, int c));
+# endif
+_GL_CXXALIASWARN (mbschr);
+#endif
+
+#if 0
+/* Locate the last single-byte character C in the character string STRING,
+   and return a pointer to it.  Return NULL if C is not found in STRING.
+   Unlike strrchr(), this function works correctly in multibyte locales with
+   encodings such as GB18030.  */
+# if defined __hpux || defined __INTERIX
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define mbsrchr rpl_mbsrchr /* avoid collision with system function */
+#  endif
+_GL_FUNCDECL_RPL (mbsrchr, char *, (const char *string, int c)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mbsrchr, char *, (const char *string, int c));
+# else
+_GL_FUNCDECL_SYS (mbsrchr, char *, (const char *string, int c)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_SYS (mbsrchr, char *, (const char *string, int c));
+# endif
+_GL_CXXALIASWARN (mbsrchr);
+#endif
+
+#if 0
+/* Find the first occurrence of the character string NEEDLE in the character
+   string HAYSTACK.  Return NULL if NEEDLE is not found in HAYSTACK.
+   Unlike strstr(), this function works correctly in multibyte locales with
+   encodings different from UTF-8.  */
+_GL_EXTERN_C char * mbsstr (const char *haystack, const char *needle)
+     _GL_ATTRIBUTE_PURE
+     _GL_ARG_NONNULL ((1, 2));
+#endif
+
+#if 0
+/* Compare the character strings S1 and S2, ignoring case, returning less than,
+   equal to or greater than zero if S1 is lexicographically less than, equal to
+   or greater than S2.
+   Note: This function may, in multibyte locales, return 0 for strings of
+   different lengths!
+   Unlike strcasecmp(), this function works correctly in multibyte locales.  */
+_GL_EXTERN_C int mbscasecmp (const char *s1, const char *s2)
+     _GL_ATTRIBUTE_PURE
+     _GL_ARG_NONNULL ((1, 2));
+#endif
+
+#if 0
+/* Compare the initial segment of the character string S1 consisting of at most
+   N characters with the initial segment of the character string S2 consisting
+   of at most N characters, ignoring case, returning less than, equal to or
+   greater than zero if the initial segment of S1 is lexicographically less
+   than, equal to or greater than the initial segment of S2.
+   Note: This function may, in multibyte locales, return 0 for initial segments
+   of different lengths!
+   Unlike strncasecmp(), this function works correctly in multibyte locales.
+   But beware that N is not a byte count but a character count!  */
+_GL_EXTERN_C int mbsncasecmp (const char *s1, const char *s2, size_t n)
+     _GL_ATTRIBUTE_PURE
+     _GL_ARG_NONNULL ((1, 2));
+#endif
+
+#if 0
+/* Compare the initial segment of the character string STRING consisting of
+   at most mbslen (PREFIX) characters with the character string PREFIX,
+   ignoring case.  If the two match, return a pointer to the first byte
+   after this prefix in STRING.  Otherwise, return NULL.
+   Note: This function may, in multibyte locales, return non-NULL if STRING
+   is of smaller length than PREFIX!
+   Unlike strncasecmp(), this function works correctly in multibyte
+   locales.  */
+_GL_EXTERN_C char * mbspcasecmp (const char *string, const char *prefix)
+     _GL_ATTRIBUTE_PURE
+     _GL_ARG_NONNULL ((1, 2));
+#endif
+
+#if 0
+/* Find the first occurrence of the character string NEEDLE in the character
+   string HAYSTACK, using case-insensitive comparison.
+   Note: This function may, in multibyte locales, return success even if
+   strlen (haystack) < strlen (needle) !
+   Unlike strcasestr(), this function works correctly in multibyte locales.  */
+_GL_EXTERN_C char * mbscasestr (const char *haystack, const char *needle)
+     _GL_ATTRIBUTE_PURE
+     _GL_ARG_NONNULL ((1, 2));
+#endif
+
+#if 0
+/* Find the first occurrence in the character string STRING of any character
+   in the character string ACCEPT.  Return the number of bytes from the
+   beginning of the string to this occurrence, or to the end of the string
+   if none exists.
+   Unlike strcspn(), this function works correctly in multibyte locales.  */
+_GL_EXTERN_C size_t mbscspn (const char *string, const char *accept)
+     _GL_ATTRIBUTE_PURE
+     _GL_ARG_NONNULL ((1, 2));
+#endif
+
+#if 0
+/* Find the first occurrence in the character string STRING of any character
+   in the character string ACCEPT.  Return the pointer to it, or NULL if none
+   exists.
+   Unlike strpbrk(), this function works correctly in multibyte locales.  */
+# if defined __hpux
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define mbspbrk rpl_mbspbrk /* avoid collision with HP-UX function */
+#  endif
+_GL_FUNCDECL_RPL (mbspbrk, char *, (const char *string, const char *accept)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (mbspbrk, char *, (const char *string, const char *accept));
+# else
+_GL_FUNCDECL_SYS (mbspbrk, char *, (const char *string, const char *accept)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_SYS (mbspbrk, char *, (const char *string, const char *accept));
+# endif
+_GL_CXXALIASWARN (mbspbrk);
+#endif
+
+#if 0
+/* Find the first occurrence in the character string STRING of any character
+   not in the character string REJECT.  Return the number of bytes from the
+   beginning of the string to this occurrence, or to the end of the string
+   if none exists.
+   Unlike strspn(), this function works correctly in multibyte locales.  */
+_GL_EXTERN_C size_t mbsspn (const char *string, const char *reject)
+     _GL_ATTRIBUTE_PURE
+     _GL_ARG_NONNULL ((1, 2));
+#endif
+
+#if 0
+/* Search the next delimiter (multibyte character listed in the character
+   string DELIM) starting at the character string *STRINGP.
+   If one is found, overwrite it with a NUL, and advance *STRINGP to point
+   to the next multibyte character after it.  Otherwise, set *STRINGP to NULL.
+   If *STRINGP was already NULL, nothing happens.
+   Return the old value of *STRINGP.
+
+   This is a variant of mbstok_r() that supports empty fields.
+
+   Caveat: It modifies the original string.
+   Caveat: These functions cannot be used on constant strings.
+   Caveat: The identity of the delimiting character is lost.
+
+   See also mbstok_r().  */
+_GL_EXTERN_C char * mbssep (char **stringp, const char *delim)
+     _GL_ARG_NONNULL ((1, 2));
+#endif
+
+#if 0
+/* Parse the character string STRING into tokens separated by characters in
+   the character string DELIM.
+   If STRING is NULL, the saved pointer in SAVE_PTR is used as
+   the next starting point.  For example:
+        char s[] = "-abc-=-def";
+        char *sp;
+        x = mbstok_r(s, "-", &sp);      // x = "abc", sp = "=-def"
+        x = mbstok_r(NULL, "-=", &sp);  // x = "def", sp = NULL
+        x = mbstok_r(NULL, "=", &sp);   // x = NULL
+                // s = "abc\0-def\0"
+
+   Caveat: It modifies the original string.
+   Caveat: These functions cannot be used on constant strings.
+   Caveat: The identity of the delimiting character is lost.
+
+   See also mbssep().  */
+_GL_EXTERN_C char * mbstok_r (char *string, const char *delim,
+                              char **save_ptr)
+     _GL_ARG_NONNULL ((2, 3));
+#endif
+
+/* Map any int, typically from errno, into an error message.  */
+#if 1
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strerror
+#   define strerror rpl_strerror
+#  endif
+_GL_FUNCDECL_RPL (strerror, char *, (int));
+_GL_CXXALIAS_RPL (strerror, char *, (int));
+# else
+_GL_CXXALIAS_SYS (strerror, char *, (int));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (strerror);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strerror
+/* Assume strerror is always declared.  */
+_GL_WARN_ON_USE (strerror, "strerror is unportable - "
+                 "use gnulib module strerror to guarantee non-NULL result");
+#endif
+
+/* Map any int, typically from errno, into an error message.  Multithread-safe.
+   Uses the POSIX declaration, not the glibc declaration.  */
+#if IN_SED_GNULIB_TESTS
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strerror_r
+#   define strerror_r rpl_strerror_r
+#  endif
+_GL_FUNCDECL_RPL (strerror_r, int, (int errnum, char *buf, size_t buflen)
+                                   _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (strerror_r, int, (int errnum, char *buf, size_t buflen));
+# else
+#  if !0
+_GL_FUNCDECL_SYS (strerror_r, int, (int errnum, char *buf, size_t buflen)
+                                   _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (strerror_r, int, (int errnum, char *buf, size_t buflen));
+# endif
+# if 0
+_GL_CXXALIASWARN (strerror_r);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strerror_r
+# if HAVE_RAW_DECL_STRERROR_R
+_GL_WARN_ON_USE (strerror_r, "strerror_r is unportable - "
+                 "use gnulib module strerror_r-posix for portability");
+# endif
+#endif
+
+/* Return the name of the system error code ERRNUM.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strerrorname_np
+#   define strerrorname_np rpl_strerrorname_np
+#  endif
+_GL_FUNCDECL_RPL (strerrorname_np, const char *, (int errnum));
+_GL_CXXALIAS_RPL (strerrorname_np, const char *, (int errnum));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (strerrorname_np, const char *, (int errnum));
+#  endif
+_GL_CXXALIAS_SYS (strerrorname_np, const char *, (int errnum));
+# endif
+_GL_CXXALIASWARN (strerrorname_np);
+#elif defined GNULIB_POSIXCHECK
+# undef strerrorname_np
+# if HAVE_RAW_DECL_STRERRORNAME_NP
+_GL_WARN_ON_USE (strerrorname_np, "strerrorname_np is unportable - "
+                 "use gnulib module strerrorname_np for portability");
+# endif
+#endif
+
+/* Return an abbreviation string for the signal number SIG.  */
+#if 0
+# if ! 1
+_GL_FUNCDECL_SYS (sigabbrev_np, const char *, (int sig));
+# endif
+_GL_CXXALIAS_SYS (sigabbrev_np, const char *, (int sig));
+_GL_CXXALIASWARN (sigabbrev_np);
+#elif defined GNULIB_POSIXCHECK
+# undef sigabbrev_np
+# if HAVE_RAW_DECL_SIGABBREV_NP
+_GL_WARN_ON_USE (sigabbrev_np, "sigabbrev_np is unportable - "
+                 "use gnulib module sigabbrev_np for portability");
+# endif
+#endif
+
+/* Return an English description string for the signal number SIG.  */
+#if 0
+# if ! 1
+_GL_FUNCDECL_SYS (sigdescr_np, const char *, (int sig));
+# endif
+_GL_CXXALIAS_SYS (sigdescr_np, const char *, (int sig));
+_GL_CXXALIASWARN (sigdescr_np);
+#elif defined GNULIB_POSIXCHECK
+# undef sigdescr_np
+# if HAVE_RAW_DECL_SIGDESCR_NP
+_GL_WARN_ON_USE (sigdescr_np, "sigdescr_np is unportable - "
+                 "use gnulib module sigdescr_np for portability");
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strsignal rpl_strsignal
+#  endif
+_GL_FUNCDECL_RPL (strsignal, char *, (int __sig));
+_GL_CXXALIAS_RPL (strsignal, char *, (int __sig));
+# else
+#  if ! 1
+_GL_FUNCDECL_SYS (strsignal, char *, (int __sig));
+#  endif
+/* Need to cast, because on Cygwin 1.5.x systems, the return type is
+   'const char *'.  */
+_GL_CXXALIAS_SYS_CAST (strsignal, char *, (int __sig));
+# endif
+_GL_CXXALIASWARN (strsignal);
+#elif defined GNULIB_POSIXCHECK
+# undef strsignal
+# if HAVE_RAW_DECL_STRSIGNAL
+_GL_WARN_ON_USE (strsignal, "strsignal is unportable - "
+                 "use gnulib module strsignal for portability");
+# endif
+#endif
+
+#if 1
+# if !0
+_GL_FUNCDECL_SYS (strverscmp, int, (const char *, const char *)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1, 2)));
+# endif
+_GL_CXXALIAS_SYS (strverscmp, int, (const char *, const char *));
+_GL_CXXALIASWARN (strverscmp);
+#elif defined GNULIB_POSIXCHECK
+# undef strverscmp
+# if HAVE_RAW_DECL_STRVERSCMP
+_GL_WARN_ON_USE (strverscmp, "strverscmp is unportable - "
+                 "use gnulib module strverscmp for portability");
+# endif
+#endif
+
+
+#endif /* _GL_STRING_H */
+#endif /* _GL_STRING_H */
+#endif
diff -Naur ../orig/sed-4.9/lib/strverscmp.c ./lib/strverscmp.c
--- ../orig/sed-4.9/lib/strverscmp.c	2022-07-02 21:22:03.000000000 +0300
+++ ./lib/strverscmp.c	2022-12-01 17:13:49.505208100 +0300
@@ -73,6 +73,7 @@
   if (p1 == p2)
     return 0;
 
+  {
   unsigned char c1 = *p1++;
   unsigned char c2 = *p2++;
   /* Hint: '0' is a digit too.  */
@@ -107,6 +108,7 @@
     default:
       return state;
   }
+  }
 }
 libc_hidden_def (__strverscmp)
 weak_alias (__strverscmp, strverscmp)
diff -Naur ../orig/sed-4.9/lib/sys/random.h ./lib/sys/random.h
--- ../orig/sed-4.9/lib/sys/random.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/sys/random.h	2022-12-01 17:12:58.276207600 +0300
@@ -0,0 +1,607 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Substitute for <sys/random.h>.
+   Copyright (C) 2020-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+# if __GNUC__ >= 3
+
+# endif
+
+
+#ifndef _GL_SYS_RANDOM_H
+
+#if 0
+
+/* On uClibc < 1.0.35, <sys/random.h> assumes prior inclusion of <stddef.h>.
+   Do not use __UCLIBC__ here, as it might not be defined yet.
+   But avoid namespace pollution on glibc systems.  */
+# ifndef __GLIBC__
+#  include <stddef.h>
+# endif
+/* On Mac OS X 10.5, <sys/random.h> assumes prior inclusion of <sys/types.h>.
+   On Max OS X 10.13, <sys/random.h> assumes prior inclusion of a file that
+   includes <Availability.h>, such as <stdlib.h> or <unistd.h>.  */
+# if defined __APPLE__ && defined __MACH__                  /* Mac OS X */
+#  include <sys/types.h>
+#  include <stdlib.h>
+# endif
+
+/* The include_next requires a split double-inclusion guard.  */
+# include ""
+
+#endif
+
+#ifndef _GL_SYS_RANDOM_H
+#define _GL_SYS_RANDOM_H
+
+#include <sys/types.h>
+
+/* Define the GRND_* constants.  */
+#ifndef GRND_NONBLOCK
+# define GRND_NONBLOCK 1
+# define GRND_RANDOM 2
+#endif
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA (func, rettype, parameters);
+   is to be used when func is a Microsoft deprecated alias, on native Windows.
+   It declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to _func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_MDA (open, int, (const char *filename, int flags, ...));
+ */
+#define _GL_CXXALIAS_MDA(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_MDA (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#define _GL_CXXALIAS_MDA_CAST(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_CAST_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || defined __clang__
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype_gcc, rettype_clang, parameters_and_attributes, "message")
+   is like _GL_WARN_ON_USE (function, "message"), except that in C++ mode the
+   function is declared with the given prototype, consisting of return type,
+   parameters, and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if !defined __cplusplus
+#  define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+     _GL_WARN_ON_USE (function, msg)
+# else
+#  if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes \
+  __attribute__ ((__warning__ (msg)))
+#  elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_clang function parameters_and_attributes \
+  __attribute__ ((__diagnose_if__ (1, msg, "warning")))
+#  elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes
+#  else /* Unsupported.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  endif
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+
+/* Declare overridden functions.  */
+
+
+#if 1
+/* Fill a buffer with random bytes.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getrandom
+#   define getrandom rpl_getrandom
+#  endif
+_GL_FUNCDECL_RPL (getrandom, ssize_t,
+                  (void *buffer, size_t length, unsigned int flags)
+                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (getrandom, ssize_t,
+                  (void *buffer, size_t length, unsigned int flags));
+# else
+#  if !0
+_GL_FUNCDECL_SYS (getrandom, ssize_t,
+                  (void *buffer, size_t length, unsigned int flags)
+                  _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (getrandom, ssize_t,
+                  (void *buffer, size_t length, unsigned int flags));
+# endif
+# if __GLIBC__ + (__GLIBC_MINOR__ >= 25) > 2
+_GL_CXXALIASWARN (getrandom);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef getrandom
+# if HAVE_RAW_DECL_GETRANDOM
+_GL_WARN_ON_USE (getrandom, "getrandom is unportable - "
+                 "use gnulib module getrandom for portability");
+# endif
+#endif
+
+
+#endif /* _GL_SYS_RANDOM_H */
+#endif /* _GL_SYS_RANDOM_H */
diff -Naur ../orig/sed-4.9/lib/sys/stat.h ./lib/sys/stat.h
--- ../orig/sed-4.9/lib/sys/stat.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/sys/stat.h	2022-12-01 17:13:19.149986300 +0300
@@ -0,0 +1,1461 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Provide a more complete sys/stat.h header file.
+   Copyright (C) 2005-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* Written by Eric Blake, Paul Eggert, and Jim Meyering.  */
+
+/* This file is supposed to be used on platforms where <sys/stat.h> is
+   incomplete.  It is intended to provide definitions and prototypes
+   needed by an application.  Start with what the system provides.  */
+
+#if __GNUC__ >= 3
+
+#endif
+
+
+#if defined __need_system_sys_stat_h
+/* Special invocation convention.  */
+
+#include ""
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_SYS_STAT_H
+
+/* Get nlink_t.
+   May also define off_t to a 64-bit type on native Windows.  */
+#include <sys/types.h>
+
+/* Get struct timespec.  */
+#include <time.h>
+
+/* The include_next requires a split double-inclusion guard.  */
+#include "C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\INCLUDE\sys\stat.h"
+
+#ifndef _GL_SYS_STAT_H
+#define _GL_SYS_STAT_H
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA (func, rettype, parameters);
+   is to be used when func is a Microsoft deprecated alias, on native Windows.
+   It declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to _func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_MDA (open, int, (const char *filename, int flags, ...));
+ */
+#define _GL_CXXALIAS_MDA(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_MDA (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#define _GL_CXXALIAS_MDA_CAST(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_CAST_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || defined __clang__
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype_gcc, rettype_clang, parameters_and_attributes, "message")
+   is like _GL_WARN_ON_USE (function, "message"), except that in C++ mode the
+   function is declared with the given prototype, consisting of return type,
+   parameters, and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if !defined __cplusplus
+#  define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+     _GL_WARN_ON_USE (function, msg)
+# else
+#  if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes \
+  __attribute__ ((__warning__ (msg)))
+#  elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_clang function parameters_and_attributes \
+  __attribute__ ((__diagnose_if__ (1, msg, "warning")))
+#  elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes
+#  else /* Unsupported.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  endif
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+/* Before doing "#define mknod rpl_mknod" below, we need to include all
+   headers that may declare mknod().  OS/2 kLIBC declares mknod() in
+   <unistd.h>, not in <sys/stat.h>.  */
+#ifdef __KLIBC__
+# include <unistd.h>
+#endif
+
+/* Before doing "#define mkdir rpl_mkdir" below, we need to include all
+   headers that may declare mkdir().  Native Windows platforms declare mkdir
+   in <io.h> and/or <direct.h>, not in <sys/stat.h>.  */
+#if defined _WIN32 && ! defined __CYGWIN__
+# include <io.h>     /* mingw32, mingw64 */
+# include <direct.h> /* mingw64, MSVC 9 */
+#endif
+
+/* Native Windows platforms declare umask() in <io.h>.  */
+#if 0 && (defined _WIN32 && ! defined __CYGWIN__)
+# include <io.h>
+#endif
+
+/* Large File Support on native Windows.  */
+#if 0
+# define stat _stati64
+#endif
+
+/* Optionally, override 'struct stat' on native Windows.  */
+#if 0
+
+# undef stat
+# if 1
+#  define stat rpl_stat
+# else
+   /* Provoke a clear link error if stat() is used as a function and
+      module 'stat' is not in use.  */
+#  define stat stat_used_without_requesting_gnulib_module_stat
+# endif
+
+# if !GNULIB_defined_struct_stat
+struct stat
+{
+  dev_t st_dev;
+  ino_t st_ino;
+  mode_t st_mode;
+  nlink_t st_nlink;
+#  if 0
+  uid_t st_uid;
+#  else /* uid_t is not defined by default on native Windows.  */
+  short st_uid;
+#  endif
+#  if 0
+  gid_t st_gid;
+#  else /* gid_t is not defined by default on native Windows.  */
+  short st_gid;
+#  endif
+  dev_t st_rdev;
+  off_t st_size;
+#  if 0
+  blksize_t st_blksize;
+  blkcnt_t st_blocks;
+#  endif
+
+#  if 0
+  struct timespec st_atim;
+  struct timespec st_mtim;
+  struct timespec st_ctim;
+#  else
+  time_t st_atime;
+  time_t st_mtime;
+  time_t st_ctime;
+#  endif
+};
+#  if 0
+#   define st_atime st_atim.tv_sec
+#   define st_mtime st_mtim.tv_sec
+#   define st_ctime st_ctim.tv_sec
+    /* Indicator, for gnulib internal purposes.  */
+#   define _GL_WINDOWS_STAT_TIMESPEC 1
+#  endif
+#  define GNULIB_defined_struct_stat 1
+# endif
+
+/* Other possible values of st_mode.  */
+# if 0
+#  define _S_IFBLK  0x6000
+# endif
+# if 0
+#  define _S_IFLNK  0xA000
+# endif
+# if 0
+#  define _S_IFSOCK 0xC000
+# endif
+
+#endif
+
+#ifndef S_IFIFO
+# ifdef _S_IFIFO
+#  define S_IFIFO _S_IFIFO
+# endif
+#endif
+
+#ifndef S_IFMT
+# define S_IFMT 0170000
+#endif
+
+#if STAT_MACROS_BROKEN
+# undef S_ISBLK
+# undef S_ISCHR
+# undef S_ISDIR
+# undef S_ISFIFO
+# undef S_ISLNK
+# undef S_ISNAM
+# undef S_ISMPB
+# undef S_ISMPC
+# undef S_ISNWK
+# undef S_ISREG
+# undef S_ISSOCK
+#endif
+
+#ifndef S_ISBLK
+# ifdef S_IFBLK
+#  define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
+# else
+#  define S_ISBLK(m) 0
+# endif
+#endif
+
+#ifndef S_ISCHR
+# ifdef S_IFCHR
+#  define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
+# else
+#  define S_ISCHR(m) 0
+# endif
+#endif
+
+#ifndef S_ISDIR
+# ifdef S_IFDIR
+#  define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
+# else
+#  define S_ISDIR(m) 0
+# endif
+#endif
+
+#ifndef S_ISDOOR /* Solaris 2.5 and up */
+# define S_ISDOOR(m) 0
+#endif
+
+#ifndef S_ISFIFO
+# ifdef S_IFIFO
+#  define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
+# else
+#  define S_ISFIFO(m) 0
+# endif
+#endif
+
+#ifndef S_ISLNK
+# ifdef S_IFLNK
+#  define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
+# else
+#  define S_ISLNK(m) 0
+# endif
+#endif
+
+#ifndef S_ISMPB /* V7 */
+# ifdef S_IFMPB
+#  define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
+#  define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
+# else
+#  define S_ISMPB(m) 0
+#  define S_ISMPC(m) 0
+# endif
+#endif
+
+#ifndef S_ISMPX /* AIX */
+# define S_ISMPX(m) 0
+#endif
+
+#ifndef S_ISNAM /* Xenix */
+# ifdef S_IFNAM
+#  define S_ISNAM(m) (((m) & S_IFMT) == S_IFNAM)
+# else
+#  define S_ISNAM(m) 0
+# endif
+#endif
+
+#ifndef S_ISNWK /* HP/UX */
+# ifdef S_IFNWK
+#  define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
+# else
+#  define S_ISNWK(m) 0
+# endif
+#endif
+
+#ifndef S_ISPORT /* Solaris 10 and up */
+# define S_ISPORT(m) 0
+#endif
+
+#ifndef S_ISREG
+# ifdef S_IFREG
+#  define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
+# else
+#  define S_ISREG(m) 0
+# endif
+#endif
+
+#ifndef S_ISSOCK
+# ifdef S_IFSOCK
+#  define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
+# else
+#  define S_ISSOCK(m) 0
+# endif
+#endif
+
+
+#ifndef S_TYPEISMQ
+# define S_TYPEISMQ(p) 0
+#endif
+
+#ifndef S_TYPEISTMO
+# define S_TYPEISTMO(p) 0
+#endif
+
+
+#ifndef S_TYPEISSEM
+# ifdef S_INSEM
+#  define S_TYPEISSEM(p) (S_ISNAM ((p)->st_mode) && (p)->st_rdev == S_INSEM)
+# else
+#  define S_TYPEISSEM(p) 0
+# endif
+#endif
+
+#ifndef S_TYPEISSHM
+# ifdef S_INSHD
+#  define S_TYPEISSHM(p) (S_ISNAM ((p)->st_mode) && (p)->st_rdev == S_INSHD)
+# else
+#  define S_TYPEISSHM(p) 0
+# endif
+#endif
+
+/* high performance ("contiguous data") */
+#ifndef S_ISCTG
+# define S_ISCTG(p) 0
+#endif
+
+/* Cray DMF (data migration facility): off line, with data  */
+#ifndef S_ISOFD
+# define S_ISOFD(p) 0
+#endif
+
+/* Cray DMF (data migration facility): off line, with no data  */
+#ifndef S_ISOFL
+# define S_ISOFL(p) 0
+#endif
+
+/* 4.4BSD whiteout */
+#ifndef S_ISWHT
+# define S_ISWHT(m) 0
+#endif
+
+/* If any of the following are undefined,
+   define them to their de facto standard values.  */
+#if !S_ISUID
+# define S_ISUID 04000
+#endif
+#if !S_ISGID
+# define S_ISGID 02000
+#endif
+
+/* S_ISVTX is a common extension to POSIX.  */
+#ifndef S_ISVTX
+# define S_ISVTX 01000
+#endif
+
+#if !S_IRUSR && S_IREAD
+# define S_IRUSR S_IREAD
+#endif
+#if !S_IRUSR
+# define S_IRUSR 00400
+#endif
+#if !S_IRGRP
+# define S_IRGRP (S_IRUSR >> 3)
+#endif
+#if !S_IROTH
+# define S_IROTH (S_IRUSR >> 6)
+#endif
+
+#if !S_IWUSR && S_IWRITE
+# define S_IWUSR S_IWRITE
+#endif
+#if !S_IWUSR
+# define S_IWUSR 00200
+#endif
+#if !S_IWGRP
+# define S_IWGRP (S_IWUSR >> 3)
+#endif
+#if !S_IWOTH
+# define S_IWOTH (S_IWUSR >> 6)
+#endif
+
+#if !S_IXUSR && S_IEXEC
+# define S_IXUSR S_IEXEC
+#endif
+#if !S_IXUSR
+# define S_IXUSR 00100
+#endif
+#if !S_IXGRP
+# define S_IXGRP (S_IXUSR >> 3)
+#endif
+#if !S_IXOTH
+# define S_IXOTH (S_IXUSR >> 6)
+#endif
+
+#if !S_IRWXU
+# define S_IRWXU (S_IRUSR | S_IWUSR | S_IXUSR)
+#endif
+#if !S_IRWXG
+# define S_IRWXG (S_IRGRP | S_IWGRP | S_IXGRP)
+#endif
+#if !S_IRWXO
+# define S_IRWXO (S_IROTH | S_IWOTH | S_IXOTH)
+#endif
+
+/* Although S_IXUGO and S_IRWXUGO are not specified by POSIX and are
+   not implemented in GNU/Linux, some Gnulib-using apps use the macros.  */
+#if !S_IXUGO
+# define S_IXUGO (S_IXUSR | S_IXGRP | S_IXOTH)
+#endif
+#ifndef S_IRWXUGO
+# define S_IRWXUGO (S_IRWXU | S_IRWXG | S_IRWXO)
+#endif
+
+/* Macros for futimens and utimensat.  */
+#ifndef UTIME_NOW
+# define UTIME_NOW (-1)
+# define UTIME_OMIT (-2)
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef chmod
+#   define chmod rpl_chmod
+#  endif
+_GL_FUNCDECL_RPL (chmod, int, (const char *filename, mode_t mode)
+                               _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (chmod, int, (const char *filename, mode_t mode));
+# elif defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef chmod
+#   define chmod _chmod
+#  endif
+/* Need to cast, because in mingw the last argument is 'int mode'.  */
+_GL_CXXALIAS_MDA_CAST (chmod, int, (const char *filename, mode_t mode));
+# else
+_GL_CXXALIAS_SYS (chmod, int, (const char *filename, mode_t mode));
+# endif
+_GL_CXXALIASWARN (chmod);
+#elif defined GNULIB_POSIXCHECK
+# undef chmod
+# if HAVE_RAW_DECL_CHMOD
+_GL_WARN_ON_USE (chmod, "chmod has portability problems - "
+                 "use gnulib module chmod for portability");
+# endif
+#elif 1
+/* On native Windows, map 'chmod' to '_chmod', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::chmod always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef chmod
+#   define chmod _chmod
+#  endif
+/* Need to cast, because in mingw the last argument is 'int mode'.  */
+_GL_CXXALIAS_MDA_CAST (chmod, int, (const char *filename, mode_t mode));
+# else
+_GL_CXXALIAS_SYS (chmod, int, (const char *filename, mode_t mode));
+# endif
+_GL_CXXALIASWARN (chmod);
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fchmodat
+#   define fchmodat rpl_fchmodat
+#  endif
+_GL_FUNCDECL_RPL (fchmodat, int,
+                  (int fd, char const *file, mode_t mode, int flag)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (fchmodat, int,
+                  (int fd, char const *file, mode_t mode, int flag));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (fchmodat, int,
+                  (int fd, char const *file, mode_t mode, int flag)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (fchmodat, int,
+                  (int fd, char const *file, mode_t mode, int flag));
+# endif
+_GL_CXXALIASWARN (fchmodat);
+#elif defined GNULIB_POSIXCHECK
+# undef fchmodat
+# if HAVE_RAW_DECL_FCHMODAT
+_GL_WARN_ON_USE (fchmodat, "fchmodat is not portable - "
+                 "use gnulib module openat for portability");
+# endif
+#endif
+
+
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fstat
+#   define fstat rpl_fstat
+#  endif
+_GL_FUNCDECL_RPL (fstat, int, (int fd, struct stat *buf) _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (fstat, int, (int fd, struct stat *buf));
+# else
+_GL_CXXALIAS_SYS (fstat, int, (int fd, struct stat *buf));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (fstat);
+# endif
+#elif 0
+# undef fstat
+# define fstat fstat_used_without_requesting_gnulib_module_fstat
+#elif 0
+/* Above, we define stat to _stati64.  */
+# define fstat _fstati64
+#elif defined GNULIB_POSIXCHECK
+# undef fstat
+# if HAVE_RAW_DECL_FSTAT
+_GL_WARN_ON_USE (fstat, "fstat has portability problems - "
+                 "use gnulib module fstat for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fstatat
+#   define fstatat rpl_fstatat
+#  endif
+_GL_FUNCDECL_RPL (fstatat, int,
+                  (int fd, char const *restrict name, struct stat *restrict st,
+                   int flags)
+                  _GL_ARG_NONNULL ((2, 3)));
+_GL_CXXALIAS_RPL (fstatat, int,
+                  (int fd, char const *restrict name, struct stat *restrict st,
+                   int flags));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (fstatat, int,
+                  (int fd, char const *restrict name, struct stat *restrict st,
+                   int flags)
+                  _GL_ARG_NONNULL ((2, 3)));
+#  endif
+_GL_CXXALIAS_SYS (fstatat, int,
+                  (int fd, char const *restrict name, struct stat *restrict st,
+                   int flags));
+# endif
+_GL_CXXALIASWARN (fstatat);
+#elif 0
+# undef fstatat
+# define fstatat fstatat_used_without_requesting_gnulib_module_fstatat
+#elif defined GNULIB_POSIXCHECK
+# undef fstatat
+# if HAVE_RAW_DECL_FSTATAT
+_GL_WARN_ON_USE (fstatat, "fstatat is not portable - "
+                 "use gnulib module openat for portability");
+# endif
+#endif
+
+
+#if 0
+/* Use the rpl_ prefix also on Solaris <= 9, because on Solaris 9 our futimens
+   implementation relies on futimesat, which on Solaris 10 makes an invocation
+   to futimens that is meant to invoke the libc's futimens(), not gnulib's
+   futimens().  */
+# if 0 || (!1 && defined __sun)
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef futimens
+#   define futimens rpl_futimens
+#  endif
+_GL_FUNCDECL_RPL (futimens, int, (int fd, struct timespec const times[2]));
+_GL_CXXALIAS_RPL (futimens, int, (int fd, struct timespec const times[2]));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (futimens, int, (int fd, struct timespec const times[2]));
+#  endif
+_GL_CXXALIAS_SYS (futimens, int, (int fd, struct timespec const times[2]));
+# endif
+# if 1
+_GL_CXXALIASWARN (futimens);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef futimens
+# if HAVE_RAW_DECL_FUTIMENS
+_GL_WARN_ON_USE (futimens, "futimens is not portable - "
+                 "use gnulib module futimens for portability");
+# endif
+#endif
+
+
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (getumask, mode_t, (void));
+# endif
+_GL_CXXALIAS_SYS (getumask, mode_t, (void));
+# if 1
+_GL_CXXALIASWARN (getumask);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef getumask
+# if HAVE_RAW_DECL_GETUMASK
+_GL_WARN_ON_USE (getumask, "getumask is not portable - "
+                 "use gnulib module getumask for portability");
+# endif
+#endif
+
+
+#if 0
+/* Change the mode of FILENAME to MODE, without dereferencing it if FILENAME
+   denotes a symbolic link.  */
+# if !1 || defined __hpux
+_GL_FUNCDECL_SYS (lchmod, int, (const char *filename, mode_t mode)
+                               _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (lchmod, int, (const char *filename, mode_t mode));
+_GL_CXXALIASWARN (lchmod);
+#elif defined GNULIB_POSIXCHECK
+# undef lchmod
+# if HAVE_RAW_DECL_LCHMOD
+_GL_WARN_ON_USE (lchmod, "lchmod is unportable - "
+                 "use gnulib module lchmod for portability");
+# endif
+#endif
+
+
+#if 1
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mkdir
+#   define mkdir rpl_mkdir
+#  endif
+_GL_FUNCDECL_RPL (mkdir, int, (char const *name, mode_t mode)
+                               _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mkdir, int, (char const *name, mode_t mode));
+# elif defined _WIN32 && !defined __CYGWIN__
+/* mingw's _mkdir() function has 1 argument, but we pass 2 arguments.
+   Additionally, it declares _mkdir (and depending on compile flags, an
+   alias mkdir), only in the nonstandard includes <direct.h> and <io.h>,
+   which are included above.  */
+#  if !GNULIB_defined_rpl_mkdir
+static int
+rpl_mkdir (char const *name, mode_t mode)
+{
+  return _mkdir (name);
+}
+#   define GNULIB_defined_rpl_mkdir 1
+#  endif
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mkdir
+#   define mkdir rpl_mkdir
+#  endif
+_GL_CXXALIAS_RPL (mkdir, int, (char const *name, mode_t mode));
+# else
+_GL_CXXALIAS_SYS (mkdir, int, (char const *name, mode_t mode));
+# endif
+_GL_CXXALIASWARN (mkdir);
+#elif defined GNULIB_POSIXCHECK
+# undef mkdir
+# if HAVE_RAW_DECL_MKDIR
+_GL_WARN_ON_USE (mkdir, "mkdir does not always support two parameters - "
+                 "use gnulib module mkdir for portability");
+# endif
+#elif 1
+/* On native Windows, map 'mkdir' to '_mkdir', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::mkdir always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !GNULIB_defined_rpl_mkdir
+static int
+rpl_mkdir (char const *name, mode_t mode)
+{
+  return _mkdir (name);
+}
+#   define GNULIB_defined_rpl_mkdir 1
+#  endif
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mkdir
+#   define mkdir rpl_mkdir
+#  endif
+_GL_CXXALIAS_RPL (mkdir, int, (char const *name, mode_t mode));
+# else
+_GL_CXXALIAS_SYS (mkdir, int, (char const *name, mode_t mode));
+# endif
+_GL_CXXALIASWARN (mkdir);
+#endif
+
+
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (mkdirat, int, (int fd, char const *file, mode_t mode)
+                                _GL_ARG_NONNULL ((2)));
+# endif
+_GL_CXXALIAS_SYS (mkdirat, int, (int fd, char const *file, mode_t mode));
+_GL_CXXALIASWARN (mkdirat);
+#elif defined GNULIB_POSIXCHECK
+# undef mkdirat
+# if HAVE_RAW_DECL_MKDIRAT
+_GL_WARN_ON_USE (mkdirat, "mkdirat is not portable - "
+                 "use gnulib module openat for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mkfifo
+#   define mkfifo rpl_mkfifo
+#  endif
+_GL_FUNCDECL_RPL (mkfifo, int, (char const *file, mode_t mode)
+                               _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mkfifo, int, (char const *file, mode_t mode));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (mkfifo, int, (char const *file, mode_t mode)
+                               _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (mkfifo, int, (char const *file, mode_t mode));
+# endif
+_GL_CXXALIASWARN (mkfifo);
+#elif defined GNULIB_POSIXCHECK
+# undef mkfifo
+# if HAVE_RAW_DECL_MKFIFO
+_GL_WARN_ON_USE (mkfifo, "mkfifo is not portable - "
+                 "use gnulib module mkfifo for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mkfifoat
+#   define mkfifoat rpl_mkfifoat
+#  endif
+_GL_FUNCDECL_RPL (mkfifoat, int, (int fd, char const *file, mode_t mode)
+                                 _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (mkfifoat, int, (int fd, char const *file, mode_t mode));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (mkfifoat, int, (int fd, char const *file, mode_t mode)
+                                 _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (mkfifoat, int, (int fd, char const *file, mode_t mode));
+# endif
+_GL_CXXALIASWARN (mkfifoat);
+#elif defined GNULIB_POSIXCHECK
+# undef mkfifoat
+# if HAVE_RAW_DECL_MKFIFOAT
+_GL_WARN_ON_USE (mkfifoat, "mkfifoat is not portable - "
+                 "use gnulib module mkfifoat for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mknod
+#   define mknod rpl_mknod
+#  endif
+_GL_FUNCDECL_RPL (mknod, int, (char const *file, mode_t mode, dev_t dev)
+                              _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mknod, int, (char const *file, mode_t mode, dev_t dev));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (mknod, int, (char const *file, mode_t mode, dev_t dev)
+                              _GL_ARG_NONNULL ((1)));
+#  endif
+/* Need to cast, because on OSF/1 5.1, the third parameter is '...'.  */
+_GL_CXXALIAS_SYS_CAST (mknod, int, (char const *file, mode_t mode, dev_t dev));
+# endif
+_GL_CXXALIASWARN (mknod);
+#elif defined GNULIB_POSIXCHECK
+# undef mknod
+# if HAVE_RAW_DECL_MKNOD
+_GL_WARN_ON_USE (mknod, "mknod is not portable - "
+                 "use gnulib module mknod for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mknodat
+#   define mknodat rpl_mknodat
+#  endif
+_GL_FUNCDECL_RPL (mknodat, int,
+                  (int fd, char const *file, mode_t mode, dev_t dev)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (mknodat, int,
+                  (int fd, char const *file, mode_t mode, dev_t dev));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (mknodat, int,
+                  (int fd, char const *file, mode_t mode, dev_t dev)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (mknodat, int,
+                  (int fd, char const *file, mode_t mode, dev_t dev));
+# endif
+_GL_CXXALIASWARN (mknodat);
+#elif defined GNULIB_POSIXCHECK
+# undef mknodat
+# if HAVE_RAW_DECL_MKNODAT
+_GL_WARN_ON_USE (mknodat, "mknodat is not portable - "
+                 "use gnulib module mkfifoat for portability");
+# endif
+#endif
+
+
+#if 1
+# if 0
+#  if !0
+    /* We can't use the object-like #define stat rpl_stat, because of
+       struct stat.  This means that rpl_stat will not be used if the user
+       does (stat)(a,b).  Oh well.  */
+#   if defined _AIX && defined stat && defined _LARGE_FILES
+     /* With _LARGE_FILES defined, AIX (only) defines stat to stat64,
+        so we have to replace stat64() instead of stat(). */
+#    undef stat64
+#    define stat64(name, st) rpl_stat (name, st)
+#   elif 0
+     /* Above, we define stat to _stati64.  */
+#    if defined __MINGW32__ && defined _stati64
+#     ifndef _USE_32BIT_TIME_T
+       /* The system headers define _stati64 to _stat64.  */
+#      undef _stat64
+#      define _stat64(name, st) rpl_stat (name, st)
+#     endif
+#    elif defined _MSC_VER && defined _stati64
+#     ifdef _USE_32BIT_TIME_T
+       /* The system headers define _stati64 to _stat32i64.  */
+#      undef _stat32i64
+#      define _stat32i64(name, st) rpl_stat (name, st)
+#     else
+       /* The system headers define _stati64 to _stat64.  */
+#      undef _stat64
+#      define _stat64(name, st) rpl_stat (name, st)
+#     endif
+#    else
+#     undef _stati64
+#     define _stati64(name, st) rpl_stat (name, st)
+#    endif
+#   elif defined __MINGW32__ && defined stat
+#    ifdef _USE_32BIT_TIME_T
+      /* The system headers define stat to _stat32i64.  */
+#     undef _stat32i64
+#     define _stat32i64(name, st) rpl_stat (name, st)
+#    else
+      /* The system headers define stat to _stat64.  */
+#     undef _stat64
+#     define _stat64(name, st) rpl_stat (name, st)
+#    endif
+#   elif defined _MSC_VER && defined stat
+#    ifdef _USE_32BIT_TIME_T
+      /* The system headers define stat to _stat32.  */
+#     undef _stat32
+#     define _stat32(name, st) rpl_stat (name, st)
+#    else
+      /* The system headers define stat to _stat64i32.  */
+#     undef _stat64i32
+#     define _stat64i32(name, st) rpl_stat (name, st)
+#    endif
+#   else /* !(_AIX || __MINGW32__ || _MSC_VER) */
+#    undef stat
+#    define stat(name, st) rpl_stat (name, st)
+#   endif /* !_LARGE_FILES */
+#  endif /* !0 */
+_GL_EXTERN_C int stat (const char *restrict name, struct stat *restrict buf)
+                      _GL_ARG_NONNULL ((1, 2));
+# endif
+#elif 0
+/* see above:
+  #define stat stat_used_without_requesting_gnulib_module_stat
+ */
+#elif defined GNULIB_POSIXCHECK
+# undef stat
+# if HAVE_RAW_DECL_STAT
+_GL_WARN_ON_USE (stat, "stat is unportable - "
+                 "use gnulib module stat for portability");
+# endif
+#endif
+
+
+#if 1
+# if ! 0
+/* mingw does not support symlinks, therefore it does not have lstat.  But
+   without links, stat does just fine.  */
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define lstat stat
+#  endif
+_GL_CXXALIAS_RPL_1 (lstat, stat, int,
+                    (const char *restrict name, struct stat *restrict buf));
+# elif 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef lstat
+#   define lstat rpl_lstat
+#  endif
+_GL_FUNCDECL_RPL (lstat, int,
+                  (const char *restrict name, struct stat *restrict buf)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (lstat, int,
+                  (const char *restrict name, struct stat *restrict buf));
+# else
+_GL_CXXALIAS_SYS (lstat, int,
+                  (const char *restrict name, struct stat *restrict buf));
+# endif
+# if 0
+_GL_CXXALIASWARN (lstat);
+# endif
+#elif 0
+# undef lstat
+# define lstat lstat_used_without_requesting_gnulib_module_lstat
+#elif defined GNULIB_POSIXCHECK
+# undef lstat
+# if HAVE_RAW_DECL_LSTAT
+_GL_WARN_ON_USE (lstat, "lstat is unportable - "
+                 "use gnulib module lstat for portability");
+# endif
+#endif
+
+
+#if 1
+/* On native Windows, map 'umask' to '_umask', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::umask always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef umask
+#   define umask _umask
+#  endif
+/* Need to cast, because in mingw the last argument is 'int mode'.  */
+_GL_CXXALIAS_MDA_CAST (umask, mode_t, (mode_t mask));
+# else
+_GL_CXXALIAS_SYS (umask, mode_t, (mode_t mask));
+# endif
+_GL_CXXALIASWARN (umask);
+#endif
+
+
+#if 0
+/* Use the rpl_ prefix also on Solaris <= 9, because on Solaris 9 our utimensat
+   implementation relies on futimesat, which on Solaris 10 makes an invocation
+   to utimensat that is meant to invoke the libc's utimensat(), not gnulib's
+   utimensat().  */
+# if 0 || (!1 && defined __sun)
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef utimensat
+#   define utimensat rpl_utimensat
+#  endif
+_GL_FUNCDECL_RPL (utimensat, int, (int fd, char const *name,
+                                   struct timespec const times[2], int flag)
+                                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (utimensat, int, (int fd, char const *name,
+                                   struct timespec const times[2], int flag));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (utimensat, int, (int fd, char const *name,
+                                   struct timespec const times[2], int flag)
+                                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (utimensat, int, (int fd, char const *name,
+                                   struct timespec const times[2], int flag));
+# endif
+# if 1
+_GL_CXXALIASWARN (utimensat);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef utimensat
+# if HAVE_RAW_DECL_UTIMENSAT
+_GL_WARN_ON_USE (utimensat, "utimensat is not portable - "
+                 "use gnulib module utimensat for portability");
+# endif
+#endif
+
+
+#endif /* _GL_SYS_STAT_H */
+#endif /* _GL_SYS_STAT_H */
+#endif
diff -Naur ../orig/sed-4.9/lib/sys/types.h ./lib/sys/types.h
--- ../orig/sed-4.9/lib/sys/types.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/sys/types.h	2022-12-01 17:13:19.159986400 +0300
@@ -0,0 +1,107 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Provide a more complete sys/types.h.
+
+   Copyright (C) 2011-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#if __GNUC__ >= 3
+
+#endif
+
+
+#if defined _WIN32 && !defined __CYGWIN__ \
+    && (defined __need_off_t || defined __need___off64_t \
+        || defined __need_ssize_t || defined __need_time_t)
+
+/* Special invocation convention inside mingw header files.  */
+
+#include ""
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_SYS_TYPES_H
+
+/* The include_next requires a split double-inclusion guard.  */
+# define _GL_INCLUDING_SYS_TYPES_H
+#include "C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\INCLUDE\sys\types.h"
+# undef _GL_INCLUDING_SYS_TYPES_H
+
+#ifndef _GL_SYS_TYPES_H
+#define _GL_SYS_TYPES_H
+
+/* Override off_t if Large File Support is requested on native Windows.  */
+#if 0
+/* Same as int64_t in <stdint.h>.  */
+# if defined _MSC_VER
+#  define off_t __int64
+# else
+#  define off_t long long int
+# endif
+/* Indicator, for gnulib internal purposes.  */
+# define _GL_WINDOWS_64_BIT_OFF_T 1
+#endif
+
+/* Override dev_t and ino_t if distinguishable inodes support is requested
+   on native Windows.  */
+#if 0
+
+# if 0 == 2
+/* Experimental, not useful in Windows 10.  */
+
+/* Define dev_t to a 64-bit type.  */
+#  if !defined GNULIB_defined_dev_t
+typedef unsigned long long int rpl_dev_t;
+#   undef dev_t
+#   define dev_t rpl_dev_t
+#   define GNULIB_defined_dev_t 1
+#  endif
+
+/* Define ino_t to a 128-bit type.  */
+#  if !defined GNULIB_defined_ino_t
+/* MSVC does not have a 128-bit integer type.
+   GCC has a 128-bit integer type __int128, but only on 64-bit targets.  */
+typedef struct { unsigned long long int _gl_ino[2]; } rpl_ino_t;
+#   undef ino_t
+#   define ino_t rpl_ino_t
+#   define GNULIB_defined_ino_t 1
+#  endif
+
+# else /* 0 == 1 */
+
+/* Define ino_t to a 64-bit type.  */
+#  if !defined GNULIB_defined_ino_t
+typedef unsigned long long int rpl_ino_t;
+#   undef ino_t
+#   define ino_t rpl_ino_t
+#   define GNULIB_defined_ino_t 1
+#  endif
+
+# endif
+
+/* Indicator, for gnulib internal purposes.  */
+# define _GL_WINDOWS_STAT_INODES 0
+
+#endif
+
+/* MSVC 9 defines size_t in <stddef.h>, not in <sys/types.h>.  */
+/* But avoid namespace pollution on glibc systems.  */
+#if (defined _WIN32 && ! defined __CYGWIN__) && ! defined __GLIBC__
+# include <stddef.h>
+#endif
+
+#endif /* _GL_SYS_TYPES_H */
+#endif /* _GL_SYS_TYPES_H */
+#endif /* __need_XXX */
diff -Naur ../orig/sed-4.9/lib/tempname.c ./lib/tempname.c
--- ../orig/sed-4.9/lib/tempname.c	2022-10-09 17:42:28.000000000 +0300
+++ ./lib/tempname.c	2022-12-01 17:13:49.510208400 +0300
@@ -92,6 +92,8 @@
 static bool
 random_bits (random_value *r, random_value s)
 {
+  random_value v;
+
   /* Without GRND_NONBLOCK it can be blocked for minutes on some systems.  */
   if (__getrandom (r, sizeof *r, GRND_NONBLOCK) == sizeof *r)
     return true;
@@ -104,7 +106,7 @@
 
      Of course we are in a state of sin here.  */
 
-  random_value v = s;
+  v = s;
 
 #if _LIBC || (defined CLOCK_REALTIME && HAVE_CLOCK_GETTIME)
   struct __timespec64 tv;
@@ -174,10 +176,11 @@
 {
   static int (*const tryfunc[]) (char *, void *) =
     {
-      [__GT_FILE] = try_file,
-      [__GT_DIR] = try_dir,
-      [__GT_NOCREATE] = try_nocreate
+      /*[__GT_FILE]* = */try_file,
+      /*[__GT_DIR] = */try_dir,
+      /*[__GT_NOCREATE] = */try_nocreate
     };
+  (void)sizeof(int[1-2*(__GT_FILE != 0 || __GT_DIR != 1 || __GT_NOCREATE != 2)]);
   return try_tempname_len (tmpl, suffixlen, &flags, tryfunc[kind],
                            x_suffix_len);
 }
@@ -238,7 +241,8 @@
 
   for (count = 0; count < attempts; ++count)
     {
-      for (size_t i = 0; i < x_suffix_len; i++)
+      size_t i;
+      for (i = 0; i < x_suffix_len; i++)
         {
           if (vdigits == 0)
             {
diff -Naur ../orig/sed-4.9/lib/time.h ./lib/time.h
--- ../orig/sed-4.9/lib/time.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/time.h	2022-12-01 17:13:19.159986400 +0300
@@ -0,0 +1,963 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A more-standard <time.h>.
+
+   Copyright (C) 2007-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#if __GNUC__ >= 3
+
+#endif
+
+
+/* Don't get in the way of glibc when it includes time.h merely to
+   declare a few standard symbols, rather than to declare all the
+   symbols.  (However, skip this for MinGW as it treats __need_time_t
+   incompatibly.)  Also, Solaris 8 <time.h> eventually includes itself
+   recursively; if that is happening, just include the system <time.h>
+   without adding our own declarations.  */
+#if (((defined __need_time_t || defined __need_clock_t \
+       || defined __need_timespec)                     \
+      && !defined __MINGW32__)                         \
+     || defined _GL_TIME_H)
+
+# include "C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\INCLUDE\time.h"
+
+#else
+
+# define _GL_TIME_H
+
+/* mingw's <time.h> provides the functions asctime_r, ctime_r, gmtime_r,
+   localtime_r only if <unistd.h> or <pthread.h> has been included before.  */
+# if defined __MINGW32__
+#  include <unistd.h>
+# endif
+
+# include "C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\INCLUDE\time.h"
+
+/* NetBSD 5.0 mis-defines NULL.  */
+# include <stddef.h>
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA (func, rettype, parameters);
+   is to be used when func is a Microsoft deprecated alias, on native Windows.
+   It declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to _func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_MDA (open, int, (const char *filename, int flags, ...));
+ */
+#define _GL_CXXALIAS_MDA(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_MDA (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#define _GL_CXXALIAS_MDA_CAST(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_CAST_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || defined __clang__
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype_gcc, rettype_clang, parameters_and_attributes, "message")
+   is like _GL_WARN_ON_USE (function, "message"), except that in C++ mode the
+   function is declared with the given prototype, consisting of return type,
+   parameters, and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if !defined __cplusplus
+#  define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+     _GL_WARN_ON_USE (function, msg)
+# else
+#  if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes \
+  __attribute__ ((__warning__ (msg)))
+#  elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_clang function parameters_and_attributes \
+  __attribute__ ((__diagnose_if__ (1, msg, "warning")))
+#  elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes
+#  else /* Unsupported.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  endif
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+/* Some systems don't define struct timespec (e.g., AIX 4.1).
+   Or they define it with the wrong member names or define it in <sys/time.h>
+   (e.g., FreeBSD circa 1997).  Stock Mingw prior to 3.0 does not define it,
+   but the pthreads-win32 library defines it in <pthread.h>.  */
+# if ! 0
+#  if 0
+#   include <sys/time.h>
+#  elif 0
+#   include <pthread.h>
+#  elif 0
+#   include <unistd.h>
+#  else
+
+#   ifdef __cplusplus
+extern "C" {
+#   endif
+
+#   if !GNULIB_defined_struct_timespec
+#    undef timespec
+#    define timespec rpl_timespec
+struct timespec
+{
+  time_t tv_sec;
+  long int tv_nsec;
+};
+#    define GNULIB_defined_struct_timespec 1
+#   endif
+
+#   ifdef __cplusplus
+}
+#   endif
+
+#  endif
+# endif
+
+# if !GNULIB_defined_struct_time_t_must_be_integral
+/* https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_types.h.html
+   requires time_t to be an integer type, even though C99 permits floating
+   point.  We don't know of any implementation that uses floating
+   point, and it is much easier to write code that doesn't have to
+   worry about that corner case, so we force the issue.  */
+struct __time_t_must_be_integral {
+  unsigned int __floating_time_t_unsupported : (time_t) 1;
+};
+#  define GNULIB_defined_struct_time_t_must_be_integral 1
+# endif
+
+/* Define TIME_UTC, a positive integer constant used for timespec_get().  */
+# if ! 0
+#  if !GNULIB_defined_TIME_UTC
+#   define TIME_UTC 1
+#   define GNULIB_defined_TIME_UTC 1
+#  endif
+# endif
+
+/* Set *TS to the current time, and return BASE.
+   Upon failure, return 0.  */
+# if 0
+#  if ! 1
+_GL_FUNCDECL_SYS (timespec_get, int, (struct timespec *ts, int base)
+                                     _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (timespec_get, int, (struct timespec *ts, int base));
+_GL_CXXALIASWARN (timespec_get);
+# endif
+
+/* Set *TS to the current time resolution, and return BASE.
+   Upon failure, return 0.  */
+# if 0
+#  if ! 1
+_GL_FUNCDECL_SYS (timespec_getres, int, (struct timespec *ts, int base)
+                                        _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (timespec_getres, int, (struct timespec *ts, int base));
+_GL_CXXALIASWARN (timespec_getres);
+# endif
+
+/* Sleep for at least RQTP seconds unless interrupted,  If interrupted,
+   return -1 and store the remaining time into RMTP.  See
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/nanosleep.html>.  */
+# if IN_SED_GNULIB_TESTS
+#  if GNULIB_PORTCHECK
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    define nanosleep rpl_nanosleep
+#   endif
+_GL_FUNCDECL_RPL (nanosleep, int,
+                  (struct timespec const *__rqtp, struct timespec *__rmtp)
+                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (nanosleep, int,
+                  (struct timespec const *__rqtp, struct timespec *__rmtp));
+#  else
+#   if ! 0
+_GL_FUNCDECL_SYS (nanosleep, int,
+                  (struct timespec const *__rqtp, struct timespec *__rmtp)
+                  _GL_ARG_NONNULL ((1)));
+#   endif
+_GL_CXXALIAS_SYS (nanosleep, int,
+                  (struct timespec const *__rqtp, struct timespec *__rmtp));
+#  endif
+_GL_CXXALIASWARN (nanosleep);
+# endif
+
+/* Initialize time conversion information.  */
+# if 0
+#  if GNULIB_PORTCHECK
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef tzset
+#    define tzset rpl_tzset
+#   endif
+_GL_FUNCDECL_RPL (tzset, void, (void));
+_GL_CXXALIAS_RPL (tzset, void, (void));
+#  elif defined _WIN32 && !defined __CYGWIN__
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef tzset
+#    define tzset _tzset
+#   endif
+_GL_CXXALIAS_MDA (tzset, void, (void));
+#  else
+_GL_CXXALIAS_SYS (tzset, void, (void));
+#  endif
+_GL_CXXALIASWARN (tzset);
+# elif 1
+/* On native Windows, map 'tzset' to '_tzset', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::tzset always.  */
+#  if defined _WIN32 && !defined __CYGWIN__
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef tzset
+#    define tzset _tzset
+#   endif
+_GL_CXXALIAS_MDA (tzset, void, (void));
+#  else
+_GL_CXXALIAS_SYS (tzset, void, (void));
+#  endif
+_GL_CXXALIASWARN (tzset);
+# endif
+
+/* Return the 'time_t' representation of TP and normalize TP.  */
+# if 0
+#  if GNULIB_PORTCHECK
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    define mktime rpl_mktime
+#   endif
+_GL_FUNCDECL_RPL (mktime, time_t, (struct tm *__tp) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mktime, time_t, (struct tm *__tp));
+#  else
+_GL_CXXALIAS_SYS (mktime, time_t, (struct tm *__tp));
+#  endif
+#  if __GLIBC__ >= 2
+_GL_CXXALIASWARN (mktime);
+#  endif
+# endif
+
+/* Convert TIMER to RESULT, assuming local time and UTC respectively.  See
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/localtime_r.html> and
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/gmtime_r.html>.  */
+# if 0
+#  if GNULIB_PORTCHECK
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef localtime_r
+#    define localtime_r rpl_localtime_r
+#   endif
+_GL_FUNCDECL_RPL (localtime_r, struct tm *, (time_t const *restrict __timer,
+                                             struct tm *restrict __result)
+                                            _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (localtime_r, struct tm *, (time_t const *restrict __timer,
+                                             struct tm *restrict __result));
+#  else
+#   if ! 1
+_GL_FUNCDECL_SYS (localtime_r, struct tm *, (time_t const *restrict __timer,
+                                             struct tm *restrict __result)
+                                            _GL_ARG_NONNULL ((1, 2)));
+#   endif
+_GL_CXXALIAS_SYS (localtime_r, struct tm *, (time_t const *restrict __timer,
+                                             struct tm *restrict __result));
+#  endif
+#  if 1
+_GL_CXXALIASWARN (localtime_r);
+#  endif
+#  if GNULIB_PORTCHECK
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef gmtime_r
+#    define gmtime_r rpl_gmtime_r
+#   endif
+_GL_FUNCDECL_RPL (gmtime_r, struct tm *, (time_t const *restrict __timer,
+                                          struct tm *restrict __result)
+                                         _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (gmtime_r, struct tm *, (time_t const *restrict __timer,
+                                          struct tm *restrict __result));
+#  else
+#   if ! 1
+_GL_FUNCDECL_SYS (gmtime_r, struct tm *, (time_t const *restrict __timer,
+                                          struct tm *restrict __result)
+                                         _GL_ARG_NONNULL ((1, 2)));
+#   endif
+_GL_CXXALIAS_SYS (gmtime_r, struct tm *, (time_t const *restrict __timer,
+                                          struct tm *restrict __result));
+#  endif
+#  if 1
+_GL_CXXALIASWARN (gmtime_r);
+#  endif
+# endif
+
+/* Convert TIMER to RESULT, assuming local time and UTC respectively.  See
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/localtime.html> and
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/gmtime.html>.  */
+# if 0 || 0
+#  if 0
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef localtime
+#    define localtime rpl_localtime
+#   endif
+_GL_FUNCDECL_RPL (localtime, struct tm *, (time_t const *__timer)
+                                          _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (localtime, struct tm *, (time_t const *__timer));
+#  else
+_GL_CXXALIAS_SYS (localtime, struct tm *, (time_t const *__timer));
+#  endif
+#  if __GLIBC__ >= 2
+_GL_CXXALIASWARN (localtime);
+#  endif
+# endif
+
+# if 0 || 0
+#  if 0
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef gmtime
+#    define gmtime rpl_gmtime
+#   endif
+_GL_FUNCDECL_RPL (gmtime, struct tm *, (time_t const *__timer)
+                                       _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (gmtime, struct tm *, (time_t const *__timer));
+#  else
+_GL_CXXALIAS_SYS (gmtime, struct tm *, (time_t const *__timer));
+#  endif
+_GL_CXXALIASWARN (gmtime);
+# endif
+
+/* Parse BUF as a timestamp, assuming FORMAT specifies its layout, and store
+   the resulting broken-down time into TM.  See
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/strptime.html>.  */
+# if 0
+#  if ! 1
+_GL_FUNCDECL_SYS (strptime, char *, (char const *restrict __buf,
+                                     char const *restrict __format,
+                                     struct tm *restrict __tm)
+                                    _GL_ARG_NONNULL ((1, 2, 3)));
+#  endif
+_GL_CXXALIAS_SYS (strptime, char *, (char const *restrict __buf,
+                                     char const *restrict __format,
+                                     struct tm *restrict __tm));
+_GL_CXXALIASWARN (strptime);
+# endif
+
+/* Convert *TP to a date and time string.  See
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/ctime.html>.  */
+# if 0
+#  if GNULIB_PORTCHECK
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    define ctime rpl_ctime
+#   endif
+_GL_FUNCDECL_RPL (ctime, char *, (time_t const *__tp)
+                                 _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (ctime, char *, (time_t const *__tp));
+#  else
+_GL_CXXALIAS_SYS (ctime, char *, (time_t const *__tp));
+#  endif
+#  if __GLIBC__ >= 2
+_GL_CXXALIASWARN (ctime);
+#  endif
+# endif
+
+/* Convert *TP to a date and time string.  See
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/strftime.html>.  */
+# if 0
+#  if GNULIB_PORTCHECK
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    define strftime rpl_strftime
+#   endif
+_GL_FUNCDECL_RPL (strftime, size_t,
+                  (char *restrict __buf, size_t __bufsize,
+                   const char *restrict __fmt, const struct tm *restrict __tp)
+                  _GL_ARG_NONNULL ((1, 3, 4)));
+_GL_CXXALIAS_RPL (strftime, size_t,
+                  (char *restrict __buf, size_t __bufsize,
+                   const char *restrict __fmt, const struct tm *restrict __tp));
+#  else
+_GL_CXXALIAS_SYS (strftime, size_t,
+                  (char *restrict __buf, size_t __bufsize,
+                   const char *restrict __fmt, const struct tm *restrict __tp));
+#  endif
+#  if __GLIBC__ >= 2
+_GL_CXXALIASWARN (strftime);
+#  endif
+# endif
+
+# if defined _GNU_SOURCE && 0 && ! 0
+/* Functions that use a first-class time zone data type, instead of
+   relying on an implicit global time zone.
+   Inspired by NetBSD.  */
+
+/* Represents a time zone.
+   (timezone_t) NULL stands for UTC.  */
+typedef struct tm_zone *timezone_t;
+
+/* tzalloc (name)
+   Returns a time zone object for the given time zone NAME.  This object
+   represents the time zone that other functions would use it the TZ
+   environment variable was set to NAME.
+   If NAME is NULL, the result represents the time zone that other functions
+   would use it the TZ environment variable was unset.
+   May return NULL if NAME is invalid (this is platform dependent) or
+   upon memory allocation failure.  */
+_GL_FUNCDECL_SYS (tzalloc, timezone_t, (char const *__name));
+_GL_CXXALIAS_SYS (tzalloc, timezone_t, (char const *__name));
+
+/* tzfree (tz)
+   Frees a time zone object.
+   The argument must have been returned by tzalloc().  */
+_GL_FUNCDECL_SYS (tzfree, void, (timezone_t __tz));
+_GL_CXXALIAS_SYS (tzfree, void, (timezone_t __tz));
+
+/* localtime_rz (tz, &t, &result)
+   Converts an absolute time T to a broken-down time RESULT, assuming the
+   time zone TZ.
+   This function is like 'localtime_r', but relies on the argument TZ instead
+   of an implicit global time zone.  */
+_GL_FUNCDECL_SYS (localtime_rz, struct tm *,
+                  (timezone_t __tz, time_t const *restrict __timer,
+                   struct tm *restrict __result) _GL_ARG_NONNULL ((2, 3)));
+_GL_CXXALIAS_SYS (localtime_rz, struct tm *,
+                  (timezone_t __tz, time_t const *restrict __timer,
+                   struct tm *restrict __result));
+
+/* mktime_z (tz, &tm)
+   Normalizes the broken-down time TM and converts it to an absolute time,
+   assuming the time zone TZ.  Returns the absolute time.
+   This function is like 'mktime', but relies on the argument TZ instead
+   of an implicit global time zone.  */
+_GL_FUNCDECL_SYS (mktime_z, time_t,
+                  (timezone_t __tz, struct tm *restrict __tm)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_SYS (mktime_z, time_t,
+                  (timezone_t __tz, struct tm *restrict __tm));
+
+/* Time zone abbreviation strings (returned by 'localtime_rz' or 'mktime_z'
+   in the 'tm_zone' member of 'struct tm') are valid as long as
+     - the 'struct tm' argument is not destroyed or overwritten,
+   and
+     - the 'timezone_t' argument is not freed through tzfree().  */
+
+# endif
+
+/* Convert TM to a time_t value, assuming UTC.  */
+# if 0
+#  if GNULIB_PORTCHECK
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef timegm
+#    define timegm rpl_timegm
+#   endif
+_GL_FUNCDECL_RPL (timegm, time_t, (struct tm *__tm) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (timegm, time_t, (struct tm *__tm));
+#  else
+#   if ! 1
+_GL_FUNCDECL_SYS (timegm, time_t, (struct tm *__tm) _GL_ARG_NONNULL ((1)));
+#   endif
+_GL_CXXALIAS_SYS (timegm, time_t, (struct tm *__tm));
+#  endif
+_GL_CXXALIASWARN (timegm);
+# endif
+
+/* Encourage applications to avoid unsafe functions that can overrun
+   buffers when given outlandish struct tm values.  Portable
+   applications should use strftime (or even sprintf) instead.  */
+# if defined GNULIB_POSIXCHECK
+#  undef asctime
+_GL_WARN_ON_USE (asctime, "asctime can overrun buffers in some cases - "
+                 "better use strftime (or even sprintf) instead");
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef asctime_r
+#  if HAVE_RAW_DECL_ASCTIME_R
+_GL_WARN_ON_USE (asctime_r, "asctime_r can overrun buffers in some cases - "
+                 "better use strftime (or even sprintf) instead");
+#  endif
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef ctime
+_GL_WARN_ON_USE (ctime, "ctime can overrun buffers in some cases - "
+                 "better use strftime (or even sprintf) instead");
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef ctime_r
+#  if HAVE_RAW_DECL_CTIME_R
+_GL_WARN_ON_USE (ctime_r, "ctime_r can overrun buffers in some cases - "
+                 "better use strftime (or even sprintf) instead");
+#  endif
+# endif
+
+#endif
diff -Naur ../orig/sed-4.9/lib/unistd.h ./lib/unistd.h
--- ../orig/sed-4.9/lib/unistd.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/unistd.h	2022-12-01 17:12:59.289233700 +0300
@@ -0,0 +1,2836 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Substitute for and wrapper around <unistd.h>.
+   Copyright (C) 2003-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_UNISTD_H
+
+#if __GNUC__ >= 3
+
+#endif
+
+
+#if 0 && defined _GL_INCLUDING_UNISTD_H
+/* Special invocation convention:
+   - On Mac OS X 10.3.9 we have a sequence of nested includes
+     <unistd.h> -> <signal.h> -> <pthread.h> -> <unistd.h>
+     In this situation, the functions are not yet declared, therefore we cannot
+     provide the C++ aliases.  */
+
+#include ""
+
+#else
+/* Normal invocation convention.  */
+
+/* The include_next requires a split double-inclusion guard.  */
+#if 0
+# define _GL_INCLUDING_UNISTD_H
+# include ""
+# undef _GL_INCLUDING_UNISTD_H
+#endif
+
+/* Get all possible declarations of gethostname().  */
+#if 0 && 1 \
+  && !defined _GL_INCLUDING_WINSOCK2_H
+# define _GL_INCLUDING_WINSOCK2_H
+# include <winsock2.h>
+# undef _GL_INCLUDING_WINSOCK2_H
+#endif
+
+#if !defined _GL_UNISTD_H && !defined _GL_INCLUDING_WINSOCK2_H
+#define _GL_UNISTD_H
+
+/* NetBSD 5.0 mis-defines NULL.  Also get size_t.  */
+/* But avoid namespace pollution on glibc systems.  */
+#ifndef __GLIBC__
+# include <stddef.h>
+#endif
+
+/* mingw doesn't define the SEEK_* or *_FILENO macros in <unistd.h>.  */
+/* MSVC declares 'unlink' in <stdio.h>, not in <unistd.h>.  We must include
+   it before we  #define unlink rpl_unlink.  */
+/* Cygwin 1.7.1 declares symlinkat in <stdio.h>, not in <unistd.h>.  */
+/* But avoid namespace pollution on glibc systems.  */
+#if (!(defined SEEK_CUR && defined SEEK_END && defined SEEK_SET) \
+     || ((0 || defined GNULIB_POSIXCHECK) \
+         && (defined _WIN32 && ! defined __CYGWIN__)) \
+     || ((0 || defined GNULIB_POSIXCHECK) \
+         && defined __CYGWIN__)) \
+    && ! defined __GLIBC__
+# include <stdio.h>
+#endif
+
+/* Cygwin 1.7.1 and Android 4.3 declare unlinkat in <fcntl.h>, not in
+   <unistd.h>.  */
+/* But avoid namespace pollution on glibc systems.  */
+#if (0 || defined GNULIB_POSIXCHECK) \
+    && (defined __CYGWIN__ || defined __ANDROID__) \
+    && ! defined __GLIBC__
+# include <fcntl.h>
+#endif
+
+/* mingw fails to declare _exit in <unistd.h>.  */
+/* mingw, MSVC, BeOS, Haiku declare environ in <stdlib.h>, not in
+   <unistd.h>.  */
+/* Solaris declares getcwd not only in <unistd.h> but also in <stdlib.h>.  */
+/* OSF Tru64 Unix cannot see gnulib rpl_strtod when system <stdlib.h> is
+   included here.  */
+/* But avoid namespace pollution on glibc systems.  */
+#if !defined __GLIBC__ && !defined __osf__
+# define __need_system_stdlib_h
+# include <stdlib.h>
+# undef __need_system_stdlib_h
+#endif
+
+/* Native Windows platforms declare _chdir, _getcwd, _rmdir in
+   <io.h> and/or <direct.h>, not in <unistd.h>.
+   They also declare _access(), _chmod(), _close(), _dup(), _dup2(), _isatty(),
+   _lseek(), _read(), _unlink(), _write() in <io.h>.  */
+#if defined _WIN32 && !defined __CYGWIN__
+# include <io.h>
+# include <direct.h>
+#endif
+
+/* Native Windows platforms declare _execl*, _execv* in <process.h>.  */
+#if defined _WIN32 && !defined __CYGWIN__
+# include <process.h>
+#endif
+
+/* AIX and OSF/1 5.1 declare getdomainname in <netdb.h>, not in <unistd.h>.
+   NonStop Kernel declares gethostname in <netdb.h>, not in <unistd.h>.  */
+/* But avoid namespace pollution on glibc systems.  */
+#if ((0 && (defined _AIX || defined __osf__)) \
+     || (0 && defined __TANDEM)) \
+    && !defined __GLIBC__
+# include <netdb.h>
+#endif
+
+/* Mac OS X 10.13, Solaris 11.4, and Android 9.0 declare getentropy in
+   <sys/random.h>, not in <unistd.h>.  */
+/* But avoid namespace pollution on glibc systems.  */
+#if (0 || defined GNULIB_POSIXCHECK) \
+    && ((defined __APPLE__ && defined __MACH__) || defined __sun \
+        || defined __ANDROID__) \
+    && 0 \
+    && !defined __GLIBC__
+# include <sys/random.h>
+#endif
+
+/* Android 4.3 declares fchownat in <sys/stat.h>, not in <unistd.h>.  */
+/* But avoid namespace pollution on glibc systems.  */
+#if (0 || defined GNULIB_POSIXCHECK) && defined __ANDROID__ \
+    && !defined __GLIBC__
+# include <sys/stat.h>
+#endif
+
+/* MSVC defines off_t in <sys/types.h>.
+   May also define off_t to a 64-bit type on native Windows.  */
+/* Get off_t, ssize_t, mode_t.  */
+#include <sys/types.h>
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA (func, rettype, parameters);
+   is to be used when func is a Microsoft deprecated alias, on native Windows.
+   It declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to _func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_MDA (open, int, (const char *filename, int flags, ...));
+ */
+#define _GL_CXXALIAS_MDA(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_MDA (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#define _GL_CXXALIAS_MDA_CAST(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_CAST_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || defined __clang__
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype_gcc, rettype_clang, parameters_and_attributes, "message")
+   is like _GL_WARN_ON_USE (function, "message"), except that in C++ mode the
+   function is declared with the given prototype, consisting of return type,
+   parameters, and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if !defined __cplusplus
+#  define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+     _GL_WARN_ON_USE (function, msg)
+# else
+#  if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes \
+  __attribute__ ((__warning__ (msg)))
+#  elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_clang function parameters_and_attributes \
+  __attribute__ ((__diagnose_if__ (1, msg, "warning")))
+#  elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes
+#  else /* Unsupported.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  endif
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+
+/* Get getopt(), optarg, optind, opterr, optopt.  */
+#if 0 && 00 && !defined _GL_SYSTEM_GETOPT
+# include <getopt-cdefs.h>
+# include <getopt-pfx-core.h>
+#endif
+
+#ifndef _GL_INLINE_HEADER_BEGIN
+ #error "Please include config.h first."
+#endif
+_GL_INLINE_HEADER_BEGIN
+#ifndef _GL_UNISTD_INLINE
+# define _GL_UNISTD_INLINE _GL_INLINE
+#endif
+
+/* Hide some function declarations from <winsock2.h>.  */
+
+#if 0 && 1
+# if !defined _GL_SYS_SOCKET_H
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef socket
+#   define socket              socket_used_without_including_sys_socket_h
+#   undef connect
+#   define connect             connect_used_without_including_sys_socket_h
+#   undef accept
+#   define accept              accept_used_without_including_sys_socket_h
+#   undef bind
+#   define bind                bind_used_without_including_sys_socket_h
+#   undef getpeername
+#   define getpeername         getpeername_used_without_including_sys_socket_h
+#   undef getsockname
+#   define getsockname         getsockname_used_without_including_sys_socket_h
+#   undef getsockopt
+#   define getsockopt          getsockopt_used_without_including_sys_socket_h
+#   undef listen
+#   define listen              listen_used_without_including_sys_socket_h
+#   undef recv
+#   define recv                recv_used_without_including_sys_socket_h
+#   undef send
+#   define send                send_used_without_including_sys_socket_h
+#   undef recvfrom
+#   define recvfrom            recvfrom_used_without_including_sys_socket_h
+#   undef sendto
+#   define sendto              sendto_used_without_including_sys_socket_h
+#   undef setsockopt
+#   define setsockopt          setsockopt_used_without_including_sys_socket_h
+#   undef shutdown
+#   define shutdown            shutdown_used_without_including_sys_socket_h
+#  else
+    _GL_WARN_ON_USE (socket,
+                     "socket() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (connect,
+                     "connect() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (accept,
+                     "accept() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (bind,
+                     "bind() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (getpeername,
+                     "getpeername() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (getsockname,
+                     "getsockname() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (getsockopt,
+                     "getsockopt() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (listen,
+                     "listen() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (recv,
+                     "recv() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (send,
+                     "send() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (recvfrom,
+                     "recvfrom() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (sendto,
+                     "sendto() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (setsockopt,
+                     "setsockopt() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (shutdown,
+                     "shutdown() used without including <sys/socket.h>");
+#  endif
+# endif
+# if !defined _GL_SYS_SELECT_H
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef select
+#   define select              select_used_without_including_sys_select_h
+#  else
+    _GL_WARN_ON_USE (select,
+                     "select() used without including <sys/select.h>");
+#  endif
+# endif
+#endif
+
+
+/* OS/2 EMX lacks these macros.  */
+#ifndef STDIN_FILENO
+# define STDIN_FILENO 0
+#endif
+#ifndef STDOUT_FILENO
+# define STDOUT_FILENO 1
+#endif
+#ifndef STDERR_FILENO
+# define STDERR_FILENO 2
+#endif
+
+/* Ensure *_OK macros exist.  */
+#ifndef F_OK
+# define F_OK 0
+# define X_OK 1
+# define W_OK 2
+# define R_OK 4
+#endif
+
+
+/* Declare overridden functions.  */
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef access
+#   define access rpl_access
+#  endif
+_GL_FUNCDECL_RPL (access, int, (const char *file, int mode)
+                               _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (access, int, (const char *file, int mode));
+# elif defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef access
+#   define access _access
+#  endif
+_GL_CXXALIAS_MDA (access, int, (const char *file, int mode));
+# else
+_GL_CXXALIAS_SYS (access, int, (const char *file, int mode));
+# endif
+_GL_CXXALIASWARN (access);
+#elif defined GNULIB_POSIXCHECK
+# undef access
+# if HAVE_RAW_DECL_ACCESS
+/* The access() function is a security risk.  */
+_GL_WARN_ON_USE (access, "access does not always support X_OK - "
+                 "use gnulib module access for portability; "
+                 "also, this function is a security risk - "
+                 "use the gnulib module faccessat instead");
+# endif
+#elif 1
+/* On native Windows, map 'access' to '_access', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::access always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef access
+#   define access _access
+#  endif
+_GL_CXXALIAS_MDA (access, int, (const char *file, int mode));
+# else
+_GL_CXXALIAS_SYS (access, int, (const char *file, int mode));
+# endif
+_GL_CXXALIASWARN (access);
+#endif
+
+
+#if 1
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef chdir
+#   define chdir _chdir
+#  endif
+_GL_CXXALIAS_MDA (chdir, int, (const char *file));
+# else
+_GL_CXXALIAS_SYS (chdir, int, (const char *file) _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIASWARN (chdir);
+#elif defined GNULIB_POSIXCHECK
+# undef chdir
+# if HAVE_RAW_DECL_CHDIR
+_GL_WARN_ON_USE (chown, "chdir is not always in <unistd.h> - "
+                 "use gnulib module chdir for portability");
+# endif
+#elif 1
+/* On native Windows, map 'chdir' to '_chdir', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::chdir always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef chdir
+#   define chdir _chdir
+#  endif
+_GL_CXXALIAS_MDA (chdir, int, (const char *file));
+# else
+_GL_CXXALIAS_SYS (chdir, int, (const char *file) _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIASWARN (chdir);
+#endif
+
+
+#if 0
+/* Change the owner of FILE to UID (if UID is not -1) and the group of FILE
+   to GID (if GID is not -1).  Follow symbolic links.
+   Return 0 if successful, otherwise -1 and errno set.
+   See the POSIX:2008 specification
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/chown.html.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef chown
+#   define chown rpl_chown
+#  endif
+_GL_FUNCDECL_RPL (chown, int, (const char *file, uid_t uid, gid_t gid)
+                              _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (chown, int, (const char *file, uid_t uid, gid_t gid));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (chown, int, (const char *file, uid_t uid, gid_t gid)
+                              _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (chown, int, (const char *file, uid_t uid, gid_t gid));
+# endif
+_GL_CXXALIASWARN (chown);
+#elif defined GNULIB_POSIXCHECK
+# undef chown
+# if HAVE_RAW_DECL_CHOWN
+_GL_WARN_ON_USE (chown, "chown fails to follow symlinks on some systems and "
+                 "doesn't treat a uid or gid of -1 on some systems - "
+                 "use gnulib module chown for portability");
+# endif
+#endif
+
+
+#if 1
+# if 1
+/* Automatically included by modules that need a replacement for close.  */
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef close
+#   define close rpl_close
+#  endif
+_GL_FUNCDECL_RPL (close, int, (int fd));
+_GL_CXXALIAS_RPL (close, int, (int fd));
+# elif defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef close
+#   define close _close
+#  endif
+_GL_CXXALIAS_MDA (close, int, (int fd));
+# else
+_GL_CXXALIAS_SYS (close, int, (int fd));
+# endif
+_GL_CXXALIASWARN (close);
+#elif 1
+# undef close
+# define close close_used_without_requesting_gnulib_module_close
+#elif defined GNULIB_POSIXCHECK
+# undef close
+/* Assume close is always declared.  */
+_GL_WARN_ON_USE (close, "close does not portably work on sockets - "
+                 "use gnulib module close for portability");
+#elif 1
+/* On native Windows, map 'close' to '_close', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::close always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef close
+#   define close _close
+#  endif
+_GL_CXXALIAS_MDA (close, int, (int fd));
+# else
+_GL_CXXALIAS_SYS (close, int, (int fd));
+# endif
+_GL_CXXALIASWARN (close);
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef copy_file_range
+#   define copy_file_range rpl_copy_file_range
+#  endif
+_GL_FUNCDECL_RPL (copy_file_range, ssize_t, (int ifd, off_t *ipos,
+                                             int ofd, off_t *opos,
+                                             size_t len, unsigned flags));
+_GL_CXXALIAS_RPL (copy_file_range, ssize_t, (int ifd, off_t *ipos,
+                                             int ofd, off_t *opos,
+                                             size_t len, unsigned flags));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (copy_file_range, ssize_t, (int ifd, off_t *ipos,
+                                             int ofd, off_t *opos,
+                                             size_t len, unsigned flags));
+#  endif
+_GL_CXXALIAS_SYS (copy_file_range, ssize_t, (int ifd, off_t *ipos,
+                                             int ofd, off_t *opos,
+                                             size_t len, unsigned flags));
+# endif
+_GL_CXXALIASWARN (copy_file_range);
+#elif defined GNULIB_POSIXCHECK
+# undef copy_file_range
+# if HAVE_RAW_DECL_COPY_FILE_RANGE
+_GL_WARN_ON_USE (copy_file_range,
+                 "copy_file_range is unportable - "
+                 "use gnulib module copy_file_range for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define dup rpl_dup
+#  endif
+_GL_FUNCDECL_RPL (dup, int, (int oldfd));
+_GL_CXXALIAS_RPL (dup, int, (int oldfd));
+# elif defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef dup
+#   define dup _dup
+#  endif
+_GL_CXXALIAS_MDA (dup, int, (int oldfd));
+# else
+_GL_CXXALIAS_SYS (dup, int, (int oldfd));
+# endif
+_GL_CXXALIASWARN (dup);
+#elif defined GNULIB_POSIXCHECK
+# undef dup
+# if HAVE_RAW_DECL_DUP
+_GL_WARN_ON_USE (dup, "dup is unportable - "
+                 "use gnulib module dup for portability");
+# endif
+#elif 1
+/* On native Windows, map 'dup' to '_dup', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::dup always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef dup
+#   define dup _dup
+#  endif
+_GL_CXXALIAS_MDA (dup, int, (int oldfd));
+# else
+_GL_CXXALIAS_SYS (dup, int, (int oldfd));
+# endif
+_GL_CXXALIASWARN (dup);
+#endif
+
+
+#if 1
+/* Copy the file descriptor OLDFD into file descriptor NEWFD.  Do nothing if
+   NEWFD = OLDFD, otherwise close NEWFD first if it is open.
+   Return newfd if successful, otherwise -1 and errno set.
+   See the POSIX:2008 specification
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/dup2.html>.  */
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define dup2 rpl_dup2
+#  endif
+_GL_FUNCDECL_RPL (dup2, int, (int oldfd, int newfd));
+_GL_CXXALIAS_RPL (dup2, int, (int oldfd, int newfd));
+# elif defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef dup2
+#   define dup2 _dup2
+#  endif
+_GL_CXXALIAS_MDA (dup2, int, (int oldfd, int newfd));
+# else
+_GL_CXXALIAS_SYS (dup2, int, (int oldfd, int newfd));
+# endif
+_GL_CXXALIASWARN (dup2);
+#elif defined GNULIB_POSIXCHECK
+# undef dup2
+# if HAVE_RAW_DECL_DUP2
+_GL_WARN_ON_USE (dup2, "dup2 is unportable - "
+                 "use gnulib module dup2 for portability");
+# endif
+#elif 1
+/* On native Windows, map 'dup2' to '_dup2', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::dup2 always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef dup2
+#   define dup2 _dup2
+#  endif
+_GL_CXXALIAS_MDA (dup2, int, (int oldfd, int newfd));
+# else
+_GL_CXXALIAS_SYS (dup2, int, (int oldfd, int newfd));
+# endif
+_GL_CXXALIASWARN (dup2);
+#endif
+
+
+#if 0
+/* Copy the file descriptor OLDFD into file descriptor NEWFD, with the
+   specified flags.
+   The flags are a bitmask, possibly including O_CLOEXEC (defined in <fcntl.h>)
+   and O_TEXT, O_BINARY (defined in "binary-io.h").
+   Close NEWFD first if it is open.
+   Return newfd if successful, otherwise -1 and errno set.
+   See the Linux man page at
+   <https://www.kernel.org/doc/man-pages/online/pages/man2/dup3.2.html>.  */
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define dup3 rpl_dup3
+#  endif
+_GL_FUNCDECL_RPL (dup3, int, (int oldfd, int newfd, int flags));
+_GL_CXXALIAS_RPL (dup3, int, (int oldfd, int newfd, int flags));
+# else
+_GL_FUNCDECL_SYS (dup3, int, (int oldfd, int newfd, int flags));
+_GL_CXXALIAS_SYS (dup3, int, (int oldfd, int newfd, int flags));
+# endif
+_GL_CXXALIASWARN (dup3);
+#elif defined GNULIB_POSIXCHECK
+# undef dup3
+# if HAVE_RAW_DECL_DUP3
+_GL_WARN_ON_USE (dup3, "dup3 is unportable - "
+                 "use gnulib module dup3 for portability");
+# endif
+#endif
+
+
+#if IN_SED_GNULIB_TESTS
+# if defined __CYGWIN__ && !defined __i386__
+/* The 'environ' variable is defined in a DLL. Therefore its declaration needs
+   the '__declspec(dllimport)' attribute, but the system's <unistd.h> lacks it.
+   This leads to a link error on 64-bit Cygwin when the option
+   -Wl,--disable-auto-import is in use.  */
+_GL_EXTERN_C __declspec(dllimport) char **environ;
+# endif
+# if !1
+/* Set of environment variables and values.  An array of strings of the form
+   "VARIABLE=VALUE", terminated with a NULL.  */
+#  if defined __APPLE__ && defined __MACH__
+#   include <TargetConditionals.h>
+#   if !TARGET_OS_IPHONE && !TARGET_IPHONE_SIMULATOR
+#    define _GL_USE_CRT_EXTERNS
+#   endif
+#  endif
+#  ifdef _GL_USE_CRT_EXTERNS
+#   include <crt_externs.h>
+#   define environ (*_NSGetEnviron ())
+#  else
+#   ifdef __cplusplus
+extern "C" {
+#   endif
+extern char **environ;
+#   ifdef __cplusplus
+}
+#   endif
+#  endif
+# endif
+#elif defined GNULIB_POSIXCHECK
+# if HAVE_RAW_DECL_ENVIRON
+_GL_UNISTD_INLINE char ***
+_GL_WARN_ON_USE_ATTRIBUTE ("environ is unportable - "
+                           "use gnulib module environ for portability")
+rpl_environ (void)
+{
+  return &environ;
+}
+#  undef environ
+#  define environ (*rpl_environ ())
+# endif
+#endif
+
+
+#if 0
+/* Like access(), except that it uses the effective user id and group id of
+   the current process.  */
+# if !1
+_GL_FUNCDECL_SYS (euidaccess, int, (const char *filename, int mode)
+                                   _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (euidaccess, int, (const char *filename, int mode));
+_GL_CXXALIASWARN (euidaccess);
+# if defined GNULIB_POSIXCHECK
+/* Like access(), this function is a security risk.  */
+_GL_WARN_ON_USE (euidaccess, "the euidaccess function is a security risk - "
+                 "use the gnulib module faccessat instead");
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef euidaccess
+# if HAVE_RAW_DECL_EUIDACCESS
+_GL_WARN_ON_USE (euidaccess, "euidaccess is unportable - "
+                 "use gnulib module euidaccess for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef execl
+#   define execl rpl_execl
+#  endif
+_GL_FUNCDECL_RPL (execl, int, (const char *program, const char *arg, ...)
+                              _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (execl, int, (const char *program, const char *arg, ...));
+# else
+_GL_CXXALIAS_SYS (execl, int, (const char *program, const char *arg, ...));
+# endif
+_GL_CXXALIASWARN (execl);
+#elif defined GNULIB_POSIXCHECK
+# undef execl
+# if HAVE_RAW_DECL_EXECL
+_GL_WARN_ON_USE (execl, "execl behaves very differently on mingw - "
+                 "use gnulib module execl for portability");
+# endif
+#elif 1
+/* On native Windows, map 'execl' to '_execl', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::execl always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef execl
+#   define execl _execl
+#  endif
+_GL_CXXALIAS_MDA (execl, intptr_t, (const char *program, const char *arg, ...));
+# else
+_GL_CXXALIAS_SYS (execl, int, (const char *program, const char *arg, ...));
+# endif
+_GL_CXXALIASWARN (execl);
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef execle
+#   define execle rpl_execle
+#  endif
+_GL_FUNCDECL_RPL (execle, int, (const char *program, const char *arg, ...)
+                               _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (execle, int, (const char *program, const char *arg, ...));
+# else
+_GL_CXXALIAS_SYS (execle, int, (const char *program, const char *arg, ...));
+# endif
+_GL_CXXALIASWARN (execle);
+#elif defined GNULIB_POSIXCHECK
+# undef execle
+# if HAVE_RAW_DECL_EXECLE
+_GL_WARN_ON_USE (execle, "execle behaves very differently on mingw - "
+                 "use gnulib module execle for portability");
+# endif
+#elif 1
+/* On native Windows, map 'execle' to '_execle', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::execle always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef execle
+#   define execle _execle
+#  endif
+_GL_CXXALIAS_MDA (execle, intptr_t,
+                  (const char *program, const char *arg, ...));
+# else
+_GL_CXXALIAS_SYS (execle, int, (const char *program, const char *arg, ...));
+# endif
+_GL_CXXALIASWARN (execle);
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef execlp
+#   define execlp rpl_execlp
+#  endif
+_GL_FUNCDECL_RPL (execlp, int, (const char *program, const char *arg, ...)
+                               _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (execlp, int, (const char *program, const char *arg, ...));
+# else
+_GL_CXXALIAS_SYS (execlp, int, (const char *program, const char *arg, ...));
+# endif
+_GL_CXXALIASWARN (execlp);
+#elif defined GNULIB_POSIXCHECK
+# undef execlp
+# if HAVE_RAW_DECL_EXECLP
+_GL_WARN_ON_USE (execlp, "execlp behaves very differently on mingw - "
+                 "use gnulib module execlp for portability");
+# endif
+#elif 1
+/* On native Windows, map 'execlp' to '_execlp', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::execlp always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef execlp
+#   define execlp _execlp
+#  endif
+_GL_CXXALIAS_MDA (execlp, intptr_t,
+                  (const char *program, const char *arg, ...));
+# else
+_GL_CXXALIAS_SYS (execlp, int, (const char *program, const char *arg, ...));
+# endif
+_GL_CXXALIASWARN (execlp);
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef execv
+#   define execv rpl_execv
+#  endif
+_GL_FUNCDECL_RPL (execv, int, (const char *program, char * const *argv)
+                              _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (execv, int, (const char *program, char * const *argv));
+# else
+_GL_CXXALIAS_SYS (execv, int, (const char *program, char * const *argv));
+# endif
+_GL_CXXALIASWARN (execv);
+#elif defined GNULIB_POSIXCHECK
+# undef execv
+# if HAVE_RAW_DECL_EXECV
+_GL_WARN_ON_USE (execv, "execv behaves very differently on mingw - "
+                 "use gnulib module execv for portability");
+# endif
+#elif 1
+/* On native Windows, map 'execv' to '_execv', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::execv always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef execv
+#   define execv _execv
+#  endif
+_GL_CXXALIAS_MDA_CAST (execv, intptr_t,
+                       (const char *program, char * const *argv));
+# else
+_GL_CXXALIAS_SYS (execv, int, (const char *program, char * const *argv));
+# endif
+_GL_CXXALIASWARN (execv);
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef execve
+#   define execve rpl_execve
+#  endif
+_GL_FUNCDECL_RPL (execve, int,
+                  (const char *program, char * const *argv, char * const *env)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (execve, int,
+                  (const char *program, char * const *argv, char * const *env));
+# else
+_GL_CXXALIAS_SYS (execve, int,
+                  (const char *program, char * const *argv, char * const *env));
+# endif
+_GL_CXXALIASWARN (execve);
+#elif defined GNULIB_POSIXCHECK
+# undef execve
+# if HAVE_RAW_DECL_EXECVE
+_GL_WARN_ON_USE (execve, "execve behaves very differently on mingw - "
+                 "use gnulib module execve for portability");
+# endif
+#elif 1
+/* On native Windows, map 'execve' to '_execve', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::execve always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef execve
+#   define execve _execve
+#  endif
+_GL_CXXALIAS_MDA_CAST (execve, intptr_t,
+                       (const char *program, char * const *argv,
+                        char * const *env));
+# else
+_GL_CXXALIAS_SYS (execve, int,
+                  (const char *program, char * const *argv, char * const *env));
+# endif
+_GL_CXXALIASWARN (execve);
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef execvp
+#   define execvp rpl_execvp
+#  endif
+_GL_FUNCDECL_RPL (execvp, int, (const char *program, char * const *argv)
+                               _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (execvp, int, (const char *program, char * const *argv));
+# else
+_GL_CXXALIAS_SYS (execvp, int, (const char *program, char * const *argv));
+# endif
+_GL_CXXALIASWARN (execvp);
+#elif defined GNULIB_POSIXCHECK
+# undef execvp
+# if HAVE_RAW_DECL_EXECVP
+_GL_WARN_ON_USE (execvp, "execvp behaves very differently on mingw - "
+                 "use gnulib module execvp for portability");
+# endif
+#elif 1
+/* On native Windows, map 'execvp' to '_execvp', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::execvp always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef execvp
+#   define execvp _execvp
+#  endif
+_GL_CXXALIAS_MDA_CAST (execvp, intptr_t,
+                       (const char *program, char * const *argv));
+# else
+_GL_CXXALIAS_SYS (execvp, int, (const char *program, char * const *argv));
+# endif
+_GL_CXXALIASWARN (execvp);
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef execvpe
+#   define execvpe rpl_execvpe
+#  endif
+_GL_FUNCDECL_RPL (execvpe, int,
+                  (const char *program, char * const *argv, char * const *env)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (execvpe, int,
+                  (const char *program, char * const *argv, char * const *env));
+# else
+#  if !0
+_GL_FUNCDECL_SYS (execvpe, int,
+                  (const char *program, char * const *argv, char * const *env)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (execvpe, int,
+                  (const char *program, char * const *argv, char * const *env));
+# endif
+_GL_CXXALIASWARN (execvpe);
+#elif defined GNULIB_POSIXCHECK
+# undef execvpe
+# if HAVE_RAW_DECL_EXECVPE
+_GL_WARN_ON_USE (execvpe, "execvpe behaves very differently on mingw - "
+                 "use gnulib module execvpe for portability");
+# endif
+#elif 1
+/* On native Windows, map 'execvpe' to '_execvpe', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::execvpe on all platforms that have
+   it.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef execvpe
+#   define execvpe _execvpe
+#  endif
+_GL_CXXALIAS_MDA_CAST (execvpe, intptr_t,
+                       (const char *program, char * const *argv,
+                        char * const *env));
+# elif 1
+#  if !0
+_GL_FUNCDECL_SYS (execvpe, int,
+                  (const char *program, char * const *argv, char * const *env)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (execvpe, int,
+                  (const char *program, char * const *argv, char * const *env));
+# endif
+# if (defined _WIN32 && !defined __CYGWIN__) || 1
+_GL_CXXALIASWARN (execvpe);
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef faccessat
+#   define faccessat rpl_faccessat
+#  endif
+_GL_FUNCDECL_RPL (faccessat, int,
+                  (int fd, char const *name, int mode, int flag)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (faccessat, int,
+                  (int fd, char const *name, int mode, int flag));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (faccessat, int,
+                  (int fd, char const *file, int mode, int flag)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (faccessat, int,
+                  (int fd, char const *file, int mode, int flag));
+# endif
+_GL_CXXALIASWARN (faccessat);
+#elif defined GNULIB_POSIXCHECK
+# undef faccessat
+# if HAVE_RAW_DECL_FACCESSAT
+_GL_WARN_ON_USE (faccessat, "faccessat is not portable - "
+                 "use gnulib module faccessat for portability");
+# endif
+#endif
+
+
+#if 0
+/* Change the process' current working directory to the directory on which
+   the given file descriptor is open.
+   Return 0 if successful, otherwise -1 and errno set.
+   See the POSIX:2008 specification
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/fchdir.html>.  */
+# if ! 1
+_GL_FUNCDECL_SYS (fchdir, int, (int /*fd*/));
+
+/* Gnulib internal hooks needed to maintain the fchdir metadata.  */
+_GL_EXTERN_C int _gl_register_fd (int fd, const char *filename)
+     _GL_ARG_NONNULL ((2));
+_GL_EXTERN_C void _gl_unregister_fd (int fd);
+_GL_EXTERN_C int _gl_register_dup (int oldfd, int newfd);
+_GL_EXTERN_C const char *_gl_directory_name (int fd);
+
+# else
+#  if !1
+_GL_FUNCDECL_SYS (fchdir, int, (int /*fd*/));
+#  endif
+# endif
+_GL_CXXALIAS_SYS (fchdir, int, (int /*fd*/));
+_GL_CXXALIASWARN (fchdir);
+#elif defined GNULIB_POSIXCHECK
+# undef fchdir
+# if HAVE_RAW_DECL_FCHDIR
+_GL_WARN_ON_USE (fchdir, "fchdir is unportable - "
+                 "use gnulib module fchdir for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fchownat
+#   define fchownat rpl_fchownat
+#  endif
+_GL_FUNCDECL_RPL (fchownat, int, (int fd, char const *file,
+                                  uid_t owner, gid_t group, int flag)
+                                 _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (fchownat, int, (int fd, char const *file,
+                                  uid_t owner, gid_t group, int flag));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (fchownat, int, (int fd, char const *file,
+                                  uid_t owner, gid_t group, int flag)
+                                 _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (fchownat, int, (int fd, char const *file,
+                                  uid_t owner, gid_t group, int flag));
+# endif
+_GL_CXXALIASWARN (fchownat);
+#elif defined GNULIB_POSIXCHECK
+# undef fchownat
+# if HAVE_RAW_DECL_FCHOWNAT
+_GL_WARN_ON_USE (fchownat, "fchownat is not portable - "
+                 "use gnulib module fchownat for portability");
+# endif
+#endif
+
+
+#if 0
+/* Synchronize changes to a file.
+   Return 0 if successful, otherwise -1 and errno set.
+   See POSIX:2008 specification
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/fdatasync.html>.  */
+# if !1 || !1
+_GL_FUNCDECL_SYS (fdatasync, int, (int fd));
+# endif
+_GL_CXXALIAS_SYS (fdatasync, int, (int fd));
+_GL_CXXALIASWARN (fdatasync);
+#elif defined GNULIB_POSIXCHECK
+# undef fdatasync
+# if HAVE_RAW_DECL_FDATASYNC
+_GL_WARN_ON_USE (fdatasync, "fdatasync is unportable - "
+                 "use gnulib module fdatasync for portability");
+# endif
+#endif
+
+
+#if 0
+/* Synchronize changes, including metadata, to a file.
+   Return 0 if successful, otherwise -1 and errno set.
+   See POSIX:2008 specification
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/fsync.html>.  */
+# if !1
+_GL_FUNCDECL_SYS (fsync, int, (int fd));
+# endif
+_GL_CXXALIAS_SYS (fsync, int, (int fd));
+_GL_CXXALIASWARN (fsync);
+#elif defined GNULIB_POSIXCHECK
+# undef fsync
+# if HAVE_RAW_DECL_FSYNC
+_GL_WARN_ON_USE (fsync, "fsync is unportable - "
+                 "use gnulib module fsync for portability");
+# endif
+#endif
+
+
+#if IN_SED_GNULIB_TESTS
+/* Change the size of the file to which FD is opened to become equal to LENGTH.
+   Return 0 if successful, otherwise -1 and errno set.
+   See the POSIX:2008 specification
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/ftruncate.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef ftruncate
+#   define ftruncate rpl_ftruncate
+#  endif
+_GL_FUNCDECL_RPL (ftruncate, int, (int fd, off_t length));
+_GL_CXXALIAS_RPL (ftruncate, int, (int fd, off_t length));
+# else
+#  if !0
+_GL_FUNCDECL_SYS (ftruncate, int, (int fd, off_t length));
+#  endif
+_GL_CXXALIAS_SYS (ftruncate, int, (int fd, off_t length));
+# endif
+_GL_CXXALIASWARN (ftruncate);
+#elif defined GNULIB_POSIXCHECK
+# undef ftruncate
+# if HAVE_RAW_DECL_FTRUNCATE
+_GL_WARN_ON_USE (ftruncate, "ftruncate is unportable - "
+                 "use gnulib module ftruncate for portability");
+# endif
+#endif
+
+
+#if IN_SED_GNULIB_TESTS
+/* Get the name of the current working directory, and put it in SIZE bytes
+   of BUF.
+   Return BUF if successful, or NULL if the directory couldn't be determined
+   or SIZE was too small.
+   See the POSIX:2008 specification
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getcwd.html>.
+   Additionally, the gnulib module 'getcwd' guarantees the following GNU
+   extension: If BUF is NULL, an array is allocated with 'malloc'; the array
+   is SIZE bytes long, unless SIZE == 0, in which case it is as big as
+   necessary.  */
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define getcwd rpl_getcwd
+#  endif
+_GL_FUNCDECL_RPL (getcwd, char *, (char *buf, size_t size));
+_GL_CXXALIAS_RPL (getcwd, char *, (char *buf, size_t size));
+# elif defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getcwd
+#   define getcwd _getcwd
+#  endif
+_GL_CXXALIAS_MDA (getcwd, char *, (char *buf, size_t size));
+# else
+/* Need to cast, because on mingw, the second parameter is
+                                                   int size.  */
+_GL_CXXALIAS_SYS_CAST (getcwd, char *, (char *buf, size_t size));
+# endif
+_GL_CXXALIASWARN (getcwd);
+#elif defined GNULIB_POSIXCHECK
+# undef getcwd
+# if HAVE_RAW_DECL_GETCWD
+_GL_WARN_ON_USE (getcwd, "getcwd is unportable - "
+                 "use gnulib module getcwd for portability");
+# endif
+#elif 1
+/* On native Windows, map 'getcwd' to '_getcwd', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::getcwd always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getcwd
+#   define getcwd _getcwd
+#  endif
+/* Need to cast, because on mingw, the second parameter is either
+   'int size' or 'size_t size'.  */
+_GL_CXXALIAS_MDA_CAST (getcwd, char *, (char *buf, size_t size));
+# else
+_GL_CXXALIAS_SYS_CAST (getcwd, char *, (char *buf, size_t size));
+# endif
+_GL_CXXALIASWARN (getcwd);
+#endif
+
+
+#if 0
+/* Return the NIS domain name of the machine.
+   WARNING! The NIS domain name is unrelated to the fully qualified host name
+            of the machine.  It is also unrelated to email addresses.
+   WARNING! The NIS domain name is usually the empty string or "(none)" when
+            not using NIS.
+
+   Put up to LEN bytes of the NIS domain name into NAME.
+   Null terminate it if the name is shorter than LEN.
+   If the NIS domain name is longer than LEN, set errno = EINVAL and return -1.
+   Return 0 if successful, otherwise set errno and return -1.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getdomainname
+#   define getdomainname rpl_getdomainname
+#  endif
+_GL_FUNCDECL_RPL (getdomainname, int, (char *name, size_t len)
+                                      _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (getdomainname, int, (char *name, size_t len));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (getdomainname, int, (char *name, size_t len)
+                                      _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (getdomainname, int, (char *name, size_t len));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (getdomainname);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef getdomainname
+# if HAVE_RAW_DECL_GETDOMAINNAME
+_GL_WARN_ON_USE (getdomainname, "getdomainname is unportable - "
+                 "use gnulib module getdomainname for portability");
+# endif
+#endif
+
+
+#if 1
+/* Return the maximum number of file descriptors in the current process.
+   In POSIX, this is same as sysconf (_SC_OPEN_MAX).  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getdtablesize
+#   define getdtablesize rpl_getdtablesize
+#  endif
+_GL_FUNCDECL_RPL (getdtablesize, int, (void));
+_GL_CXXALIAS_RPL (getdtablesize, int, (void));
+# else
+#  if !0
+_GL_FUNCDECL_SYS (getdtablesize, int, (void));
+#  endif
+/* Need to cast, because on AIX, the parameter list is
+                                           (...).  */
+_GL_CXXALIAS_SYS_CAST (getdtablesize, int, (void));
+# endif
+_GL_CXXALIASWARN (getdtablesize);
+#elif defined GNULIB_POSIXCHECK
+# undef getdtablesize
+# if HAVE_RAW_DECL_GETDTABLESIZE
+_GL_WARN_ON_USE (getdtablesize, "getdtablesize is unportable - "
+                 "use gnulib module getdtablesize for portability");
+# endif
+#endif
+
+
+#if 0
+/* Fill a buffer with random bytes.  */
+# if !1
+_GL_FUNCDECL_SYS (getentropy, int, (void *buffer, size_t length));
+# endif
+_GL_CXXALIAS_SYS (getentropy, int, (void *buffer, size_t length));
+_GL_CXXALIASWARN (getentropy);
+#elif defined GNULIB_POSIXCHECK
+# undef getentropy
+# if HAVE_RAW_DECL_GETENTROPY
+_GL_WARN_ON_USE (getentropy, "getentropy is unportable - "
+                 "use gnulib module getentropy for portability");
+# endif
+#endif
+
+
+#if 0
+/* Return the supplemental groups that the current process belongs to.
+   It is unspecified whether the effective group id is in the list.
+   If N is 0, return the group count; otherwise, N describes how many
+   entries are available in GROUPS.  Return -1 and set errno if N is
+   not 0 and not large enough.  Fails with ENOSYS on some systems.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getgroups
+#   define getgroups rpl_getgroups
+#  endif
+_GL_FUNCDECL_RPL (getgroups, int, (int n, gid_t *groups));
+_GL_CXXALIAS_RPL (getgroups, int, (int n, gid_t *groups));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (getgroups, int, (int n, gid_t *groups));
+#  endif
+_GL_CXXALIAS_SYS (getgroups, int, (int n, gid_t *groups));
+# endif
+_GL_CXXALIASWARN (getgroups);
+#elif defined GNULIB_POSIXCHECK
+# undef getgroups
+# if HAVE_RAW_DECL_GETGROUPS
+_GL_WARN_ON_USE (getgroups, "getgroups is unportable - "
+                 "use gnulib module getgroups for portability");
+# endif
+#endif
+
+
+#if 0
+/* Return the standard host name of the machine.
+   WARNING! The host name may or may not be fully qualified.
+
+   Put up to LEN bytes of the host name into NAME.
+   Null terminate it if the name is shorter than LEN.
+   If the host name is longer than LEN, set errno = EINVAL and return -1.
+   Return 0 if successful, otherwise set errno and return -1.  */
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef gethostname
+#   define gethostname rpl_gethostname
+#  endif
+_GL_FUNCDECL_RPL (gethostname, int, (char *name, size_t len)
+                                    _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (gethostname, int, (char *name, size_t len));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (gethostname, int, (char *name, size_t len)
+                                    _GL_ARG_NONNULL ((1)));
+#  endif
+/* Need to cast, because on Solaris 10 and OSF/1 5.1 systems, the second
+   parameter is
+                                                      int len.  */
+_GL_CXXALIAS_SYS_CAST (gethostname, int, (char *name, size_t len));
+# endif
+_GL_CXXALIASWARN (gethostname);
+#elif 1
+# undef gethostname
+# define gethostname gethostname_used_without_requesting_gnulib_module_gethostname
+#elif defined GNULIB_POSIXCHECK
+# undef gethostname
+# if HAVE_RAW_DECL_GETHOSTNAME
+_GL_WARN_ON_USE (gethostname, "gethostname is unportable - "
+                 "use gnulib module gethostname for portability");
+# endif
+#endif
+
+
+#if 0
+/* Returns the user's login name, or NULL if it cannot be found.  Upon error,
+   returns NULL with errno set.
+
+   See <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getlogin.html>.
+
+   Most programs don't need to use this function, because the information is
+   available through environment variables:
+     ${LOGNAME-$USER}        on Unix platforms,
+     $USERNAME               on native Windows platforms.
+ */
+# if !1
+_GL_FUNCDECL_SYS (getlogin, char *, (void));
+# endif
+_GL_CXXALIAS_SYS (getlogin, char *, (void));
+_GL_CXXALIASWARN (getlogin);
+#elif defined GNULIB_POSIXCHECK
+# undef getlogin
+# if HAVE_RAW_DECL_GETLOGIN
+_GL_WARN_ON_USE (getlogin, "getlogin is unportable - "
+                 "use gnulib module getlogin for portability");
+# endif
+#endif
+
+
+#if 0
+/* Copies the user's login name to NAME.
+   The array pointed to by NAME has room for SIZE bytes.
+
+   Returns 0 if successful.  Upon error, an error number is returned, or -1 in
+   the case that the login name cannot be found but no specific error is
+   provided (this case is hopefully rare but is left open by the POSIX spec).
+
+   See <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getlogin.html>.
+
+   Most programs don't need to use this function, because the information is
+   available through environment variables:
+     ${LOGNAME-$USER}        on Unix platforms,
+     $USERNAME               on native Windows platforms.
+ */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define getlogin_r rpl_getlogin_r
+#  endif
+_GL_FUNCDECL_RPL (getlogin_r, int, (char *name, size_t size)
+                                   _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (getlogin_r, int, (char *name, size_t size));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (getlogin_r, int, (char *name, size_t size)
+                                   _GL_ARG_NONNULL ((1)));
+#  endif
+/* Need to cast, because on Solaris 10 systems, the second argument is
+                                                     int size.  */
+_GL_CXXALIAS_SYS_CAST (getlogin_r, int, (char *name, size_t size));
+# endif
+_GL_CXXALIASWARN (getlogin_r);
+#elif defined GNULIB_POSIXCHECK
+# undef getlogin_r
+# if HAVE_RAW_DECL_GETLOGIN_R
+_GL_WARN_ON_USE (getlogin_r, "getlogin_r is unportable - "
+                 "use gnulib module getlogin_r for portability");
+# endif
+#endif
+
+
+#if IN_SED_GNULIB_TESTS
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define getpagesize rpl_getpagesize
+#  endif
+_GL_FUNCDECL_RPL (getpagesize, int, (void));
+_GL_CXXALIAS_RPL (getpagesize, int, (void));
+# else
+/* On HP-UX, getpagesize exists, but it is not declared in <unistd.h> even if
+   the compiler options -D_HPUX_SOURCE -D_XOPEN_SOURCE=600 are used.  */
+#  if defined __hpux
+_GL_FUNCDECL_SYS (getpagesize, int, (void));
+#  endif
+#  if !0
+#   if !defined getpagesize
+/* This is for POSIX systems.  */
+#    if !defined _gl_getpagesize && defined _SC_PAGESIZE
+#     if ! (defined __VMS && __VMS_VER < 70000000)
+#      define _gl_getpagesize() sysconf (_SC_PAGESIZE)
+#     endif
+#    endif
+/* This is for older VMS.  */
+#    if !defined _gl_getpagesize && defined __VMS
+#     ifdef __ALPHA
+#      define _gl_getpagesize() 8192
+#     else
+#      define _gl_getpagesize() 512
+#     endif
+#    endif
+/* This is for BeOS.  */
+#    if !defined _gl_getpagesize && 0
+#     include <OS.h>
+#     if defined B_PAGE_SIZE
+#      define _gl_getpagesize() B_PAGE_SIZE
+#     endif
+#    endif
+/* This is for AmigaOS4.0.  */
+#    if !defined _gl_getpagesize && defined __amigaos4__
+#     define _gl_getpagesize() 2048
+#    endif
+/* This is for older Unix systems.  */
+#    if !defined _gl_getpagesize && 0
+#     include <sys/param.h>
+#     ifdef EXEC_PAGESIZE
+#      define _gl_getpagesize() EXEC_PAGESIZE
+#     else
+#      ifdef NBPG
+#       ifndef CLSIZE
+#        define CLSIZE 1
+#       endif
+#       define _gl_getpagesize() (NBPG * CLSIZE)
+#      else
+#       ifdef NBPC
+#        define _gl_getpagesize() NBPC
+#       endif
+#      endif
+#     endif
+#    endif
+#    if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#     define getpagesize() _gl_getpagesize ()
+#    else
+#     if !GNULIB_defined_getpagesize_function
+_GL_UNISTD_INLINE int
+getpagesize ()
+{
+  return _gl_getpagesize ();
+}
+#      define GNULIB_defined_getpagesize_function 1
+#     endif
+#    endif
+#   endif
+#  endif
+/* Need to cast, because on Cygwin 1.5.x systems, the return type is size_t.  */
+_GL_CXXALIAS_SYS_CAST (getpagesize, int, (void));
+# endif
+# if 0
+_GL_CXXALIASWARN (getpagesize);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef getpagesize
+# if HAVE_RAW_DECL_GETPAGESIZE
+_GL_WARN_ON_USE (getpagesize, "getpagesize is unportable - "
+                 "use gnulib module getpagesize for portability");
+# endif
+#endif
+
+
+#if 0
+/* Function getpass() from module 'getpass':
+     Read a password from /dev/tty or stdin.
+   Function getpass() from module 'getpass-gnu':
+     Read a password of arbitrary length from /dev/tty or stdin.  */
+# if (0 && 0) \
+     || (0 && 0)
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getpass
+#   define getpass rpl_getpass
+#  endif
+_GL_FUNCDECL_RPL (getpass, char *, (const char *prompt)
+                                   _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (getpass, char *, (const char *prompt));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (getpass, char *, (const char *prompt)
+                                   _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (getpass, char *, (const char *prompt));
+# endif
+_GL_CXXALIASWARN (getpass);
+#elif defined GNULIB_POSIXCHECK
+# undef getpass
+# if HAVE_RAW_DECL_GETPASS
+_GL_WARN_ON_USE (getpass, "getpass is unportable - "
+                 "use gnulib module getpass or getpass-gnu for portability");
+# endif
+#endif
+
+
+#if 1
+/* On native Windows, map 'getpid' to '_getpid', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::getpid always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getpid
+#   define getpid _getpid
+#  endif
+_GL_CXXALIAS_MDA (getpid, int, (void));
+# else
+_GL_CXXALIAS_SYS (getpid, pid_t, (void));
+# endif
+_GL_CXXALIASWARN (getpid);
+#endif
+
+
+#if 0
+/* Return the next valid login shell on the system, or NULL when the end of
+   the list has been reached.  */
+# if !1
+_GL_FUNCDECL_SYS (getusershell, char *, (void));
+# endif
+_GL_CXXALIAS_SYS (getusershell, char *, (void));
+_GL_CXXALIASWARN (getusershell);
+#elif defined GNULIB_POSIXCHECK
+# undef getusershell
+# if HAVE_RAW_DECL_GETUSERSHELL
+_GL_WARN_ON_USE (getusershell, "getusershell is unportable - "
+                 "use gnulib module getusershell for portability");
+# endif
+#endif
+
+#if 0
+/* Rewind to pointer that is advanced at each getusershell() call.  */
+# if !1
+_GL_FUNCDECL_SYS (setusershell, void, (void));
+# endif
+_GL_CXXALIAS_SYS (setusershell, void, (void));
+_GL_CXXALIASWARN (setusershell);
+#elif defined GNULIB_POSIXCHECK
+# undef setusershell
+# if HAVE_RAW_DECL_SETUSERSHELL
+_GL_WARN_ON_USE (setusershell, "setusershell is unportable - "
+                 "use gnulib module getusershell for portability");
+# endif
+#endif
+
+#if 0
+/* Free the pointer that is advanced at each getusershell() call and
+   associated resources.  */
+# if !1
+_GL_FUNCDECL_SYS (endusershell, void, (void));
+# endif
+_GL_CXXALIAS_SYS (endusershell, void, (void));
+_GL_CXXALIASWARN (endusershell);
+#elif defined GNULIB_POSIXCHECK
+# undef endusershell
+# if HAVE_RAW_DECL_ENDUSERSHELL
+_GL_WARN_ON_USE (endusershell, "endusershell is unportable - "
+                 "use gnulib module getusershell for portability");
+# endif
+#endif
+
+
+#if 0
+/* Determine whether group id is in calling user's group list.  */
+# if !1
+_GL_FUNCDECL_SYS (group_member, int, (gid_t gid));
+# endif
+_GL_CXXALIAS_SYS (group_member, int, (gid_t gid));
+_GL_CXXALIASWARN (group_member);
+#elif defined GNULIB_POSIXCHECK
+# undef group_member
+# if HAVE_RAW_DECL_GROUP_MEMBER
+_GL_WARN_ON_USE (group_member, "group_member is unportable - "
+                 "use gnulib module group-member for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef isatty
+#   define isatty rpl_isatty
+#  endif
+#  define GNULIB_defined_isatty 1
+_GL_FUNCDECL_RPL (isatty, int, (int fd));
+_GL_CXXALIAS_RPL (isatty, int, (int fd));
+# elif defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef isatty
+#   define isatty _isatty
+#  endif
+_GL_CXXALIAS_MDA (isatty, int, (int fd));
+# else
+_GL_CXXALIAS_SYS (isatty, int, (int fd));
+# endif
+_GL_CXXALIASWARN (isatty);
+#elif defined GNULIB_POSIXCHECK
+# undef isatty
+# if HAVE_RAW_DECL_ISATTY
+_GL_WARN_ON_USE (isatty, "isatty has portability problems on native Windows - "
+                 "use gnulib module isatty for portability");
+# endif
+#elif 1
+/* On native Windows, map 'isatty' to '_isatty', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::isatty always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef isatty
+#   define isatty _isatty
+#  endif
+_GL_CXXALIAS_MDA (isatty, int, (int fd));
+# else
+_GL_CXXALIAS_SYS (isatty, int, (int fd));
+# endif
+_GL_CXXALIASWARN (isatty);
+#endif
+
+
+#if 0
+/* Change the owner of FILE to UID (if UID is not -1) and the group of FILE
+   to GID (if GID is not -1).  Do not follow symbolic links.
+   Return 0 if successful, otherwise -1 and errno set.
+   See the POSIX:2008 specification
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/lchown.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef lchown
+#   define lchown rpl_lchown
+#  endif
+_GL_FUNCDECL_RPL (lchown, int, (char const *file, uid_t owner, gid_t group)
+                               _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (lchown, int, (char const *file, uid_t owner, gid_t group));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (lchown, int, (char const *file, uid_t owner, gid_t group)
+                               _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (lchown, int, (char const *file, uid_t owner, gid_t group));
+# endif
+_GL_CXXALIASWARN (lchown);
+#elif defined GNULIB_POSIXCHECK
+# undef lchown
+# if HAVE_RAW_DECL_LCHOWN
+_GL_WARN_ON_USE (lchown, "lchown is unportable to pre-POSIX.1-2001 systems - "
+                 "use gnulib module lchown for portability");
+# endif
+#endif
+
+
+#if IN_SED_GNULIB_TESTS
+/* Create a new hard link for an existing file.
+   Return 0 if successful, otherwise -1 and errno set.
+   See POSIX:2008 specification
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/link.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define link rpl_link
+#  endif
+_GL_FUNCDECL_RPL (link, int, (const char *path1, const char *path2)
+                             _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (link, int, (const char *path1, const char *path2));
+# else
+#  if !0
+_GL_FUNCDECL_SYS (link, int, (const char *path1, const char *path2)
+                             _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (link, int, (const char *path1, const char *path2));
+# endif
+_GL_CXXALIASWARN (link);
+#elif defined GNULIB_POSIXCHECK
+# undef link
+# if HAVE_RAW_DECL_LINK
+_GL_WARN_ON_USE (link, "link is unportable - "
+                 "use gnulib module link for portability");
+# endif
+#endif
+
+
+#if 0
+/* Create a new hard link for an existing file, relative to two
+   directories.  FLAG controls whether symlinks are followed.
+   Return 0 if successful, otherwise -1 and errno set.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef linkat
+#   define linkat rpl_linkat
+#  endif
+_GL_FUNCDECL_RPL (linkat, int,
+                  (int fd1, const char *path1, int fd2, const char *path2,
+                   int flag)
+                  _GL_ARG_NONNULL ((2, 4)));
+_GL_CXXALIAS_RPL (linkat, int,
+                  (int fd1, const char *path1, int fd2, const char *path2,
+                   int flag));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (linkat, int,
+                  (int fd1, const char *path1, int fd2, const char *path2,
+                   int flag)
+                  _GL_ARG_NONNULL ((2, 4)));
+#  endif
+_GL_CXXALIAS_SYS (linkat, int,
+                  (int fd1, const char *path1, int fd2, const char *path2,
+                   int flag));
+# endif
+_GL_CXXALIASWARN (linkat);
+#elif defined GNULIB_POSIXCHECK
+# undef linkat
+# if HAVE_RAW_DECL_LINKAT
+_GL_WARN_ON_USE (linkat, "linkat is unportable - "
+                 "use gnulib module linkat for portability");
+# endif
+#endif
+
+
+#if IN_SED_GNULIB_TESTS
+/* Set the offset of FD relative to SEEK_SET, SEEK_CUR, or SEEK_END.
+   Return the new offset if successful, otherwise -1 and errno set.
+   See the POSIX:2008 specification
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/lseek.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define lseek rpl_lseek
+#  endif
+_GL_FUNCDECL_RPL (lseek, off_t, (int fd, off_t offset, int whence));
+_GL_CXXALIAS_RPL (lseek, off_t, (int fd, off_t offset, int whence));
+# elif defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef lseek
+#   define lseek _lseek
+#  endif
+_GL_CXXALIAS_MDA (lseek, off_t, (int fd, off_t offset, int whence));
+# else
+_GL_CXXALIAS_SYS (lseek, off_t, (int fd, off_t offset, int whence));
+# endif
+_GL_CXXALIASWARN (lseek);
+#elif defined GNULIB_POSIXCHECK
+# undef lseek
+# if HAVE_RAW_DECL_LSEEK
+_GL_WARN_ON_USE (lseek, "lseek does not fail with ESPIPE on pipes on some "
+                 "systems - use gnulib module lseek for portability");
+# endif
+#elif 1
+/* On native Windows, map 'lseek' to '_lseek', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::lseek always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef lseek
+#   define lseek _lseek
+#  endif
+_GL_CXXALIAS_MDA (lseek, long, (int fd, long offset, int whence));
+# else
+_GL_CXXALIAS_SYS (lseek, off_t, (int fd, off_t offset, int whence));
+# endif
+_GL_CXXALIASWARN (lseek);
+#endif
+
+
+#if IN_SED_GNULIB_TESTS
+/* Create a pipe, defaulting to O_BINARY mode.
+   Store the read-end as fd[0] and the write-end as fd[1].
+   Return 0 upon success, or -1 with errno set upon failure.  */
+# if !0
+_GL_FUNCDECL_SYS (pipe, int, (int fd[2]) _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (pipe, int, (int fd[2]));
+_GL_CXXALIASWARN (pipe);
+#elif defined GNULIB_POSIXCHECK
+# undef pipe
+# if HAVE_RAW_DECL_PIPE
+_GL_WARN_ON_USE (pipe, "pipe is unportable - "
+                 "use gnulib module pipe-posix for portability");
+# endif
+#endif
+
+
+#if 0
+/* Create a pipe, applying the given flags when opening the read-end of the
+   pipe and the write-end of the pipe.
+   The flags are a bitmask, possibly including O_CLOEXEC (defined in <fcntl.h>)
+   and O_TEXT, O_BINARY (defined in "binary-io.h").
+   Store the read-end as fd[0] and the write-end as fd[1].
+   Return 0 upon success, or -1 with errno set upon failure.
+   See also the Linux man page at
+   <https://www.kernel.org/doc/man-pages/online/pages/man2/pipe2.2.html>.  */
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define pipe2 rpl_pipe2
+#  endif
+_GL_FUNCDECL_RPL (pipe2, int, (int fd[2], int flags) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (pipe2, int, (int fd[2], int flags));
+# else
+_GL_FUNCDECL_SYS (pipe2, int, (int fd[2], int flags) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_SYS (pipe2, int, (int fd[2], int flags));
+# endif
+_GL_CXXALIASWARN (pipe2);
+#elif defined GNULIB_POSIXCHECK
+# undef pipe2
+# if HAVE_RAW_DECL_PIPE2
+_GL_WARN_ON_USE (pipe2, "pipe2 is unportable - "
+                 "use gnulib module pipe2 for portability");
+# endif
+#endif
+
+
+#if 0
+/* Read at most BUFSIZE bytes from FD into BUF, starting at OFFSET.
+   Return the number of bytes placed into BUF if successful, otherwise
+   set errno and return -1.  0 indicates EOF.
+   See the POSIX:2008 specification
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/pread.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef pread
+#   define pread rpl_pread
+#  endif
+_GL_FUNCDECL_RPL (pread, ssize_t,
+                  (int fd, void *buf, size_t bufsize, off_t offset)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (pread, ssize_t,
+                  (int fd, void *buf, size_t bufsize, off_t offset));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (pread, ssize_t,
+                  (int fd, void *buf, size_t bufsize, off_t offset)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (pread, ssize_t,
+                  (int fd, void *buf, size_t bufsize, off_t offset));
+# endif
+_GL_CXXALIASWARN (pread);
+#elif defined GNULIB_POSIXCHECK
+# undef pread
+# if HAVE_RAW_DECL_PREAD
+_GL_WARN_ON_USE (pread, "pread is unportable - "
+                 "use gnulib module pread for portability");
+# endif
+#endif
+
+
+#if 0
+/* Write at most BUFSIZE bytes from BUF into FD, starting at OFFSET.
+   Return the number of bytes written if successful, otherwise
+   set errno and return -1.  0 indicates nothing written.  See the
+   POSIX:2008 specification
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/pwrite.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef pwrite
+#   define pwrite rpl_pwrite
+#  endif
+_GL_FUNCDECL_RPL (pwrite, ssize_t,
+                  (int fd, const void *buf, size_t bufsize, off_t offset)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (pwrite, ssize_t,
+                  (int fd, const void *buf, size_t bufsize, off_t offset));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (pwrite, ssize_t,
+                  (int fd, const void *buf, size_t bufsize, off_t offset)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (pwrite, ssize_t,
+                  (int fd, const void *buf, size_t bufsize, off_t offset));
+# endif
+_GL_CXXALIASWARN (pwrite);
+#elif defined GNULIB_POSIXCHECK
+# undef pwrite
+# if HAVE_RAW_DECL_PWRITE
+_GL_WARN_ON_USE (pwrite, "pwrite is unportable - "
+                 "use gnulib module pwrite for portability");
+# endif
+#endif
+
+
+#if 0
+/* Read up to COUNT bytes from file descriptor FD into the buffer starting
+   at BUF.  See the POSIX:2008 specification
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/read.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef read
+#   define read rpl_read
+#  endif
+_GL_FUNCDECL_RPL (read, ssize_t, (int fd, void *buf, size_t count)
+                                 _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (read, ssize_t, (int fd, void *buf, size_t count));
+# elif defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef read
+#   define read _read
+#  endif
+_GL_CXXALIAS_MDA (read, ssize_t, (int fd, void *buf, size_t count));
+# else
+_GL_CXXALIAS_SYS (read, ssize_t, (int fd, void *buf, size_t count));
+# endif
+_GL_CXXALIASWARN (read);
+#elif 1
+/* On native Windows, map 'read' to '_read', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::read always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef read
+#   define read _read
+#  endif
+#  ifdef __MINGW32__
+_GL_CXXALIAS_MDA (read, int, (int fd, void *buf, unsigned int count));
+#  else
+_GL_CXXALIAS_MDA (read, ssize_t, (int fd, void *buf, unsigned int count));
+#  endif
+# else
+_GL_CXXALIAS_SYS (read, ssize_t, (int fd, void *buf, size_t count));
+# endif
+_GL_CXXALIASWARN (read);
+#endif
+
+
+#if 1
+/* Read the contents of the symbolic link FILE and place the first BUFSIZE
+   bytes of it into BUF.  Return the number of bytes placed into BUF if
+   successful, otherwise -1 and errno set.
+   See the POSIX:2008 specification
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/readlink.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define readlink rpl_readlink
+#  endif
+_GL_FUNCDECL_RPL (readlink, ssize_t,
+                  (const char *restrict file,
+                   char *restrict buf, size_t bufsize)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (readlink, ssize_t,
+                  (const char *restrict file,
+                   char *restrict buf, size_t bufsize));
+# else
+#  if !0
+_GL_FUNCDECL_SYS (readlink, ssize_t,
+                  (const char *restrict file,
+                   char *restrict buf, size_t bufsize)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (readlink, ssize_t,
+                  (const char *restrict file,
+                   char *restrict buf, size_t bufsize));
+# endif
+_GL_CXXALIASWARN (readlink);
+#elif defined GNULIB_POSIXCHECK
+# undef readlink
+# if HAVE_RAW_DECL_READLINK
+_GL_WARN_ON_USE (readlink, "readlink is unportable - "
+                 "use gnulib module readlink for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define readlinkat rpl_readlinkat
+#  endif
+_GL_FUNCDECL_RPL (readlinkat, ssize_t,
+                  (int fd, char const *restrict file,
+                   char *restrict buf, size_t len)
+                  _GL_ARG_NONNULL ((2, 3)));
+_GL_CXXALIAS_RPL (readlinkat, ssize_t,
+                  (int fd, char const *restrict file,
+                   char *restrict buf, size_t len));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (readlinkat, ssize_t,
+                  (int fd, char const *restrict file,
+                   char *restrict buf, size_t len)
+                  _GL_ARG_NONNULL ((2, 3)));
+#  endif
+_GL_CXXALIAS_SYS (readlinkat, ssize_t,
+                  (int fd, char const *restrict file,
+                   char *restrict buf, size_t len));
+# endif
+_GL_CXXALIASWARN (readlinkat);
+#elif defined GNULIB_POSIXCHECK
+# undef readlinkat
+# if HAVE_RAW_DECL_READLINKAT
+_GL_WARN_ON_USE (readlinkat, "readlinkat is not portable - "
+                 "use gnulib module readlinkat for portability");
+# endif
+#endif
+
+
+#if 1
+/* Remove the directory DIR.  */
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define rmdir rpl_rmdir
+#  endif
+_GL_FUNCDECL_RPL (rmdir, int, (char const *name) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (rmdir, int, (char const *name));
+# elif defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef rmdir
+#   define rmdir _rmdir
+#  endif
+_GL_CXXALIAS_MDA (rmdir, int, (char const *name));
+# else
+_GL_CXXALIAS_SYS (rmdir, int, (char const *name));
+# endif
+_GL_CXXALIASWARN (rmdir);
+#elif defined GNULIB_POSIXCHECK
+# undef rmdir
+# if HAVE_RAW_DECL_RMDIR
+_GL_WARN_ON_USE (rmdir, "rmdir is unportable - "
+                 "use gnulib module rmdir for portability");
+# endif
+#elif 1
+/* On native Windows, map 'rmdir' to '_rmdir', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::rmdir always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef rmdir
+#   define rmdir _rmdir
+#  endif
+_GL_CXXALIAS_MDA (rmdir, int, (char const *name));
+# else
+_GL_CXXALIAS_SYS (rmdir, int, (char const *name));
+# endif
+_GL_CXXALIASWARN (rmdir);
+#endif
+
+
+#if 0
+/* Set the host name of the machine.
+   The host name may or may not be fully qualified.
+
+   Put LEN bytes of NAME into the host name.
+   Return 0 if successful, otherwise, set errno and return -1.
+
+   Platforms with no ability to set the hostname return -1 and set
+   errno = ENOSYS.  */
+# if !1 || !1
+_GL_FUNCDECL_SYS (sethostname, int, (const char *name, size_t len)
+                                    _GL_ARG_NONNULL ((1)));
+# endif
+/* Need to cast, because on Solaris 11 2011-10, Mac OS X 10.5, IRIX 6.5
+   and FreeBSD 6.4 the second parameter is int.  On Solaris 11
+   2011-10, the first parameter is not const.  */
+_GL_CXXALIAS_SYS_CAST (sethostname, int, (const char *name, size_t len));
+_GL_CXXALIASWARN (sethostname);
+#elif defined GNULIB_POSIXCHECK
+# undef sethostname
+# if HAVE_RAW_DECL_SETHOSTNAME
+_GL_WARN_ON_USE (sethostname, "sethostname is unportable - "
+                 "use gnulib module sethostname for portability");
+# endif
+#endif
+
+
+#if IN_SED_GNULIB_TESTS
+/* Pause the execution of the current thread for N seconds.
+   Returns the number of seconds left to sleep.
+   See the POSIX:2008 specification
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sleep.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef sleep
+#   define sleep rpl_sleep
+#  endif
+_GL_FUNCDECL_RPL (sleep, unsigned int, (unsigned int n));
+_GL_CXXALIAS_RPL (sleep, unsigned int, (unsigned int n));
+# else
+#  if !0
+_GL_FUNCDECL_SYS (sleep, unsigned int, (unsigned int n));
+#  endif
+_GL_CXXALIAS_SYS (sleep, unsigned int, (unsigned int n));
+# endif
+_GL_CXXALIASWARN (sleep);
+#elif defined GNULIB_POSIXCHECK
+# undef sleep
+# if HAVE_RAW_DECL_SLEEP
+_GL_WARN_ON_USE (sleep, "sleep is unportable - "
+                 "use gnulib module sleep for portability");
+# endif
+#endif
+
+
+#if 1
+/* On native Windows, map 'swab' to '_swab', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::swab always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef swab
+#   define swab _swab
+#  endif
+/* Need to cast, because in old mingw the arguments are
+                             (const char *from, char *to, size_t n).  */
+_GL_CXXALIAS_MDA_CAST (swab, void, (char *from, char *to, int n));
+# else
+#  if defined __hpux /* HP-UX */
+_GL_CXXALIAS_SYS (swab, void, (const char *from, char *to, int n));
+#  elif defined __sun && (defined __SunOS_5_10 || defined __XOPEN_OR_POSIX) && !defined _XPG4 /* Solaris */
+_GL_CXXALIAS_SYS (swab, void, (const char *from, char *to, ssize_t n));
+#  else
+_GL_CXXALIAS_SYS (swab, void, (const void *from, void *to, ssize_t n));
+#  endif
+# endif
+_GL_CXXALIASWARN (swab);
+#endif
+
+
+#if IN_SED_GNULIB_TESTS
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef symlink
+#   define symlink rpl_symlink
+#  endif
+_GL_FUNCDECL_RPL (symlink, int, (char const *contents, char const *file)
+                                _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (symlink, int, (char const *contents, char const *file));
+# else
+#  if !0
+_GL_FUNCDECL_SYS (symlink, int, (char const *contents, char const *file)
+                                _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (symlink, int, (char const *contents, char const *file));
+# endif
+_GL_CXXALIASWARN (symlink);
+#elif defined GNULIB_POSIXCHECK
+# undef symlink
+# if HAVE_RAW_DECL_SYMLINK
+_GL_WARN_ON_USE (symlink, "symlink is not portable - "
+                 "use gnulib module symlink for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef symlinkat
+#   define symlinkat rpl_symlinkat
+#  endif
+_GL_FUNCDECL_RPL (symlinkat, int,
+                  (char const *contents, int fd, char const *file)
+                  _GL_ARG_NONNULL ((1, 3)));
+_GL_CXXALIAS_RPL (symlinkat, int,
+                  (char const *contents, int fd, char const *file));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (symlinkat, int,
+                  (char const *contents, int fd, char const *file)
+                  _GL_ARG_NONNULL ((1, 3)));
+#  endif
+_GL_CXXALIAS_SYS (symlinkat, int,
+                  (char const *contents, int fd, char const *file));
+# endif
+_GL_CXXALIASWARN (symlinkat);
+#elif defined GNULIB_POSIXCHECK
+# undef symlinkat
+# if HAVE_RAW_DECL_SYMLINKAT
+_GL_WARN_ON_USE (symlinkat, "symlinkat is not portable - "
+                 "use gnulib module symlinkat for portability");
+# endif
+#endif
+
+
+#if 0
+/* Change the size of the file designated by FILENAME to become equal to LENGTH.
+   Return 0 if successful, otherwise -1 and errno set.
+   See the POSIX:2008 specification
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/truncate.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef truncate
+#   define truncate rpl_truncate
+#  endif
+_GL_FUNCDECL_RPL (truncate, int, (const char *filename, off_t length)
+                                 _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (truncate, int, (const char *filename, off_t length));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (truncate, int, (const char *filename, off_t length)
+                                 _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (truncate, int, (const char *filename, off_t length));
+# endif
+_GL_CXXALIASWARN (truncate);
+#elif defined GNULIB_POSIXCHECK
+# undef truncate
+# if HAVE_RAW_DECL_TRUNCATE
+_GL_WARN_ON_USE (truncate, "truncate is unportable - "
+                 "use gnulib module truncate for portability");
+# endif
+#endif
+
+
+#if 0
+/* Store at most BUFLEN characters of the pathname of the terminal FD is
+   open on in BUF.  Return 0 on success, otherwise an error number.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef ttyname_r
+#   define ttyname_r rpl_ttyname_r
+#  endif
+_GL_FUNCDECL_RPL (ttyname_r, int,
+                  (int fd, char *buf, size_t buflen) _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (ttyname_r, int,
+                  (int fd, char *buf, size_t buflen));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (ttyname_r, int,
+                  (int fd, char *buf, size_t buflen) _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (ttyname_r, int,
+                  (int fd, char *buf, size_t buflen));
+# endif
+_GL_CXXALIASWARN (ttyname_r);
+#elif defined GNULIB_POSIXCHECK
+# undef ttyname_r
+# if HAVE_RAW_DECL_TTYNAME_R
+_GL_WARN_ON_USE (ttyname_r, "ttyname_r is not portable - "
+                 "use gnulib module ttyname_r for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef unlink
+#   define unlink rpl_unlink
+#  endif
+_GL_FUNCDECL_RPL (unlink, int, (char const *file) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (unlink, int, (char const *file));
+# elif defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef unlink
+#   define unlink _unlink
+#  endif
+_GL_CXXALIAS_MDA (unlink, int, (char const *file));
+# else
+_GL_CXXALIAS_SYS (unlink, int, (char const *file));
+# endif
+_GL_CXXALIASWARN (unlink);
+#elif defined GNULIB_POSIXCHECK
+# undef unlink
+# if HAVE_RAW_DECL_UNLINK
+_GL_WARN_ON_USE (unlink, "unlink is not portable - "
+                 "use gnulib module unlink for portability");
+# endif
+#elif 1
+/* On native Windows, map 'unlink' to '_unlink', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::unlink always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef unlink
+#   define unlink _unlink
+#  endif
+_GL_CXXALIAS_MDA (unlink, int, (char const *file));
+# else
+_GL_CXXALIAS_SYS (unlink, int, (char const *file));
+# endif
+_GL_CXXALIASWARN (unlink);
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef unlinkat
+#   define unlinkat rpl_unlinkat
+#  endif
+_GL_FUNCDECL_RPL (unlinkat, int, (int fd, char const *file, int flag)
+                                 _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (unlinkat, int, (int fd, char const *file, int flag));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (unlinkat, int, (int fd, char const *file, int flag)
+                                 _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (unlinkat, int, (int fd, char const *file, int flag));
+# endif
+_GL_CXXALIASWARN (unlinkat);
+#elif defined GNULIB_POSIXCHECK
+# undef unlinkat
+# if HAVE_RAW_DECL_UNLINKAT
+_GL_WARN_ON_USE (unlinkat, "unlinkat is not portable - "
+                 "use gnulib module unlinkat for portability");
+# endif
+#endif
+
+
+#if 0
+/* Pause the execution of the current thread for N microseconds.
+   Returns 0 on completion, or -1 on range error.
+   See the POSIX:2001 specification
+   <https://pubs.opengroup.org/onlinepubs/009695399/functions/usleep.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef usleep
+#   define usleep rpl_usleep
+#  endif
+_GL_FUNCDECL_RPL (usleep, int, (useconds_t n));
+_GL_CXXALIAS_RPL (usleep, int, (useconds_t n));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (usleep, int, (useconds_t n));
+#  endif
+/* Need to cast, because on Haiku, the first parameter is
+                                     unsigned int n.  */
+_GL_CXXALIAS_SYS_CAST (usleep, int, (useconds_t n));
+# endif
+_GL_CXXALIASWARN (usleep);
+#elif defined GNULIB_POSIXCHECK
+# undef usleep
+# if HAVE_RAW_DECL_USLEEP
+_GL_WARN_ON_USE (usleep, "usleep is unportable - "
+                 "use gnulib module usleep for portability");
+# endif
+#endif
+
+
+#if 0
+/* Write up to COUNT bytes starting at BUF to file descriptor FD.
+   See the POSIX:2008 specification
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef write
+#   define write rpl_write
+#  endif
+_GL_FUNCDECL_RPL (write, ssize_t, (int fd, const void *buf, size_t count)
+                                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (write, ssize_t, (int fd, const void *buf, size_t count));
+# elif defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef write
+#   define write _write
+#  endif
+_GL_CXXALIAS_MDA (write, ssize_t, (int fd, const void *buf, size_t count));
+# else
+_GL_CXXALIAS_SYS (write, ssize_t, (int fd, const void *buf, size_t count));
+# endif
+_GL_CXXALIASWARN (write);
+#elif 1
+/* On native Windows, map 'write' to '_write', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::write always.  */
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef write
+#   define write _write
+#  endif
+#  ifdef __MINGW32__
+_GL_CXXALIAS_MDA (write, int, (int fd, const void *buf, unsigned int count));
+#  else
+_GL_CXXALIAS_MDA (write, ssize_t, (int fd, const void *buf, unsigned int count));
+#  endif
+# else
+_GL_CXXALIAS_SYS (write, ssize_t, (int fd, const void *buf, size_t count));
+# endif
+_GL_CXXALIASWARN (write);
+#endif
+
+_GL_INLINE_HEADER_END
+
+#endif /* _GL_UNISTD_H */
+#endif /* _GL_INCLUDING_UNISTD_H */
+#endif /* _GL_UNISTD_H */
diff -Naur ../orig/sed-4.9/lib/wchar.h ./lib/wchar.h
--- ../orig/sed-4.9/lib/wchar.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/wchar.h	2022-12-01 17:13:19.169986400 +0300
@@ -0,0 +1,1863 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A substitute for ISO C99 <wchar.h>, for platforms that have issues.
+
+   Copyright (C) 2007-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* Written by Eric Blake.  */
+
+/*
+ * ISO C 99 <wchar.h> for platforms that have issues.
+ * <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/wchar.h.html>
+ *
+ * For now, this just ensures proper prerequisite inclusion order and
+ * the declaration of wcwidth().
+ */
+
+#if __GNUC__ >= 3
+
+#endif
+
+
+#if (((defined __need_mbstate_t || defined __need_wint_t)               \
+      && !defined __MINGW32__)                                          \
+     || (defined __hpux                                                 \
+         && ((defined _INTTYPES_INCLUDED                                \
+              && !defined _GL_FINISHED_INCLUDING_SYSTEM_INTTYPES_H)     \
+             || defined _GL_JUST_INCLUDE_SYSTEM_WCHAR_H))               \
+     || (defined __MINGW32__ && defined __STRING_H_SOURCED__)           \
+     || defined _GL_ALREADY_INCLUDING_WCHAR_H)
+/* Special invocation convention:
+   - Inside glibc and uClibc header files, but not MinGW.
+   - On HP-UX 11.00 we have a sequence of nested includes
+     <wchar.h> -> <stdlib.h> -> <stdint.h>, and the latter includes <wchar.h>,
+     once indirectly <stdint.h> -> <sys/types.h> -> <inttypes.h> -> <wchar.h>
+     and once directly.  In both situations 'wint_t' is not yet defined,
+     therefore we cannot provide the function overrides; instead include only
+     the system's <wchar.h>.
+   - With MinGW 3.22, when <string.h> includes <wchar.h>, only some part of
+     <wchar.h> is actually processed, and that doesn't include 'mbstate_t'.
+   - On IRIX 6.5, similarly, we have an include <wchar.h> -> <wctype.h>, and
+     the latter includes <wchar.h>.  But here, we have no way to detect whether
+     <wctype.h> is completely included or is still being included.  */
+
+#include ""
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_WCHAR_H
+
+#define _GL_ALREADY_INCLUDING_WCHAR_H
+
+#if 0
+# include <features.h> /* for __GLIBC__ */
+#endif
+
+/* In some builds of uClibc, <wchar.h> is nonexistent and wchar_t is defined
+   by <stddef.h>.
+   But avoid namespace pollution on glibc systems.  */
+#if !(defined __GLIBC__ && !defined __UCLIBC__)
+# include <stddef.h>
+#endif
+
+/* Include the original <wchar.h> if it exists.
+   Some builds of uClibc lack it.  */
+/* The include_next requires a split double-inclusion guard.  */
+#if 1
+# include "C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\INCLUDE\wchar.h"
+#endif
+
+#undef _GL_ALREADY_INCLUDING_WCHAR_H
+
+#ifndef _GL_WCHAR_H
+#define _GL_WCHAR_H
+
+/* _GL_ATTRIBUTE_DEALLOC (F, I) declares that the function returns pointers
+   that can be freed by passing them as the Ith argument to the
+   function F.  */
+#ifndef _GL_ATTRIBUTE_DEALLOC
+# if __GNUC__ >= 11
+#  define _GL_ATTRIBUTE_DEALLOC(f, i) __attribute__ ((__malloc__ (f, i)))
+# else
+#  define _GL_ATTRIBUTE_DEALLOC(f, i)
+# endif
+#endif
+
+/* _GL_ATTRIBUTE_DEALLOC_FREE declares that the function returns pointers that
+   can be freed via 'free'; it can be used only after declaring 'free'.  */
+/* Applies to: functions.  Cannot be used on inline functions.  */
+#ifndef _GL_ATTRIBUTE_DEALLOC_FREE
+# define _GL_ATTRIBUTE_DEALLOC_FREE _GL_ATTRIBUTE_DEALLOC (free, 1)
+#endif
+
+/* _GL_ATTRIBUTE_MALLOC declares that the function returns a pointer to freshly
+   allocated memory.  */
+/* Applies to: functions.  */
+#ifndef _GL_ATTRIBUTE_MALLOC
+# if __GNUC__ >= 3 || defined __clang__
+#  define _GL_ATTRIBUTE_MALLOC __attribute__ ((__malloc__))
+# else
+#  define _GL_ATTRIBUTE_MALLOC
+# endif
+#endif
+
+/* The __attribute__ feature is available in gcc versions 2.5 and later.
+   The attribute __pure__ was added in gcc 2.96.  */
+#ifndef _GL_ATTRIBUTE_PURE
+# if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96) || defined __clang__
+#  define _GL_ATTRIBUTE_PURE __attribute__ ((__pure__))
+# else
+#  define _GL_ATTRIBUTE_PURE /* empty */
+# endif
+#endif
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA (func, rettype, parameters);
+   is to be used when func is a Microsoft deprecated alias, on native Windows.
+   It declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to _func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_MDA (open, int, (const char *filename, int flags, ...));
+ */
+#define _GL_CXXALIAS_MDA(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_MDA (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#define _GL_CXXALIAS_MDA_CAST(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_CAST_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || defined __clang__
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype_gcc, rettype_clang, parameters_and_attributes, "message")
+   is like _GL_WARN_ON_USE (function, "message"), except that in C++ mode the
+   function is declared with the given prototype, consisting of return type,
+   parameters, and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if !defined __cplusplus
+#  define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+     _GL_WARN_ON_USE (function, msg)
+# else
+#  if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes \
+  __attribute__ ((__warning__ (msg)))
+#  elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_clang function parameters_and_attributes \
+  __attribute__ ((__diagnose_if__ (1, msg, "warning")))
+#  elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes
+#  else /* Unsupported.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  endif
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+
+/* Define wint_t and WEOF.  (Also done in wctype.in.h.)  */
+#if !1 && !defined wint_t
+# define wint_t int
+# ifndef WEOF
+#  define WEOF -1
+# endif
+#else
+/* mingw and MSVC define wint_t as 'unsigned short' in <crtdefs.h> or
+   <stddef.h>.  This is too small: ISO C 99 section 7.24.1.(2) says that
+   wint_t must be "unchanged by default argument promotions".  Override it.  */
+# if 1
+#  if !GNULIB_defined_wint_t
+#   if 1
+#    include <crtdefs.h>
+#   else
+#    include <stddef.h>
+#   endif
+typedef unsigned int rpl_wint_t;
+#   undef wint_t
+#   define wint_t rpl_wint_t
+#   define GNULIB_defined_wint_t 1
+#  endif
+# endif
+# ifndef WEOF
+#  define WEOF ((wint_t) -1)
+# endif
+#endif
+
+
+/* Override mbstate_t if it is too small.
+   On IRIX 6.5, sizeof (mbstate_t) == 1, which is not sufficient for
+   implementing mbrtowc for encodings like UTF-8.
+   On AIX and MSVC, mbrtowc needs to be overridden, but mbstate_t exists and is
+   large enough and overriding it would cause problems in C++ mode.  */
+#if !(((defined _WIN32 && !defined __CYGWIN__) || 0) && 1) || 1
+# if !GNULIB_defined_mbstate_t
+#  if !(defined _AIX || defined _MSC_VER)
+typedef int rpl_mbstate_t;
+#   undef mbstate_t
+#   define mbstate_t rpl_mbstate_t
+#  endif
+#  define GNULIB_defined_mbstate_t 1
+# endif
+#endif
+
+/* Make _GL_ATTRIBUTE_DEALLOC_FREE work, even though <stdlib.h> may not have
+   been included yet.  */
+#if 1
+# if (1 && !defined free \
+      && !(defined __cplusplus && defined GNULIB_NAMESPACE))
+/* We can't do '#define free rpl_free' here.  */
+_GL_EXTERN_C void rpl_free (void *);
+#  undef _GL_ATTRIBUTE_DEALLOC_FREE
+#  define _GL_ATTRIBUTE_DEALLOC_FREE _GL_ATTRIBUTE_DEALLOC (rpl_free, 1)
+# else
+#  if defined _MSC_VER && !defined free
+_GL_EXTERN_C
+#   if defined _DLL
+     __declspec (dllimport)
+#   endif
+     void __cdecl free (void *);
+#  else
+#   if defined __cplusplus && (__GLIBC__ + (__GLIBC_MINOR__ >= 14) > 2)
+_GL_EXTERN_C void free (void *) throw ();
+#   else
+_GL_EXTERN_C void free (void *);
+#   endif
+#  endif
+# endif
+#else
+# if defined _MSC_VER && !defined free
+_GL_EXTERN_C
+#   if defined _DLL
+     __declspec (dllimport)
+#   endif
+     void __cdecl free (void *);
+# else
+#  if defined __cplusplus && (__GLIBC__ + (__GLIBC_MINOR__ >= 14) > 2)
+_GL_EXTERN_C void free (void *) throw ();
+#  else
+_GL_EXTERN_C void free (void *);
+#  endif
+# endif
+#endif
+
+/* Convert a single-byte character to a wide character.  */
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef btowc
+#   define btowc rpl_btowc
+#  endif
+_GL_FUNCDECL_RPL (btowc, wint_t, (int c) _GL_ATTRIBUTE_PURE);
+_GL_CXXALIAS_RPL (btowc, wint_t, (int c));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (btowc, wint_t, (int c) _GL_ATTRIBUTE_PURE);
+#  endif
+/* Need to cast, because on mingw, the return type is 'unsigned short'.  */
+_GL_CXXALIAS_SYS_CAST (btowc, wint_t, (int c));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (btowc);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef btowc
+# if HAVE_RAW_DECL_BTOWC
+_GL_WARN_ON_USE (btowc, "btowc is unportable - "
+                 "use gnulib module btowc for portability");
+# endif
+#endif
+
+
+/* Convert a wide character to a single-byte character.  */
+#if 1
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wctob
+#   define wctob rpl_wctob
+#  endif
+_GL_FUNCDECL_RPL (wctob, int, (wint_t wc) _GL_ATTRIBUTE_PURE);
+_GL_CXXALIAS_RPL (wctob, int, (wint_t wc));
+# else
+#  if !defined wctob && !1
+/* wctob is provided by gnulib, or wctob exists but is not declared.  */
+_GL_FUNCDECL_SYS (wctob, int, (wint_t wc) _GL_ATTRIBUTE_PURE);
+#  endif
+_GL_CXXALIAS_SYS (wctob, int, (wint_t wc));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wctob);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wctob
+# if HAVE_RAW_DECL_WCTOB
+_GL_WARN_ON_USE (wctob, "wctob is unportable - "
+                 "use gnulib module wctob for portability");
+# endif
+#endif
+
+
+/* Test whether *PS is in the initial state.  */
+#if 1
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbsinit
+#   define mbsinit rpl_mbsinit
+#  endif
+_GL_FUNCDECL_RPL (mbsinit, int, (const mbstate_t *ps));
+_GL_CXXALIAS_RPL (mbsinit, int, (const mbstate_t *ps));
+# else
+#  if !0
+_GL_FUNCDECL_SYS (mbsinit, int, (const mbstate_t *ps));
+#  endif
+_GL_CXXALIAS_SYS (mbsinit, int, (const mbstate_t *ps));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (mbsinit);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef mbsinit
+# if HAVE_RAW_DECL_MBSINIT
+_GL_WARN_ON_USE (mbsinit, "mbsinit is unportable - "
+                 "use gnulib module mbsinit for portability");
+# endif
+#endif
+
+
+/* Convert a multibyte character to a wide character.  */
+#if 1
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbrtowc
+#   define mbrtowc rpl_mbrtowc
+#  endif
+_GL_FUNCDECL_RPL (mbrtowc, size_t,
+                  (wchar_t *restrict pwc, const char *restrict s, size_t n,
+                   mbstate_t *restrict ps));
+_GL_CXXALIAS_RPL (mbrtowc, size_t,
+                  (wchar_t *restrict pwc, const char *restrict s, size_t n,
+                   mbstate_t *restrict ps));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (mbrtowc, size_t,
+                  (wchar_t *restrict pwc, const char *restrict s, size_t n,
+                   mbstate_t *restrict ps));
+#  endif
+_GL_CXXALIAS_SYS (mbrtowc, size_t,
+                  (wchar_t *restrict pwc, const char *restrict s, size_t n,
+                   mbstate_t *restrict ps));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (mbrtowc);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef mbrtowc
+# if HAVE_RAW_DECL_MBRTOWC
+_GL_WARN_ON_USE (mbrtowc, "mbrtowc is unportable - "
+                 "use gnulib module mbrtowc for portability");
+# endif
+#endif
+
+
+/* Recognize a multibyte character.  */
+#if 1
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbrlen
+#   define mbrlen rpl_mbrlen
+#  endif
+_GL_FUNCDECL_RPL (mbrlen, size_t,
+                  (const char *restrict s, size_t n, mbstate_t *restrict ps));
+_GL_CXXALIAS_RPL (mbrlen, size_t,
+                  (const char *restrict s, size_t n, mbstate_t *restrict ps));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (mbrlen, size_t,
+                  (const char *restrict s, size_t n, mbstate_t *restrict ps));
+#  endif
+_GL_CXXALIAS_SYS (mbrlen, size_t,
+                  (const char *restrict s, size_t n, mbstate_t *restrict ps));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (mbrlen);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef mbrlen
+# if HAVE_RAW_DECL_MBRLEN
+_GL_WARN_ON_USE (mbrlen, "mbrlen is unportable - "
+                 "use gnulib module mbrlen for portability");
+# endif
+#endif
+
+
+/* Convert a string to a wide string.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbsrtowcs
+#   define mbsrtowcs rpl_mbsrtowcs
+#  endif
+_GL_FUNCDECL_RPL (mbsrtowcs, size_t,
+                  (wchar_t *restrict dest,
+                   const char **restrict srcp, size_t len,
+                   mbstate_t *restrict ps)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (mbsrtowcs, size_t,
+                  (wchar_t *restrict dest,
+                   const char **restrict srcp, size_t len,
+                   mbstate_t *restrict ps));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (mbsrtowcs, size_t,
+                  (wchar_t *restrict dest,
+                   const char **restrict srcp, size_t len,
+                   mbstate_t *restrict ps)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (mbsrtowcs, size_t,
+                  (wchar_t *restrict dest,
+                   const char **restrict srcp, size_t len,
+                   mbstate_t *restrict ps));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (mbsrtowcs);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef mbsrtowcs
+# if HAVE_RAW_DECL_MBSRTOWCS
+_GL_WARN_ON_USE (mbsrtowcs, "mbsrtowcs is unportable - "
+                 "use gnulib module mbsrtowcs for portability");
+# endif
+#endif
+
+
+/* Convert a string to a wide string.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbsnrtowcs
+#   define mbsnrtowcs rpl_mbsnrtowcs
+#  endif
+_GL_FUNCDECL_RPL (mbsnrtowcs, size_t,
+                  (wchar_t *restrict dest,
+                   const char **restrict srcp, size_t srclen, size_t len,
+                   mbstate_t *restrict ps)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (mbsnrtowcs, size_t,
+                  (wchar_t *restrict dest,
+                   const char **restrict srcp, size_t srclen, size_t len,
+                   mbstate_t *restrict ps));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (mbsnrtowcs, size_t,
+                  (wchar_t *restrict dest,
+                   const char **restrict srcp, size_t srclen, size_t len,
+                   mbstate_t *restrict ps)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (mbsnrtowcs, size_t,
+                  (wchar_t *restrict dest,
+                   const char **restrict srcp, size_t srclen, size_t len,
+                   mbstate_t *restrict ps));
+# endif
+_GL_CXXALIASWARN (mbsnrtowcs);
+#elif defined GNULIB_POSIXCHECK
+# undef mbsnrtowcs
+# if HAVE_RAW_DECL_MBSNRTOWCS
+_GL_WARN_ON_USE (mbsnrtowcs, "mbsnrtowcs is unportable - "
+                 "use gnulib module mbsnrtowcs for portability");
+# endif
+#endif
+
+
+/* Convert a wide character to a multibyte character.  */
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcrtomb
+#   define wcrtomb rpl_wcrtomb
+#  endif
+_GL_FUNCDECL_RPL (wcrtomb, size_t,
+                  (char *restrict s, wchar_t wc, mbstate_t *restrict ps));
+_GL_CXXALIAS_RPL (wcrtomb, size_t,
+                  (char *restrict s, wchar_t wc, mbstate_t *restrict ps));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (wcrtomb, size_t,
+                  (char *restrict s, wchar_t wc, mbstate_t *restrict ps));
+#  endif
+_GL_CXXALIAS_SYS (wcrtomb, size_t,
+                  (char *restrict s, wchar_t wc, mbstate_t *restrict ps));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcrtomb);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcrtomb
+# if HAVE_RAW_DECL_WCRTOMB
+_GL_WARN_ON_USE (wcrtomb, "wcrtomb is unportable - "
+                 "use gnulib module wcrtomb for portability");
+# endif
+#endif
+
+
+/* Convert a wide string to a string.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcsrtombs
+#   define wcsrtombs rpl_wcsrtombs
+#  endif
+_GL_FUNCDECL_RPL (wcsrtombs, size_t,
+                  (char *restrict dest, const wchar_t **restrict srcp,
+                   size_t len,
+                   mbstate_t *restrict ps)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (wcsrtombs, size_t,
+                  (char *restrict dest, const wchar_t **restrict srcp,
+                   size_t len,
+                   mbstate_t *restrict ps));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (wcsrtombs, size_t,
+                  (char *restrict dest, const wchar_t **restrict srcp,
+                   size_t len,
+                   mbstate_t *restrict ps)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (wcsrtombs, size_t,
+                  (char *restrict dest, const wchar_t **restrict srcp,
+                   size_t len,
+                   mbstate_t *restrict ps));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcsrtombs);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcsrtombs
+# if HAVE_RAW_DECL_WCSRTOMBS
+_GL_WARN_ON_USE (wcsrtombs, "wcsrtombs is unportable - "
+                 "use gnulib module wcsrtombs for portability");
+# endif
+#endif
+
+
+/* Convert a wide string to a string.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcsnrtombs
+#   define wcsnrtombs rpl_wcsnrtombs
+#  endif
+_GL_FUNCDECL_RPL (wcsnrtombs, size_t,
+                  (char *restrict dest,
+                   const wchar_t **restrict srcp, size_t srclen,
+                   size_t len,
+                   mbstate_t *restrict ps)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (wcsnrtombs, size_t,
+                  (char *restrict dest,
+                   const wchar_t **restrict srcp, size_t srclen,
+                   size_t len,
+                   mbstate_t *restrict ps));
+# else
+#  if !1 || (defined __cplusplus && defined __sun)
+_GL_FUNCDECL_SYS (wcsnrtombs, size_t,
+                  (char *restrict dest,
+                   const wchar_t **restrict srcp, size_t srclen,
+                   size_t len,
+                   mbstate_t *restrict ps)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (wcsnrtombs, size_t,
+                  (char *restrict dest,
+                   const wchar_t **restrict srcp, size_t srclen,
+                   size_t len,
+                   mbstate_t *restrict ps));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcsnrtombs);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcsnrtombs
+# if HAVE_RAW_DECL_WCSNRTOMBS
+_GL_WARN_ON_USE (wcsnrtombs, "wcsnrtombs is unportable - "
+                 "use gnulib module wcsnrtombs for portability");
+# endif
+#endif
+
+
+/* Return the number of screen columns needed for WC.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcwidth
+#   define wcwidth rpl_wcwidth
+#  endif
+_GL_FUNCDECL_RPL (wcwidth, int, (wchar_t) _GL_ATTRIBUTE_PURE);
+_GL_CXXALIAS_RPL (wcwidth, int, (wchar_t));
+# else
+#  if !1
+/* wcwidth exists but is not declared.  */
+_GL_FUNCDECL_SYS (wcwidth, int, (wchar_t) _GL_ATTRIBUTE_PURE);
+#  endif
+_GL_CXXALIAS_SYS (wcwidth, int, (wchar_t));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcwidth);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcwidth
+# if HAVE_RAW_DECL_WCWIDTH
+_GL_WARN_ON_USE (wcwidth, "wcwidth is unportable - "
+                 "use gnulib module wcwidth for portability");
+# endif
+#endif
+
+
+/* Search N wide characters of S for C.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wmemchr, wchar_t *, (const wchar_t *s, wchar_t c, size_t n)
+                                      _GL_ATTRIBUTE_PURE);
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" {
+         const wchar_t * std::wmemchr (const wchar_t *, wchar_t, size_t);
+         wchar_t * std::wmemchr (wchar_t *, wchar_t, size_t);
+       }  */
+_GL_CXXALIAS_SYS_CAST2 (wmemchr,
+                        wchar_t *, (const wchar_t *, wchar_t, size_t),
+                        const wchar_t *, (const wchar_t *, wchar_t, size_t));
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (wmemchr, wchar_t *, (wchar_t *s, wchar_t c, size_t n));
+_GL_CXXALIASWARN1 (wmemchr, const wchar_t *,
+                   (const wchar_t *s, wchar_t c, size_t n));
+# elif __GLIBC__ >= 2
+_GL_CXXALIASWARN (wmemchr);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wmemchr
+# if HAVE_RAW_DECL_WMEMCHR
+_GL_WARN_ON_USE (wmemchr, "wmemchr is unportable - "
+                 "use gnulib module wmemchr for portability");
+# endif
+#endif
+
+
+/* Compare N wide characters of S1 and S2.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wmemcmp, int,
+                  (const wchar_t *s1, const wchar_t *s2, size_t n)
+                  _GL_ATTRIBUTE_PURE);
+# endif
+_GL_CXXALIAS_SYS (wmemcmp, int,
+                  (const wchar_t *s1, const wchar_t *s2, size_t n));
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wmemcmp);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wmemcmp
+# if HAVE_RAW_DECL_WMEMCMP
+_GL_WARN_ON_USE (wmemcmp, "wmemcmp is unportable - "
+                 "use gnulib module wmemcmp for portability");
+# endif
+#endif
+
+
+/* Copy N wide characters of SRC to DEST.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wmemcpy, wchar_t *,
+                  (wchar_t *restrict dest,
+                   const wchar_t *restrict src, size_t n));
+# endif
+_GL_CXXALIAS_SYS (wmemcpy, wchar_t *,
+                  (wchar_t *restrict dest,
+                   const wchar_t *restrict src, size_t n));
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wmemcpy);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wmemcpy
+# if HAVE_RAW_DECL_WMEMCPY
+_GL_WARN_ON_USE (wmemcpy, "wmemcpy is unportable - "
+                 "use gnulib module wmemcpy for portability");
+# endif
+#endif
+
+
+/* Copy N wide characters of SRC to DEST, guaranteeing correct behavior for
+   overlapping memory areas.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wmemmove, wchar_t *,
+                  (wchar_t *dest, const wchar_t *src, size_t n));
+# endif
+_GL_CXXALIAS_SYS (wmemmove, wchar_t *,
+                  (wchar_t *dest, const wchar_t *src, size_t n));
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wmemmove);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wmemmove
+# if HAVE_RAW_DECL_WMEMMOVE
+_GL_WARN_ON_USE (wmemmove, "wmemmove is unportable - "
+                 "use gnulib module wmemmove for portability");
+# endif
+#endif
+
+
+/* Copy N wide characters of SRC to DEST.
+   Return pointer to wide characters after the last written wide character.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wmempcpy, wchar_t *,
+                  (wchar_t *restrict dest,
+                   const wchar_t *restrict src, size_t n));
+# endif
+_GL_CXXALIAS_SYS (wmempcpy, wchar_t *,
+                  (wchar_t *restrict dest,
+                   const wchar_t *restrict src, size_t n));
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wmempcpy);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wmempcpy
+# if HAVE_RAW_DECL_WMEMPCPY
+_GL_WARN_ON_USE (wmempcpy, "wmempcpy is unportable - "
+                 "use gnulib module wmempcpy for portability");
+# endif
+#endif
+
+
+/* Set N wide characters of S to C.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wmemset, wchar_t *, (wchar_t *s, wchar_t c, size_t n));
+# endif
+_GL_CXXALIAS_SYS (wmemset, wchar_t *, (wchar_t *s, wchar_t c, size_t n));
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wmemset);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wmemset
+# if HAVE_RAW_DECL_WMEMSET
+_GL_WARN_ON_USE (wmemset, "wmemset is unportable - "
+                 "use gnulib module wmemset for portability");
+# endif
+#endif
+
+
+/* Return the number of wide characters in S.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcslen, size_t, (const wchar_t *s) _GL_ATTRIBUTE_PURE);
+# endif
+_GL_CXXALIAS_SYS (wcslen, size_t, (const wchar_t *s));
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcslen);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcslen
+# if HAVE_RAW_DECL_WCSLEN
+_GL_WARN_ON_USE (wcslen, "wcslen is unportable - "
+                 "use gnulib module wcslen for portability");
+# endif
+#endif
+
+
+/* Return the number of wide characters in S, but at most MAXLEN.  */
+#if 0
+/* On Solaris 11.3, the header files declare the function in the std::
+   namespace, not in the global namespace.  So, force a declaration in
+   the global namespace.  */
+# if !1 || (defined __sun && defined __cplusplus)
+_GL_FUNCDECL_SYS (wcsnlen, size_t, (const wchar_t *s, size_t maxlen)
+                                   _GL_ATTRIBUTE_PURE);
+# endif
+_GL_CXXALIAS_SYS (wcsnlen, size_t, (const wchar_t *s, size_t maxlen));
+_GL_CXXALIASWARN (wcsnlen);
+#elif defined GNULIB_POSIXCHECK
+# undef wcsnlen
+# if HAVE_RAW_DECL_WCSNLEN
+_GL_WARN_ON_USE (wcsnlen, "wcsnlen is unportable - "
+                 "use gnulib module wcsnlen for portability");
+# endif
+#endif
+
+
+/* Copy SRC to DEST.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcscpy, wchar_t *,
+                  (wchar_t *restrict dest, const wchar_t *restrict src));
+# endif
+_GL_CXXALIAS_SYS (wcscpy, wchar_t *,
+                  (wchar_t *restrict dest, const wchar_t *restrict src));
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcscpy);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcscpy
+# if HAVE_RAW_DECL_WCSCPY
+_GL_WARN_ON_USE (wcscpy, "wcscpy is unportable - "
+                 "use gnulib module wcscpy for portability");
+# endif
+#endif
+
+
+/* Copy SRC to DEST, returning the address of the terminating L'\0' in DEST.  */
+#if 0
+/* On Solaris 11.3, the header files declare the function in the std::
+   namespace, not in the global namespace.  So, force a declaration in
+   the global namespace.  */
+# if !1 || (defined __sun && defined __cplusplus)
+_GL_FUNCDECL_SYS (wcpcpy, wchar_t *,
+                  (wchar_t *restrict dest, const wchar_t *restrict src));
+# endif
+_GL_CXXALIAS_SYS (wcpcpy, wchar_t *,
+                  (wchar_t *restrict dest, const wchar_t *restrict src));
+_GL_CXXALIASWARN (wcpcpy);
+#elif defined GNULIB_POSIXCHECK
+# undef wcpcpy
+# if HAVE_RAW_DECL_WCPCPY
+_GL_WARN_ON_USE (wcpcpy, "wcpcpy is unportable - "
+                 "use gnulib module wcpcpy for portability");
+# endif
+#endif
+
+
+/* Copy no more than N wide characters of SRC to DEST.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcsncpy, wchar_t *,
+                  (wchar_t *restrict dest,
+                   const wchar_t *restrict src, size_t n));
+# endif
+_GL_CXXALIAS_SYS (wcsncpy, wchar_t *,
+                  (wchar_t *restrict dest,
+                   const wchar_t *restrict src, size_t n));
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcsncpy);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcsncpy
+# if HAVE_RAW_DECL_WCSNCPY
+_GL_WARN_ON_USE (wcsncpy, "wcsncpy is unportable - "
+                 "use gnulib module wcsncpy for portability");
+# endif
+#endif
+
+
+/* Copy no more than N characters of SRC to DEST, returning the address of
+   the last character written into DEST.  */
+#if 0
+/* On Solaris 11.3, the header files declare the function in the std::
+   namespace, not in the global namespace.  So, force a declaration in
+   the global namespace.  */
+# if !1 || (defined __sun && defined __cplusplus)
+_GL_FUNCDECL_SYS (wcpncpy, wchar_t *,
+                  (wchar_t *restrict dest,
+                   const wchar_t *restrict src, size_t n));
+# endif
+_GL_CXXALIAS_SYS (wcpncpy, wchar_t *,
+                  (wchar_t *restrict dest,
+                   const wchar_t *restrict src, size_t n));
+_GL_CXXALIASWARN (wcpncpy);
+#elif defined GNULIB_POSIXCHECK
+# undef wcpncpy
+# if HAVE_RAW_DECL_WCPNCPY
+_GL_WARN_ON_USE (wcpncpy, "wcpncpy is unportable - "
+                 "use gnulib module wcpncpy for portability");
+# endif
+#endif
+
+
+/* Append SRC onto DEST.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcscat, wchar_t *,
+                  (wchar_t *restrict dest, const wchar_t *restrict src));
+# endif
+_GL_CXXALIAS_SYS (wcscat, wchar_t *,
+                  (wchar_t *restrict dest, const wchar_t *restrict src));
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcscat);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcscat
+# if HAVE_RAW_DECL_WCSCAT
+_GL_WARN_ON_USE (wcscat, "wcscat is unportable - "
+                 "use gnulib module wcscat for portability");
+# endif
+#endif
+
+
+/* Append no more than N wide characters of SRC onto DEST.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcsncat, wchar_t *,
+                  (wchar_t *restrict dest, const wchar_t *restrict src,
+                   size_t n));
+# endif
+_GL_CXXALIAS_SYS (wcsncat, wchar_t *,
+                  (wchar_t *restrict dest, const wchar_t *restrict src,
+                   size_t n));
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcsncat);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcsncat
+# if HAVE_RAW_DECL_WCSNCAT
+_GL_WARN_ON_USE (wcsncat, "wcsncat is unportable - "
+                 "use gnulib module wcsncat for portability");
+# endif
+#endif
+
+
+/* Compare S1 and S2.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcscmp, int, (const wchar_t *s1, const wchar_t *s2)
+                               _GL_ATTRIBUTE_PURE);
+# endif
+_GL_CXXALIAS_SYS (wcscmp, int, (const wchar_t *s1, const wchar_t *s2));
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcscmp);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcscmp
+# if HAVE_RAW_DECL_WCSCMP
+_GL_WARN_ON_USE (wcscmp, "wcscmp is unportable - "
+                 "use gnulib module wcscmp for portability");
+# endif
+#endif
+
+
+/* Compare no more than N wide characters of S1 and S2.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcsncmp, int,
+                  (const wchar_t *s1, const wchar_t *s2, size_t n)
+                  _GL_ATTRIBUTE_PURE);
+# endif
+_GL_CXXALIAS_SYS (wcsncmp, int,
+                  (const wchar_t *s1, const wchar_t *s2, size_t n));
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcsncmp);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcsncmp
+# if HAVE_RAW_DECL_WCSNCMP
+_GL_WARN_ON_USE (wcsncmp, "wcsncmp is unportable - "
+                 "use gnulib module wcsncmp for portability");
+# endif
+#endif
+
+
+/* Compare S1 and S2, ignoring case.  */
+#if 0
+/* On Solaris 11.3, the header files declare the function in the std::
+   namespace, not in the global namespace.  So, force a declaration in
+   the global namespace.  */
+# if !1 || (defined __sun && defined __cplusplus)
+_GL_FUNCDECL_SYS (wcscasecmp, int, (const wchar_t *s1, const wchar_t *s2)
+                                   _GL_ATTRIBUTE_PURE);
+# endif
+_GL_CXXALIAS_SYS (wcscasecmp, int, (const wchar_t *s1, const wchar_t *s2));
+_GL_CXXALIASWARN (wcscasecmp);
+#elif defined GNULIB_POSIXCHECK
+# undef wcscasecmp
+# if HAVE_RAW_DECL_WCSCASECMP
+_GL_WARN_ON_USE (wcscasecmp, "wcscasecmp is unportable - "
+                 "use gnulib module wcscasecmp for portability");
+# endif
+#endif
+
+
+/* Compare no more than N chars of S1 and S2, ignoring case.  */
+#if 0
+/* On Solaris 11.3, the header files declare the function in the std::
+   namespace, not in the global namespace.  So, force a declaration in
+   the global namespace.  */
+# if !1 || (defined __sun && defined __cplusplus)
+_GL_FUNCDECL_SYS (wcsncasecmp, int,
+                  (const wchar_t *s1, const wchar_t *s2, size_t n)
+                  _GL_ATTRIBUTE_PURE);
+# endif
+_GL_CXXALIAS_SYS (wcsncasecmp, int,
+                  (const wchar_t *s1, const wchar_t *s2, size_t n));
+_GL_CXXALIASWARN (wcsncasecmp);
+#elif defined GNULIB_POSIXCHECK
+# undef wcsncasecmp
+# if HAVE_RAW_DECL_WCSNCASECMP
+_GL_WARN_ON_USE (wcsncasecmp, "wcsncasecmp is unportable - "
+                 "use gnulib module wcsncasecmp for portability");
+# endif
+#endif
+
+
+/* Compare S1 and S2, both interpreted as appropriate to the LC_COLLATE
+   category of the current locale.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcscoll, int, (const wchar_t *s1, const wchar_t *s2));
+# endif
+_GL_CXXALIAS_SYS (wcscoll, int, (const wchar_t *s1, const wchar_t *s2));
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcscoll);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcscoll
+# if HAVE_RAW_DECL_WCSCOLL
+_GL_WARN_ON_USE (wcscoll, "wcscoll is unportable - "
+                 "use gnulib module wcscoll for portability");
+# endif
+#endif
+
+
+/* Transform S2 into array pointed to by S1 such that if wcscmp is applied
+   to two transformed strings the result is the as applying 'wcscoll' to the
+   original strings.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcsxfrm, size_t,
+                  (wchar_t *restrict s1, const wchar_t *restrict s2, size_t n));
+# endif
+_GL_CXXALIAS_SYS (wcsxfrm, size_t,
+                  (wchar_t *restrict s1, const wchar_t *restrict s2, size_t n));
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcsxfrm);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcsxfrm
+# if HAVE_RAW_DECL_WCSXFRM
+_GL_WARN_ON_USE (wcsxfrm, "wcsxfrm is unportable - "
+                 "use gnulib module wcsxfrm for portability");
+# endif
+#endif
+
+
+/* Duplicate S, returning an identical malloc'd string.  */
+#if 0
+# if defined _WIN32 && !defined __CYGWIN__
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcsdup
+#   define wcsdup _wcsdup
+#  endif
+_GL_CXXALIAS_MDA (wcsdup, wchar_t *, (const wchar_t *s));
+# else
+/* On Solaris 11.3, the header files declare the function in the std::
+   namespace, not in the global namespace.  So, force a declaration in
+   the global namespace.  */
+#  if !1 || (defined __sun && defined __cplusplus) || __GNUC__ >= 11
+_GL_FUNCDECL_SYS (wcsdup, wchar_t *,
+                  (const wchar_t *s)
+                  _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC_FREE);
+#  endif
+_GL_CXXALIAS_SYS (wcsdup, wchar_t *, (const wchar_t *s));
+# endif
+_GL_CXXALIASWARN (wcsdup);
+#else
+# if __GNUC__ >= 11 && !defined wcsdup
+/* For -Wmismatched-dealloc: Associate wcsdup with free or rpl_free.  */
+_GL_FUNCDECL_SYS (wcsdup, wchar_t *,
+                  (const wchar_t *s)
+                  _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC_FREE);
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef wcsdup
+#  if HAVE_RAW_DECL_WCSDUP
+_GL_WARN_ON_USE (wcsdup, "wcsdup is unportable - "
+                 "use gnulib module wcsdup for portability");
+#  endif
+# elif 1
+/* On native Windows, map 'wcsdup' to '_wcsdup', so that -loldnames is not
+   required.  In C++ with GNULIB_NAMESPACE, avoid differences between
+   platforms by defining GNULIB_NAMESPACE::wcsdup always.  */
+#  if defined _WIN32 && !defined __CYGWIN__
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef wcsdup
+#    define wcsdup _wcsdup
+#   endif
+_GL_CXXALIAS_MDA (wcsdup, wchar_t *, (const wchar_t *s));
+#  else
+_GL_FUNCDECL_SYS (wcsdup, wchar_t *,
+                  (const wchar_t *s)
+                  _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC_FREE);
+#   if 1
+_GL_CXXALIAS_SYS (wcsdup, wchar_t *, (const wchar_t *s));
+#   endif
+#  endif
+#  if (defined _WIN32 && !defined __CYGWIN__) || 1
+_GL_CXXALIASWARN (wcsdup);
+#  endif
+# endif
+#endif
+
+
+/* Find the first occurrence of WC in WCS.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcschr, wchar_t *, (const wchar_t *wcs, wchar_t wc)
+                                     _GL_ATTRIBUTE_PURE);
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" {
+         const wchar_t * std::wcschr (const wchar_t *, wchar_t);
+         wchar_t * std::wcschr (wchar_t *, wchar_t);
+       }  */
+_GL_CXXALIAS_SYS_CAST2 (wcschr,
+                        wchar_t *, (const wchar_t *, wchar_t),
+                        const wchar_t *, (const wchar_t *, wchar_t));
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (wcschr, wchar_t *, (wchar_t *wcs, wchar_t wc));
+_GL_CXXALIASWARN1 (wcschr, const wchar_t *, (const wchar_t *wcs, wchar_t wc));
+# elif __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcschr);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcschr
+# if HAVE_RAW_DECL_WCSCHR
+_GL_WARN_ON_USE (wcschr, "wcschr is unportable - "
+                 "use gnulib module wcschr for portability");
+# endif
+#endif
+
+
+/* Find the last occurrence of WC in WCS.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcsrchr, wchar_t *, (const wchar_t *wcs, wchar_t wc)
+                                      _GL_ATTRIBUTE_PURE);
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" {
+         const wchar_t * std::wcsrchr (const wchar_t *, wchar_t);
+         wchar_t * std::wcsrchr (wchar_t *, wchar_t);
+       }  */
+_GL_CXXALIAS_SYS_CAST2 (wcsrchr,
+                        wchar_t *, (const wchar_t *, wchar_t),
+                        const wchar_t *, (const wchar_t *, wchar_t));
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (wcsrchr, wchar_t *, (wchar_t *wcs, wchar_t wc));
+_GL_CXXALIASWARN1 (wcsrchr, const wchar_t *, (const wchar_t *wcs, wchar_t wc));
+# elif __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcsrchr);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcsrchr
+# if HAVE_RAW_DECL_WCSRCHR
+_GL_WARN_ON_USE (wcsrchr, "wcsrchr is unportable - "
+                 "use gnulib module wcsrchr for portability");
+# endif
+#endif
+
+
+/* Return the length of the initial segmet of WCS which consists entirely
+   of wide characters not in REJECT.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcscspn, size_t, (const wchar_t *wcs, const wchar_t *reject)
+                                   _GL_ATTRIBUTE_PURE);
+# endif
+_GL_CXXALIAS_SYS (wcscspn, size_t, (const wchar_t *wcs, const wchar_t *reject));
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcscspn);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcscspn
+# if HAVE_RAW_DECL_WCSCSPN
+_GL_WARN_ON_USE (wcscspn, "wcscspn is unportable - "
+                 "use gnulib module wcscspn for portability");
+# endif
+#endif
+
+
+/* Return the length of the initial segmet of WCS which consists entirely
+   of wide characters in ACCEPT.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcsspn, size_t, (const wchar_t *wcs, const wchar_t *accept)
+                                  _GL_ATTRIBUTE_PURE);
+# endif
+_GL_CXXALIAS_SYS (wcsspn, size_t, (const wchar_t *wcs, const wchar_t *accept));
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcsspn);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcsspn
+# if HAVE_RAW_DECL_WCSSPN
+_GL_WARN_ON_USE (wcsspn, "wcsspn is unportable - "
+                 "use gnulib module wcsspn for portability");
+# endif
+#endif
+
+
+/* Find the first occurrence in WCS of any character in ACCEPT.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcspbrk, wchar_t *,
+                  (const wchar_t *wcs, const wchar_t *accept)
+                  _GL_ATTRIBUTE_PURE);
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" {
+         const wchar_t * std::wcspbrk (const wchar_t *, const wchar_t *);
+         wchar_t * std::wcspbrk (wchar_t *, const wchar_t *);
+       }  */
+_GL_CXXALIAS_SYS_CAST2 (wcspbrk,
+                        wchar_t *, (const wchar_t *, const wchar_t *),
+                        const wchar_t *, (const wchar_t *, const wchar_t *));
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (wcspbrk, wchar_t *,
+                   (wchar_t *wcs, const wchar_t *accept));
+_GL_CXXALIASWARN1 (wcspbrk, const wchar_t *,
+                   (const wchar_t *wcs, const wchar_t *accept));
+# elif __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcspbrk);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcspbrk
+# if HAVE_RAW_DECL_WCSPBRK
+_GL_WARN_ON_USE (wcspbrk, "wcspbrk is unportable - "
+                 "use gnulib module wcspbrk for portability");
+# endif
+#endif
+
+
+/* Find the first occurrence of NEEDLE in HAYSTACK.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcsstr, wchar_t *,
+                  (const wchar_t *restrict haystack,
+                   const wchar_t *restrict needle)
+                  _GL_ATTRIBUTE_PURE);
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" {
+         const wchar_t * std::wcsstr (const wchar_t *, const wchar_t *);
+         wchar_t * std::wcsstr (wchar_t *, const wchar_t *);
+       }  */
+_GL_CXXALIAS_SYS_CAST2 (wcsstr,
+                        wchar_t *,
+                        (const wchar_t *restrict, const wchar_t *restrict),
+                        const wchar_t *,
+                        (const wchar_t *restrict, const wchar_t *restrict));
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (wcsstr, wchar_t *,
+                   (wchar_t *restrict haystack,
+                    const wchar_t *restrict needle));
+_GL_CXXALIASWARN1 (wcsstr, const wchar_t *,
+                   (const wchar_t *restrict haystack,
+                    const wchar_t *restrict needle));
+# elif __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcsstr);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcsstr
+# if HAVE_RAW_DECL_WCSSTR
+_GL_WARN_ON_USE (wcsstr, "wcsstr is unportable - "
+                 "use gnulib module wcsstr for portability");
+# endif
+#endif
+
+
+/* Divide WCS into tokens separated by characters in DELIM.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcstok
+#   define wcstok rpl_wcstok
+#  endif
+_GL_FUNCDECL_RPL (wcstok, wchar_t *,
+                  (wchar_t *restrict wcs, const wchar_t *restrict delim,
+                   wchar_t **restrict ptr));
+_GL_CXXALIAS_RPL (wcstok, wchar_t *,
+                  (wchar_t *restrict wcs, const wchar_t *restrict delim,
+                   wchar_t **restrict ptr));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (wcstok, wchar_t *,
+                  (wchar_t *restrict wcs, const wchar_t *restrict delim,
+                   wchar_t **restrict ptr));
+#  endif
+_GL_CXXALIAS_SYS (wcstok, wchar_t *,
+                  (wchar_t *restrict wcs, const wchar_t *restrict delim,
+                   wchar_t **restrict ptr));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcstok);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcstok
+# if HAVE_RAW_DECL_WCSTOK
+_GL_WARN_ON_USE (wcstok, "wcstok is unportable - "
+                 "use gnulib module wcstok for portability");
+# endif
+#endif
+
+
+/* Determine number of column positions required for first N wide
+   characters (or fewer if S ends before this) in S.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcswidth
+#   define wcswidth rpl_wcswidth
+#  endif
+_GL_FUNCDECL_RPL (wcswidth, int, (const wchar_t *s, size_t n)
+                                 _GL_ATTRIBUTE_PURE);
+_GL_CXXALIAS_RPL (wcswidth, int, (const wchar_t *s, size_t n));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (wcswidth, int, (const wchar_t *s, size_t n)
+                                 _GL_ATTRIBUTE_PURE);
+#  endif
+_GL_CXXALIAS_SYS (wcswidth, int, (const wchar_t *s, size_t n));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcswidth);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcswidth
+# if HAVE_RAW_DECL_WCSWIDTH
+_GL_WARN_ON_USE (wcswidth, "wcswidth is unportable - "
+                 "use gnulib module wcswidth for portability");
+# endif
+#endif
+
+
+/* Convert *TP to a date and time wide string.  See
+   <https://pubs.opengroup.org/onlinepubs/9699919799/functions/wcsftime.html>.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcsftime
+#   define wcsftime rpl_wcsftime
+#  endif
+_GL_FUNCDECL_RPL (wcsftime, size_t,
+                  (wchar_t *restrict __buf, size_t __bufsize,
+                   const wchar_t *restrict __fmt,
+                   const struct tm *restrict __tp)
+                  _GL_ARG_NONNULL ((1, 3, 4)));
+_GL_CXXALIAS_RPL (wcsftime, size_t,
+                  (wchar_t *restrict __buf, size_t __bufsize,
+                   const wchar_t *restrict __fmt,
+                   const struct tm *restrict __tp));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (wcsftime, size_t,
+                  (wchar_t *restrict __buf, size_t __bufsize,
+                   const wchar_t *restrict __fmt,
+                   const struct tm *restrict __tp)
+                  _GL_ARG_NONNULL ((1, 3, 4)));
+#  endif
+_GL_CXXALIAS_SYS (wcsftime, size_t,
+                  (wchar_t *restrict __buf, size_t __bufsize,
+                   const wchar_t *restrict __fmt,
+                   const struct tm *restrict __tp));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wcsftime);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcsftime
+# if HAVE_RAW_DECL_WCSFTIME
+_GL_WARN_ON_USE (wcsftime, "wcsftime is unportable - "
+                 "use gnulib module wcsftime for portability");
+# endif
+#endif
+
+
+#endif /* _GL_WCHAR_H */
+#endif /* _GL_WCHAR_H */
+#endif
diff -Naur ../orig/sed-4.9/lib/wctype.h ./lib/wctype.h
--- ../orig/sed-4.9/lib/wctype.h	1970-01-01 03:00:00.000000000 +0300
+++ ./lib/wctype.h	2022-12-01 17:13:19.169986400 +0300
@@ -0,0 +1,1213 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A substitute for ISO C99 <wctype.h>, for platforms that lack it.
+
+   Copyright (C) 2006-2022 Free Software Foundation, Inc.
+
+   This file is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   This file is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible and Paul Eggert.  */
+
+/*
+ * ISO C 99 <wctype.h> for platforms that lack it.
+ * <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/wctype.h.html>
+ *
+ * iswctype, towctrans, towlower, towupper, wctrans, wctype,
+ * wctrans_t, and wctype_t are not yet implemented.
+ */
+
+#if __GNUC__ >= 3
+
+#endif
+
+
+#if (defined __MINGW32__ && defined __CTYPE_H_SOURCED__)
+
+/* Special invocation convention:
+   - With MinGW 3.22, when <ctype.h> includes <wctype.h>, only some part of
+     <wctype.h> is being processed, which doesn't include the idempotency
+     guard.   */
+
+#include ""
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_WCTYPE_H
+
+#if 1
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+#endif
+
+/* Native Windows (mingw, MSVC) have declarations of towupper, towlower, and
+   isw* functions in <ctype.h>, <wchar.h> as well as in <wctype.h>.  Include
+   <ctype.h>, <wchar.h> in advance to avoid rpl_ prefix being added to the
+   declarations.  */
+#if defined _WIN32 && ! defined __CYGWIN__
+# include <ctype.h>
+# include <wchar.h>
+#endif
+
+/* Include the original <wctype.h> if it exists.
+   BeOS 5 has the functions but no <wctype.h>.  */
+/* The include_next requires a split double-inclusion guard.  */
+#if 1
+# include "C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\INCLUDE\wctype.h"
+#endif
+
+#ifndef _GL_WCTYPE_H
+#define _GL_WCTYPE_H
+
+#ifndef _GL_INLINE_HEADER_BEGIN
+ #error "Please include config.h first."
+#endif
+_GL_INLINE_HEADER_BEGIN
+#ifndef _GL_WCTYPE_INLINE
+# define _GL_WCTYPE_INLINE _GL_INLINE
+#endif
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA (func, rettype, parameters);
+   is to be used when func is a Microsoft deprecated alias, on native Windows.
+   It declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to _func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_MDA (open, int, (const char *filename, int flags, ...));
+ */
+#define _GL_CXXALIAS_MDA(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_MDA_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_MDA (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#define _GL_CXXALIAS_MDA_CAST(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_CAST_1 (func, _##func, rettype, parameters)
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !(defined __GNUC__ && !defined __clang__ && __OPTIMIZE__)
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2022 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__diagnose_if__ (1, message, "warning")))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype_gcc, rettype_clang, parameters_and_attributes, "message")
+   is like _GL_WARN_ON_USE (function, "message"), except that in C++ mode the
+   function is declared with the given prototype, consisting of return type,
+   parameters, and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if !defined __cplusplus
+#  define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+     _GL_WARN_ON_USE (function, msg)
+# else
+#  if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes \
+  __attribute__ ((__warning__ (msg)))
+#  elif __clang_major__ >= 4
+/* Another compiler attribute is available in clang.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_clang function parameters_and_attributes \
+  __attribute__ ((__diagnose_if__ (1, msg, "warning")))
+#  elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+extern rettype_gcc function parameters_and_attributes
+#  else /* Unsupported.  */
+#   define _GL_WARN_ON_USE_CXX(function,rettype_gcc,rettype_clang,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  endif
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+/* Solaris 2.6 <wctype.h> includes <widec.h> which includes <euc.h> which
+   #defines a number of identifiers in the application namespace.  Revert
+   these #defines.  */
+#ifdef __sun
+# undef multibyte
+# undef eucw1
+# undef eucw2
+# undef eucw3
+# undef scrw1
+# undef scrw2
+# undef scrw3
+#endif
+
+/* Define wint_t and WEOF.  (Also done in wchar.in.h.)  */
+#if !1 && !defined wint_t
+# define wint_t int
+# ifndef WEOF
+#  define WEOF -1
+# endif
+#else
+/* mingw and MSVC define wint_t as 'unsigned short' in <crtdefs.h> or
+   <stddef.h>.  This is too small: ISO C 99 section 7.24.1.(2) says that
+   wint_t must be "unchanged by default argument promotions".  Override it.  */
+# if 1
+#  if !GNULIB_defined_wint_t
+#   if 1
+#    include <crtdefs.h>
+#   else
+#    include <stddef.h>
+#   endif
+typedef unsigned int rpl_wint_t;
+#   undef wint_t
+#   define wint_t rpl_wint_t
+#   define GNULIB_defined_wint_t 1
+#  endif
+# endif
+# ifndef WEOF
+#  define WEOF ((wint_t) -1)
+# endif
+#endif
+
+
+#if !GNULIB_defined_wctype_functions
+
+/* FreeBSD 4.4 to 4.11 has <wctype.h> but lacks the functions.
+   Linux libc5 has <wctype.h> and the functions but they are broken.
+   mingw and MSVC have <wctype.h> and the functions but they take a wchar_t
+   as argument, not an rpl_wint_t.
+   Assume all 11 functions (all isw* except iswblank) are implemented the
+   same way, or not at all.  */
+# if ! 1 || 1
+
+#  if 1 /* implies 1 */
+
+_GL_WCTYPE_INLINE int
+rpl_iswalnum (wint_t wc)
+{
+  return ((wchar_t) wc == wc ? iswalnum ((wchar_t) wc) : 0);
+}
+
+_GL_WCTYPE_INLINE int
+rpl_iswalpha (wint_t wc)
+{
+  return ((wchar_t) wc == wc ? iswalpha ((wchar_t) wc) : 0);
+}
+
+_GL_WCTYPE_INLINE int
+rpl_iswblank (wint_t wc)
+{
+  return ((wchar_t) wc == wc ? iswblank ((wchar_t) wc) : 0);
+}
+
+_GL_WCTYPE_INLINE int
+rpl_iswcntrl (wint_t wc)
+{
+  return ((wchar_t) wc == wc ? iswcntrl ((wchar_t) wc) : 0);
+}
+
+_GL_WCTYPE_INLINE int
+rpl_iswdigit (wint_t wc)
+{
+  return ((wchar_t) wc == wc ? wc >= '0' && wc <= '9' : 0);
+}
+
+_GL_WCTYPE_INLINE int
+rpl_iswgraph (wint_t wc)
+{
+  return ((wchar_t) wc == wc ? iswgraph ((wchar_t) wc) : 0);
+}
+
+_GL_WCTYPE_INLINE int
+rpl_iswlower (wint_t wc)
+{
+  return ((wchar_t) wc == wc ? iswlower ((wchar_t) wc) : 0);
+}
+
+_GL_WCTYPE_INLINE int
+rpl_iswprint (wint_t wc)
+{
+  return ((wchar_t) wc == wc ? iswprint ((wchar_t) wc) : 0);
+}
+
+_GL_WCTYPE_INLINE int
+rpl_iswpunct (wint_t wc)
+{
+  return ((wchar_t) wc == wc ? iswpunct ((wchar_t) wc) : 0);
+}
+
+_GL_WCTYPE_INLINE int
+rpl_iswspace (wint_t wc)
+{
+  return ((wchar_t) wc == wc ? iswspace ((wchar_t) wc) : 0);
+}
+
+_GL_WCTYPE_INLINE int
+rpl_iswupper (wint_t wc)
+{
+  return ((wchar_t) wc == wc ? iswupper ((wchar_t) wc) : 0);
+}
+
+_GL_WCTYPE_INLINE int
+rpl_iswxdigit (wint_t wc)
+{
+  return ((wchar_t) wc == wc
+          ? (wc >= '0' && wc <= '9')
+            || ((wc & ~0x20) >= 'A' && (wc & ~0x20) <= 'F')
+          : 0);
+}
+
+_GL_WCTYPE_INLINE wint_t
+rpl_towlower (wint_t wc)
+{
+  return ((wchar_t) wc == wc ? (wchar_t) towlower ((wchar_t) wc) : wc);
+}
+
+_GL_WCTYPE_INLINE wint_t
+rpl_towupper (wint_t wc)
+{
+  return ((wchar_t) wc == wc ? (wchar_t) towupper ((wchar_t) wc) : wc);
+}
+
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef iswalnum
+#    undef iswalpha
+#    undef iswblank
+#    undef iswcntrl
+#    undef iswdigit
+#    undef iswgraph
+#    undef iswlower
+#    undef iswprint
+#    undef iswpunct
+#    undef iswspace
+#    undef iswupper
+#    undef iswxdigit
+#    undef towlower
+#    undef towupper
+#    define iswalnum rpl_iswalnum
+#    define iswalpha rpl_iswalpha
+#    define iswblank rpl_iswblank
+#    define iswcntrl rpl_iswcntrl
+#    define iswdigit rpl_iswdigit
+#    define iswgraph rpl_iswgraph
+#    define iswlower rpl_iswlower
+#    define iswprint rpl_iswprint
+#    define iswpunct rpl_iswpunct
+#    define iswspace rpl_iswspace
+#    define iswupper rpl_iswupper
+#    define iswxdigit rpl_iswxdigit
+#    define towlower rpl_towlower
+#    define towupper rpl_towupper
+#   endif
+
+#  else
+
+/* IRIX 5.3 has macros but no functions, its isw* macros refer to an
+   undefined variable _ctmp_ and to <ctype.h> macros like _P, and they
+   refer to system functions like _iswctype that are not in the
+   standard C library.  Rather than try to get ancient buggy
+   implementations like this to work, just disable them.  */
+#   undef iswalnum
+#   undef iswalpha
+#   undef iswblank
+#   undef iswcntrl
+#   undef iswdigit
+#   undef iswgraph
+#   undef iswlower
+#   undef iswprint
+#   undef iswpunct
+#   undef iswspace
+#   undef iswupper
+#   undef iswxdigit
+#   undef towlower
+#   undef towupper
+
+/* Linux libc5 has <wctype.h> and the functions but they are broken.  */
+#   if 1
+#    if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#     define iswalnum rpl_iswalnum
+#     define iswalpha rpl_iswalpha
+#     define iswblank rpl_iswblank
+#     define iswcntrl rpl_iswcntrl
+#     define iswdigit rpl_iswdigit
+#     define iswgraph rpl_iswgraph
+#     define iswlower rpl_iswlower
+#     define iswprint rpl_iswprint
+#     define iswpunct rpl_iswpunct
+#     define iswspace rpl_iswspace
+#     define iswupper rpl_iswupper
+#     define iswxdigit rpl_iswxdigit
+#    endif
+#   endif
+#   if 1
+#    if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#     define towlower rpl_towlower
+#     define towupper rpl_towupper
+#    endif
+#   endif
+
+_GL_WCTYPE_INLINE int
+#   if 1
+rpl_iswalnum
+#   else
+iswalnum
+#   endif
+         (wint_t wc)
+{
+  return ((wc >= '0' && wc <= '9')
+          || ((wc & ~0x20) >= 'A' && (wc & ~0x20) <= 'Z'));
+}
+
+_GL_WCTYPE_INLINE int
+#   if 1
+rpl_iswalpha
+#   else
+iswalpha
+#   endif
+         (wint_t wc)
+{
+  return (wc & ~0x20) >= 'A' && (wc & ~0x20) <= 'Z';
+}
+
+_GL_WCTYPE_INLINE int
+#   if 1
+rpl_iswblank
+#   else
+iswblank
+#   endif
+         (wint_t wc)
+{
+  return wc == ' ' || wc == '\t';
+}
+
+_GL_WCTYPE_INLINE int
+#   if 1
+rpl_iswcntrl
+#   else
+iswcntrl
+#   endif
+        (wint_t wc)
+{
+  return (wc & ~0x1f) == 0 || wc == 0x7f;
+}
+
+_GL_WCTYPE_INLINE int
+#   if 0
+rpl_iswdigit
+#   else
+iswdigit
+#   endif
+         (wint_t wc)
+{
+  return wc >= '0' && wc <= '9';
+}
+
+_GL_WCTYPE_INLINE int
+#   if 1
+rpl_iswgraph
+#   else
+iswgraph
+#   endif
+         (wint_t wc)
+{
+  return wc >= '!' && wc <= '~';
+}
+
+_GL_WCTYPE_INLINE int
+#   if 1
+rpl_iswlower
+#   else
+iswlower
+#   endif
+         (wint_t wc)
+{
+  return wc >= 'a' && wc <= 'z';
+}
+
+_GL_WCTYPE_INLINE int
+#   if 1
+rpl_iswprint
+#   else
+iswprint
+#   endif
+         (wint_t wc)
+{
+  return wc >= ' ' && wc <= '~';
+}
+
+_GL_WCTYPE_INLINE int
+#   if 1
+rpl_iswpunct
+#   else
+iswpunct
+#   endif
+         (wint_t wc)
+{
+  return (wc >= '!' && wc <= '~'
+          && !((wc >= '0' && wc <= '9')
+               || ((wc & ~0x20) >= 'A' && (wc & ~0x20) <= 'Z')));
+}
+
+_GL_WCTYPE_INLINE int
+#   if 1
+rpl_iswspace
+#   else
+iswspace
+#   endif
+         (wint_t wc)
+{
+  return (wc == ' ' || wc == '\t'
+          || wc == '\n' || wc == '\v' || wc == '\f' || wc == '\r');
+}
+
+_GL_WCTYPE_INLINE int
+#   if 1
+rpl_iswupper
+#   else
+iswupper
+#   endif
+         (wint_t wc)
+{
+  return wc >= 'A' && wc <= 'Z';
+}
+
+_GL_WCTYPE_INLINE int
+#   if 0
+rpl_iswxdigit
+#   else
+iswxdigit
+#   endif
+          (wint_t wc)
+{
+  return ((wc >= '0' && wc <= '9')
+          || ((wc & ~0x20) >= 'A' && (wc & ~0x20) <= 'F'));
+}
+
+_GL_WCTYPE_INLINE wint_t
+#   if 1
+rpl_towlower
+#   else
+towlower
+#   endif
+         (wint_t wc)
+{
+  return (wc >= 'A' && wc <= 'Z' ? wc - 'A' + 'a' : wc);
+}
+
+_GL_WCTYPE_INLINE wint_t
+#   if 1
+rpl_towupper
+#   else
+towupper
+#   endif
+         (wint_t wc)
+{
+  return (wc >= 'a' && wc <= 'z' ? wc - 'a' + 'A' : wc);
+}
+
+#  endif
+
+# else
+/* Only some of the functions are missing or broken.  */
+
+#  if 0 && (! 1 || 0)
+/* Only the iswblank function is missing.  */
+#   if 0
+#    if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#     define iswblank rpl_iswblank
+#    endif
+_GL_FUNCDECL_RPL (iswblank, int, (wint_t wc));
+#   else
+_GL_FUNCDECL_SYS (iswblank, int, (wint_t wc));
+#   endif
+#  endif
+
+#  if 0
+#   if 0
+#    if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#     undef iswdigit
+#     define iswdigit rpl_iswdigit
+#    endif
+_GL_FUNCDECL_RPL (iswdigit, int, (wint_t wc));
+#   endif
+#  endif
+
+#  if 0
+#   if 0
+#    if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#     undef iswxdigit
+#     define iswxdigit rpl_iswxdigit
+#    endif
+_GL_FUNCDECL_RPL (iswxdigit, int, (wint_t wc));
+#   endif
+#  endif
+
+# endif
+
+# if defined __MINGW32__ && !1
+
+/* On native Windows, wchar_t is uint16_t, and wint_t is uint32_t.
+   The functions towlower and towupper are implemented in the MSVCRT library
+   to take a wchar_t argument and return a wchar_t result.  mingw declares
+   these functions to take a wint_t argument and return a wint_t result.
+   This means that:
+   1. When the user passes an argument outside the range 0x0000..0xFFFF, the
+      function will look only at the lower 16 bits.  This is allowed according
+      to POSIX.
+   2. The return value is returned in the lower 16 bits of the result register.
+      The upper 16 bits are random: whatever happened to be in that part of the
+      result register.  We need to fix this by adding a zero-extend from
+      wchar_t to wint_t after the call.  */
+
+_GL_WCTYPE_INLINE wint_t
+rpl_towlower (wint_t wc)
+{
+  return (wint_t) (wchar_t) towlower (wc);
+}
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define towlower rpl_towlower
+#  endif
+
+_GL_WCTYPE_INLINE wint_t
+rpl_towupper (wint_t wc)
+{
+  return (wint_t) (wchar_t) towupper (wc);
+}
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define towupper rpl_towupper
+#  endif
+
+# endif /* __MINGW32__ && !1 */
+
+# define GNULIB_defined_wctype_functions 1
+#endif
+
+#if 1
+_GL_CXXALIAS_RPL (iswalnum, int, (wint_t wc));
+#else
+_GL_CXXALIAS_SYS (iswalnum, int, (wint_t wc));
+#endif
+#if 1
+_GL_CXXALIAS_RPL (iswalpha, int, (wint_t wc));
+#else
+_GL_CXXALIAS_SYS (iswalpha, int, (wint_t wc));
+#endif
+#if 1
+_GL_CXXALIAS_RPL (iswcntrl, int, (wint_t wc));
+#else
+_GL_CXXALIAS_SYS (iswcntrl, int, (wint_t wc));
+#endif
+#if 0
+# if 0
+_GL_CXXALIAS_RPL (iswdigit, int, (wint_t wc));
+# else
+_GL_CXXALIAS_SYS (iswdigit, int, (wint_t wc));
+# endif
+#endif
+#if 1
+_GL_CXXALIAS_RPL (iswgraph, int, (wint_t wc));
+#else
+_GL_CXXALIAS_SYS (iswgraph, int, (wint_t wc));
+#endif
+#if 1
+_GL_CXXALIAS_RPL (iswlower, int, (wint_t wc));
+#else
+_GL_CXXALIAS_SYS (iswlower, int, (wint_t wc));
+#endif
+#if 1
+_GL_CXXALIAS_RPL (iswprint, int, (wint_t wc));
+#else
+_GL_CXXALIAS_SYS (iswprint, int, (wint_t wc));
+#endif
+#if 1
+_GL_CXXALIAS_RPL (iswpunct, int, (wint_t wc));
+#else
+_GL_CXXALIAS_SYS (iswpunct, int, (wint_t wc));
+#endif
+#if 1
+_GL_CXXALIAS_RPL (iswspace, int, (wint_t wc));
+#else
+_GL_CXXALIAS_SYS (iswspace, int, (wint_t wc));
+#endif
+#if 1
+_GL_CXXALIAS_RPL (iswupper, int, (wint_t wc));
+#else
+_GL_CXXALIAS_SYS (iswupper, int, (wint_t wc));
+#endif
+#if 0
+# if 0
+_GL_CXXALIAS_RPL (iswxdigit, int, (wint_t wc));
+# else
+_GL_CXXALIAS_SYS (iswxdigit, int, (wint_t wc));
+# endif
+#endif
+#if __GLIBC__ >= 2
+_GL_CXXALIASWARN (iswalnum);
+_GL_CXXALIASWARN (iswalpha);
+_GL_CXXALIASWARN (iswcntrl);
+_GL_CXXALIASWARN (iswdigit);
+_GL_CXXALIASWARN (iswgraph);
+_GL_CXXALIASWARN (iswlower);
+_GL_CXXALIASWARN (iswprint);
+_GL_CXXALIASWARN (iswpunct);
+_GL_CXXALIASWARN (iswspace);
+_GL_CXXALIASWARN (iswupper);
+_GL_CXXALIASWARN (iswxdigit);
+#endif
+
+#if 0
+# if 1 || 0
+_GL_CXXALIAS_RPL (iswblank, int, (wint_t wc));
+# else
+_GL_CXXALIAS_SYS (iswblank, int, (wint_t wc));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (iswblank);
+# endif
+#endif
+
+#if !1
+# if !GNULIB_defined_wctype_t
+typedef void * wctype_t;
+#  define GNULIB_defined_wctype_t 1
+# endif
+#endif
+
+/* Get a descriptor for a wide character property.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wctype, wctype_t, (const char *name));
+# endif
+_GL_CXXALIAS_SYS (wctype, wctype_t, (const char *name));
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wctype);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wctype
+# if HAVE_RAW_DECL_WCTYPE
+_GL_WARN_ON_USE (wctype, "wctype is unportable - "
+                 "use gnulib module wctype for portability");
+# endif
+#endif
+
+/* Test whether a wide character has a given property.
+   The argument WC must be either a wchar_t value or WEOF.
+   The argument DESC must have been returned by the wctype() function.  */
+#if 0
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef iswctype
+#   define iswctype rpl_iswctype
+#  endif
+_GL_FUNCDECL_RPL (iswctype, int, (wint_t wc, wctype_t desc));
+_GL_CXXALIAS_RPL (iswctype, int, (wint_t wc, wctype_t desc));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (iswctype, int, (wint_t wc, wctype_t desc));
+#  endif
+_GL_CXXALIAS_SYS (iswctype, int, (wint_t wc, wctype_t desc));
+# endif
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (iswctype);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef iswctype
+# if HAVE_RAW_DECL_ISWCTYPE
+_GL_WARN_ON_USE (iswctype, "iswctype is unportable - "
+                 "use gnulib module iswctype for portability");
+# endif
+#endif
+
+#if 1 || defined __MINGW32__
+_GL_CXXALIAS_RPL (towlower, wint_t, (wint_t wc));
+_GL_CXXALIAS_RPL (towupper, wint_t, (wint_t wc));
+#else
+_GL_CXXALIAS_SYS (towlower, wint_t, (wint_t wc));
+_GL_CXXALIAS_SYS (towupper, wint_t, (wint_t wc));
+#endif
+#if __GLIBC__ >= 2
+_GL_CXXALIASWARN (towlower);
+_GL_CXXALIASWARN (towupper);
+#endif
+
+#if !1
+# if !GNULIB_defined_wctrans_t
+typedef void * wctrans_t;
+#  define GNULIB_defined_wctrans_t 1
+# endif
+#endif
+
+/* Get a descriptor for a wide character case conversion.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wctrans, wctrans_t, (const char *name));
+# endif
+_GL_CXXALIAS_SYS (wctrans, wctrans_t, (const char *name));
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (wctrans);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wctrans
+# if HAVE_RAW_DECL_WCTRANS
+_GL_WARN_ON_USE (wctrans, "wctrans is unportable - "
+                 "use gnulib module wctrans for portability");
+# endif
+#endif
+
+/* Perform a given case conversion on a wide character.
+   The argument WC must be either a wchar_t value or WEOF.
+   The argument DESC must have been returned by the wctrans() function.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (towctrans, wint_t, (wint_t wc, wctrans_t desc));
+# endif
+_GL_CXXALIAS_SYS (towctrans, wint_t, (wint_t wc, wctrans_t desc));
+# if __GLIBC__ >= 2
+_GL_CXXALIASWARN (towctrans);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef towctrans
+# if HAVE_RAW_DECL_TOWCTRANS
+_GL_WARN_ON_USE (towctrans, "towctrans is unportable - "
+                 "use gnulib module towctrans for portability");
+# endif
+#endif
+
+_GL_INLINE_HEADER_END
+
+#endif /* _GL_WCTYPE_H */
+#endif /* _GL_WCTYPE_H */
+#endif
diff -Naur ../orig/sed-4.9/lib/xmalloc.c ./lib/xmalloc.c
--- ../orig/sed-4.9/lib/xmalloc.c	2022-10-16 20:37:16.000000000 +0300
+++ ./lib/xmalloc.c	2022-12-01 17:13:49.514208600 +0300
@@ -242,6 +242,7 @@
   if (0 <= n_max && n_max < n)
     n = n_max;
 
+  {
   /* NBYTES is of a type suitable for holding the count of bytes in an object.
      This is typically idx_t, but it should be size_t on (theoretical?)
      platforms where SIZE_MAX < IDX_MAX so xpalloc does not pass
@@ -271,6 +272,7 @@
   pa = xrealloc (pa, nbytes);
   *pn = n;
   return pa;
+  }
 }
 
 /* Allocate S bytes of zeroed memory dynamically, with error checking.
diff -Naur ../orig/sed-4.9/make.bat ./make.bat
--- ../orig/sed-4.9/make.bat	1970-01-01 03:00:00.000000000 +0300
+++ ./make.bat	2022-12-01 17:33:46.399454600 +0300
@@ -0,0 +1,102 @@
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed /DLOCALEDIR="" /c /nologo /Fosed\sed-compile.obj sed\compile.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed /DLOCALEDIR="" /c /nologo /Fosed\sed-debug.obj sed\debug.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed /DLOCALEDIR="" /c /nologo /Fosed\sed-execute.obj sed\execute.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed /DLOCALEDIR="" /c /nologo /Fosed\sed-mbcs.obj sed\mbcs.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed /DLOCALEDIR="" /c /nologo /Fosed\sed-regexp.obj sed\regexp.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed /DLOCALEDIR="" /c /nologo /Fosed\sed-sed.obj sed\sed.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed /DLOCALEDIR="" /c /nologo /Fosed\sed-utils.obj sed\utils.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-copy-acl.obj lib\copy-acl.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-set-acl.obj lib\set-acl.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-acl-errno-valid.obj lib\acl-errno-valid.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-acl-internal.obj lib\acl-internal.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-get-permissions.obj lib\get-permissions.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-set-permissions.obj lib\set-permissions.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-basename-lgpl.obj lib\basename-lgpl.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-binary-io.obj lib\binary-io.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-c-ctype.obj lib\c-ctype.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-c-strcasecmp.obj lib\c-strcasecmp.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-c-strncasecmp.obj lib\c-strncasecmp.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-canonicalize-lgpl.obj lib\canonicalize-lgpl.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-cloexec.obj lib\cloexec.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-close.obj lib\close.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-close-stream.obj lib\close-stream.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-closeout.obj lib\closeout.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-dfa.obj lib\dfa.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-localeinfo.obj lib\localeinfo.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-dirname-lgpl.obj lib\dirname-lgpl.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-stripslash.obj lib\stripslash.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-dup2.obj lib\dup2.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-error.obj lib\error.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-exitfail.obj lib\exitfail.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-fcntl.obj lib\fcntl.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-fd-hook.obj lib\fd-hook.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-fpending.obj lib\fpending.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-free.obj lib\free.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-fwriting.obj lib\fwriting.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-getdelim.obj lib\getdelim.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-getdtablesize.obj lib\getdtablesize.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-getprogname.obj lib\getprogname.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-getrandom.obj lib\getrandom.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\malloc\libsed_a-dynarray_at_failure.obj lib\malloc\dynarray_at_failure.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\malloc\libsed_a-dynarray_emplace_enlarge.obj lib\malloc\dynarray_emplace_enlarge.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\malloc\libsed_a-dynarray_finalize.obj lib\malloc\dynarray_finalize.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\malloc\libsed_a-dynarray_resize.obj lib\malloc\dynarray_resize.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\malloc\libsed_a-dynarray_resize_clear.obj lib\malloc\dynarray_resize_clear.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\malloc\libsed_a-scratch_buffer_grow.obj lib\malloc\scratch_buffer_grow.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\malloc\libsed_a-scratch_buffer_grow_preserve.obj lib\malloc\scratch_buffer_grow_preserve.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\malloc\libsed_a-scratch_buffer_set_array_size.obj lib\malloc\scratch_buffer_set_array_size.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-hard-locale.obj lib\hard-locale.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-ialloc.obj lib\ialloc.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-localcharset.obj lib\localcharset.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\glthread\libsed_a-lock.obj lib\glthread\lock.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-malloca.obj lib\malloca.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-mbrlen.obj lib\mbrlen.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-mbrtowc.obj lib\mbrtowc.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-mbsinit.obj lib\mbsinit.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-mempcpy.obj lib\mempcpy.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-memrchr.obj lib\memrchr.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-mkdir.obj lib\mkdir.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-mkostemp.obj lib\mkostemp.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-msvc-inval.obj lib\msvc-inval.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-msvc-nothrow.obj lib\msvc-nothrow.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-nl_langinfo.obj lib\nl_langinfo.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-obstack.obj lib\obstack.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-open.obj lib\open.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-progname.obj lib\progname.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-qcopy-acl.obj lib\qcopy-acl.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-qset-acl.obj lib\qset-acl.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-quotearg.obj lib\quotearg.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-rawmemchr.obj lib\rawmemchr.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-readlink.obj lib\readlink.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-reallocarray.obj lib\reallocarray.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-regex.obj lib\regex.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-rename.obj lib\rename.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-rmdir.obj lib\rmdir.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-se-context.obj lib\se-context.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-se-label.obj lib\se-label.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-se-selinux.obj lib\se-selinux.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-setlocale_null.obj lib\setlocale_null.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-stat-time.obj lib\stat-time.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-strerror.obj lib\strerror.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-strerror-override.obj lib\strerror-override.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-strverscmp.obj lib\strverscmp.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-tempname.obj lib\tempname.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\glthread\libsed_a-threadlib.obj lib\glthread\threadlib.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-unistd.obj lib\unistd.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-version-etc.obj lib\version-etc.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-version-etc-fsf.obj lib\version-etc-fsf.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-wctob.obj lib\wctob.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-wctype-h.obj lib\wctype-h.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-xmalloc.obj lib\xmalloc.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed  /c /nologo /Folib\libsed_a-xalloc-die.obj lib\xalloc-die.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed /c /nologo /Folib\calloc.obj lib\calloc.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed /c /nologo /DGNULIB_WCHAR_SINGLE_LOCALE=1 /Folib\lc-charset-dispatch.obj lib\lc-charset-dispatch.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed /c /nologo /Folib\malloc.obj lib\malloc.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed /c /nologo /Folib\mbtowc-lock.obj lib\mbtowc-lock.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed /c /nologo /Folib\realloc.obj lib\realloc.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed /c /nologo /Folib\getopt.obj lib\getopt.c || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed /c /nologo /Folib\getopt1.obj lib\getopt1.c || exit /b 1
+lib /LTCG /nologo /OUT:lib\libsed.a lib\libsed_a-copy-acl.obj lib\libsed_a-set-acl.obj lib\libsed_a-acl-errno-valid.obj lib\libsed_a-acl-internal.obj lib\libsed_a-get-permissions.obj lib\libsed_a-set-permissions.obj lib\libsed_a-basename-lgpl.obj lib\libsed_a-binary-io.obj  lib\libsed_a-c-ctype.obj lib\libsed_a-c-strcasecmp.obj lib\libsed_a-c-strncasecmp.obj lib\libsed_a-canonicalize-lgpl.obj lib\libsed_a-cloexec.obj lib\libsed_a-close.obj lib\libsed_a-close-stream.obj lib\libsed_a-closeout.obj lib\libsed_a-dfa.obj lib\libsed_a-localeinfo.obj lib\libsed_a-dirname-lgpl.obj lib\libsed_a-stripslash.obj lib\libsed_a-dup2.obj lib\libsed_a-error.obj lib\libsed_a-exitfail.obj lib\libsed_a-fcntl.obj lib\libsed_a-fd-hook.obj lib\libsed_a-fpending.obj lib\libsed_a-free.obj  lib\libsed_a-fwriting.obj lib\libsed_a-getdelim.obj lib\libsed_a-getdtablesize.obj lib\libsed_a-getprogname.obj lib\libsed_a-getrandom.obj lib\malloc\libsed_a-dynarray_at_failure.obj lib\malloc\libsed_a-dynarray_emplace_enlarge.obj lib\malloc\libsed_a-dynarray_finalize.obj lib\malloc\libsed_a-dynarray_resize.obj lib\malloc\libsed_a-dynarray_resize_clear.obj lib\malloc\libsed_a-scratch_buffer_grow.obj lib\malloc\libsed_a-scratch_buffer_grow_preserve.obj lib\malloc\libsed_a-scratch_buffer_set_array_size.obj lib\libsed_a-hard-locale.obj lib\libsed_a-ialloc.obj lib\libsed_a-localcharset.obj  lib\glthread\libsed_a-lock.obj  lib\libsed_a-malloca.obj lib\libsed_a-mbrlen.obj lib\libsed_a-mbrtowc.obj lib\libsed_a-mbsinit.obj   lib\libsed_a-mempcpy.obj lib\libsed_a-memrchr.obj lib\libsed_a-mkdir.obj lib\libsed_a-mkostemp.obj lib\libsed_a-msvc-inval.obj lib\libsed_a-msvc-nothrow.obj lib\libsed_a-nl_langinfo.obj  lib\libsed_a-obstack.obj lib\libsed_a-open.obj lib\libsed_a-progname.obj lib\libsed_a-qcopy-acl.obj lib\libsed_a-qset-acl.obj lib\libsed_a-quotearg.obj lib\libsed_a-rawmemchr.obj lib\libsed_a-readlink.obj lib\libsed_a-reallocarray.obj lib\libsed_a-regex.obj lib\libsed_a-rename.obj lib\libsed_a-rmdir.obj  lib\libsed_a-se-context.obj lib\libsed_a-se-label.obj lib\libsed_a-se-selinux.obj lib\libsed_a-setlocale_null.obj   lib\libsed_a-stat-time.obj   lib\libsed_a-strerror.obj lib\libsed_a-strerror-override.obj lib\libsed_a-strverscmp.obj lib\libsed_a-tempname.obj lib\glthread\libsed_a-threadlib.obj lib\libsed_a-unistd.obj lib\libsed_a-version-etc.obj lib\libsed_a-version-etc-fsf.obj  lib\libsed_a-wctob.obj  lib\libsed_a-wctype-h.obj     lib\libsed_a-xmalloc.obj lib\libsed_a-xalloc-die.obj lib\calloc.obj lib\lc-charset-dispatch.obj lib\malloc.obj lib\mbtowc-lock.obj lib\realloc.obj lib\getopt.obj lib\getopt1.obj  || exit /b 1
+cl /D_WIN32_WINNT=0x501 /D__bool_true_false_are_defined /Dbool=int /Dtrue=1 /Dfalse=0 /Ox /GF /Gy /GS- /GL /EHsc /DHAVE_CONFIG_H /I. /I.\lib /I.\sed /c /nologo /Fosed\version.obj sed\version.c || exit /b 1
+lib /LTCG /nologo /OUT:sed\libver.a sed\version.obj  || exit /b 1
+link /nologo /LTCG /SUBSYSTEM:CONSOLE,5.01 /OUT:sed\sed.exe /DEFAULTLIB:Advapi32.lib /DEFAULTLIB:LIBCPMT.lib wsetargv.obj sed\sed-compile.obj sed\sed-debug.obj sed\sed-execute.obj sed\sed-mbcs.obj sed\sed-regexp.obj sed\sed-sed.obj sed\sed-utils.obj sed\libver.a lib\libsed.a     || exit /b 1
diff -Naur ../orig/sed-4.9/sed/debug.c ./sed/debug.c
--- ../orig/sed-4.9/sed/debug.c	2022-01-02 02:00:07.000000000 +0300
+++ ./sed/debug.c	2022-12-01 17:13:49.519208900 +0300
@@ -154,11 +154,11 @@
 debug_print_subst_replacement (const struct replacement *r)
 {
   enum replacement_types last_repl_type = REPL_ASIS;
+  const struct replacement *p = r;
 
   if (!r)
     return;
 
-  const struct replacement *p = r;
   while (p)
     {
       if (p->repl_type != last_repl_type)
@@ -408,6 +408,7 @@
 void
 debug_print_command (const struct vector *program, const struct sed_cmd *sc)
 {
+  int j;
   bool addr_bang;
   if (!program)
     return;
@@ -415,7 +416,7 @@
   if (sc->cmd == '}')
     --block_level;
 
-  for (int j = 0; j < block_level; ++j)
+  for (j = 0; j < block_level; ++j)
     fputs ("  ", stdout);
 
   debug_print_addr (sc->a1);
@@ -445,12 +446,13 @@
 void
 debug_print_program (const struct vector *program)
 {
+  size_t i;
   if (!program)
     return;
 
   block_level = 1;
   puts ("SED PROGRAM:");
-  for (size_t i = 0; i < program->v_length; ++i)
+  for (i = 0; i < program->v_length; ++i)
     debug_print_command (program, &program->v[i]);
   block_level = 0;
 }
diff -Naur ../orig/sed-4.9/sed/execute.c ./sed/execute.c
--- ../orig/sed-4.9/sed/execute.c	2022-07-03 01:22:03.000000000 +0300
+++ ./sed/execute.c	2022-12-01 17:13:49.524209200 +0300
@@ -37,6 +37,8 @@
 #include "progname.h"
 #include "xalloc.h"
 
+#include "dirname.h"
+
 /* The number of extra bytes that must be allocated/usable, beyond
    the declared "end" of each line buffer that may be passed to
    match_regex.  This is imposed by its use of dfaexec.  */
@@ -575,17 +577,22 @@
   if (in_place_extension)
     {
       int input_fd;
-      char *tmpdir, *p;
+      char *tmpdir;
       char *old_fscreatecon;
       int reset_fscreatecon = 0;
+      size_t in_dir_len;
       memset (&old_fscreatecon, 0, sizeof (old_fscreatecon));
 
       /* get the base name */
-      tmpdir = xstrdup (input->in_file_name);
-      if ((p = strrchr (tmpdir, '/')))
-        *p = 0;
+      in_dir_len = dir_len (input->in_file_name);
+      if (in_dir_len)
+        {
+          tmpdir = xmalloc (in_dir_len + 1);
+          memcpy (tmpdir, input->in_file_name, in_dir_len);
+          tmpdir[in_dir_len] = '\0';
+        }
       else
-        strcpy (tmpdir, ".");
+        tmpdir = xstrdup (".");
 
       if (isatty (fileno (input->fp)))
         panic (_("couldn't edit %s: is a terminal"), input->in_file_name);
@@ -1021,10 +1028,11 @@
 
   if (debug)
     {
+      int i;
       if (regs.num_regs>0 && regs.start[0] != -1)
         puts ("MATCHED REGEX REGISTERS");
 
-      for (int i = 0; i < regs.num_regs; ++i)
+      for (i = 0; i < regs.num_regs; ++i)
         {
           if (regs.start[i] == -1)
             break;
@@ -1204,6 +1212,7 @@
               bool move_remain_buffer = false;
               const char *tr = trans[2*i+1];
               size_t trans_len = *tr == '\0' ? 1 : strlen (tr);
+              size_t prev_idx;
 
               if (mbclen < trans_len)
                 {
@@ -1222,7 +1231,7 @@
                   /* We must truncate the line buffer.  */
                   move_remain_buffer = true;
                 }
-              size_t prev_idx = idx;
+              prev_idx = idx;
               if (move_remain_buffer)
                 {
                   /* Move the remaining with \0.  */
diff -Naur ../orig/sed-4.9/sed/regexp.c ./sed/regexp.c
--- ../orig/sed-4.9/sed/regexp.c	2022-01-02 02:00:07.000000000 +0300
+++ ./sed/regexp.c	2022-12-01 17:13:49.528209400 +0300
@@ -126,10 +126,11 @@
               needed_sub - 1);
       bad_prog (buf);
     }
-
+  {
   int dfaopts = buffer_delimiter == '\n' ? 0 : DFA_EOL_NUL;
   new_regex->dfa = dfaalloc ();
   dfasyntax (new_regex->dfa, &localeinfo, syntax, dfaopts);
+  }
   dfacomp (new_regex->re, new_regex->sz, new_regex->dfa, 1);
 
   /* The patterns which consist of only ^ or $ often appear in
diff -Naur ../orig/sed-4.9/sed/sed.c ./sed/sed.c
--- ../orig/sed-4.9/sed/sed.c	2022-09-15 22:51:33.000000000 +0300
+++ ./sed/sed.c	2022-12-01 17:08:55.515645500 +0300
@@ -67,9 +67,17 @@
 /* How do we edit files in-place? (we don't if NULL) */
 char *in_place_extension = NULL;
 
-/* The mode to use to read/write files, either "r"/"w" or "rb"/"wb".  */
+/* The mode to use to read/write files, either "r(t)"/"w(t)" or "rb"/"wb".  */
+#ifdef HAVE_FOPEN_RT
+char const *read_mode = "rt";
+char const *write_mode = "wt";
+#else
 char const *read_mode = "r";
 char const *write_mode = "w";
+#endif
+
+/* Locale to set at startup.  */
+char const *def_locale = "";
 
 #if O_BINARY
 /* Additional flag for binary mode on platforms with O_BINARY/O_TEXT.  */
@@ -96,6 +104,145 @@
   remove_cleanup_file ();
 }
 
+#if defined _WIN32 && !defined __CYGWIN__
+#define WINDOWS_NATIVE
+#endif
+
+#ifdef WINDOWS_NATIVE
+
+/* Get value of command-line option:
+   --lo[cale]=locale-name or --lo[cale] locale-name,
+   Returns option value or NULL if the option is not specified.
+   Panics if the option specified without a value,
+   else terminates opt_name_array to the length of the option name.  */
+/* Note: before the call, opt_name_array must contain "--locale".  */
+static const wchar_t *
+get_specified_locale (wchar_t **wa, char opt_name_array[])
+{
+  const wchar_t *w = NULL;
+  for (; *wa; wa++)
+    {
+      w = *wa;
+      if (L'-' != w[0] || L'-' != w[1] || L'l' != w[2] || L'o' != w[3])
+        continue;
+      w += 4;
+      if (L'=' == *w || !*w)
+        break;
+      if (L'c' != *w)
+        continue;
+      w++;
+      if (L'=' == *w || !*w)
+        break;
+      if (L'a' != *w)
+        continue;
+      w++;
+      if (L'=' == *w || !*w)
+        break;
+      if (L'l' != *w)
+        continue;
+      w++;
+      if (L'=' == *w || !*w)
+        break;
+      if (L'e' != *w)
+        continue;
+      w++;
+      if (L'=' == *w || !*w)
+        break;
+    }
+
+  if (!*wa)
+    return NULL; /* --lo[cale] option wasn't found.  */
+
+  opt_name_array[(unsigned) (w - *wa)] = '\0';
+  if (*w)
+    return w + 1; /* --lo[cale]=locale-name, return locale-name.  */
+
+  /* --lo[cale] locale-name.  */
+  {
+    const wchar_t *locale_name = wa[1];
+    if (!locale_name)
+      panic (_("option '%s' requires an argument"), opt_name_array);
+    return locale_name;
+  }
+}
+
+/* Set locale based on the values of environment variables.  */
+static void
+set_locale_from_env (const char *def)
+{
+  const char *locale = getenv ("LC_ALL");
+  if (locale && locale[0])
+    {
+      if (!setlocale (LC_ALL, locale))
+        panic (_("Bad locale: LC_ALL=%s"), locale);
+      return;
+    }
+
+  /* LANG is the default for all LC_...  */
+  locale = getenv ("LANG");
+
+  /* if LANG is not defined - set the system default.
+     (If def is "", locale may be be set to
+     e.g. Russian_Russia.1251).  */
+  if (!locale || !locale[0])
+    locale = def;
+
+  if (!setlocale (LC_ALL, locale))
+    panic (_("Bad locale: LANG=%s"), locale);
+
+  /* specific LC_... take precedence over LANG.  */
+  locale = getenv ("LC_CTYPE");
+  if (locale && locale[0])
+    {
+      if (!setlocale (LC_CTYPE, locale))
+        panic (_("Bad locale: LC_CTYPE=%s"), locale);
+    }
+}
+
+/* Convert wide-char args to multibyte.  */
+static char **
+convert_wargv (int argc, wchar_t **wargv)
+{
+  /* Convert program arguments from wide-char to multibyte
+     according to the locale codepage.  */
+  /* Note: argv array must be NULL-terminated.  */
+  char **argv = (char**) xmalloc (sizeof(*argv)*(argc + 1));
+
+  wchar_t **wa = wargv;
+  for (; *wa; wa++)
+    {
+      const size_t need = wcstombs (NULL, *wa, 0);
+
+      if ((size_t) -1 == need)
+        panic (_("failed to convert argument %u (Unicode -> LC_CTYPE=%s): %s"),
+          (unsigned) (wa - wargv), setlocale (LC_CTYPE, NULL),
+          strerror (errno));
+
+      {
+        char *a = (char*) xmalloc (need + 1);
+        wcstombs (a, *wa, need + 1);
+        argv[wa - wargv] = a;
+      }
+    }
+
+  /* argv - is a NULL-terminated array of pointers */
+  argv[wa - wargv] = NULL;
+
+  return argv;
+}
+
+/* Free arguments array allocated by convert_wargv ().  */
+static void
+free_argv (char **argv)
+{
+  char **a = argv;
+  for (; *a; a++)
+    free (*a);
+  free (argv);
+}
+
+#endif /* WINDOWS_NATIVE */
+
 static void
 contact (int errmsg)
 {
@@ -107,6 +254,9 @@
      get reports for other people's bugs.  */
   if (!errmsg)
     fprintf (out, _("E-mail bug reports to: <%s>.\n"), PACKAGE_BUGREPORT);
+
+  if (!errmsg)
+    fprintf (out, _("Patched (v2) by: Michael M. Builov <mbuilov@yandex.ru>.\n"));
 }
 
 static void
@@ -154,6 +304,13 @@
                  open files in binary mode (CR+LFs are not" \
                  " processed specially)\n"));
 #endif
+  fprintf (out, _("  -C, --ignore-locale\n\
+                 ignore system locale, operate in the default \"C\" locale\n"));
+#ifdef WINDOWS_NATIVE
+  fprintf (out, _("  --locale=locale-name\n\
+                 use the specified locale (ignore environment" \
+                 " variables LC_ALL, LC_CTYPE and LANG)\n"));
+#endif
   fprintf (out, _("  -l N, --line-length=N\n\
                  specify the desired line-wrap length for the `l' command\n"));
   fprintf (out, _("  --posix\n\
@@ -186,16 +343,24 @@
 }
 
 int
+#ifndef WINDOWS_NATIVE
 main (int argc, char **argv)
+#else
+wmain (int argc, wchar_t **wargv)
+#endif
 {
-#define SHORTOPTS "bsnrzuEe:f:l:i::V:"
+#define SHORTOPTS "bCsnrzuEe:f:l:i::V:"
 
   enum { SANDBOX_OPTION = CHAR_MAX+1,
          DEBUG_OPTION
+#ifdef WINDOWS_NATIVE
+         ,LOCALE_OPTION
+#endif
     };
 
   static const struct option longopts[] = {
     {"binary", 0, NULL, 'b'},
+    {"ignore-locale", 0, NULL, 'C'},
     {"regexp-extended", 0, NULL, 'r'},
     {"debug", 0, NULL, DEBUG_OPTION},
     {"expression", 1, NULL, 'e'},
@@ -215,6 +380,9 @@
 #ifdef HAVE_READLINK
     {"follow-symlinks", 0, NULL, 'F'},
 #endif
+#ifdef WINDOWS_NATIVE
+    {"locale", 1, NULL, LOCALE_OPTION},
+#endif
     {NULL, 0, NULL, 0}
   };
 
@@ -222,11 +390,68 @@
   int return_code;
   const char *cols = getenv ("COLS");
 
+#ifdef WINDOWS_NATIVE
+  char **old_argv = NULL;
+  char **argv;
+
+  /* Set locale according to user's wishes.
+     (Current locale is "C").  */
+  char opt_name_array[] = "--locale";
+  const wchar_t *spec_locale;
+
+  /* Temporary set program name.
+     This is needed for error messages - in case of bad locale.  */
+  set_program_name ("sed");
+
+  /* Command-line option takes precedence over environment vars.  */
+  spec_locale = get_specified_locale (wargv, opt_name_array);
+  if (!spec_locale)
+    set_locale_from_env (def_locale);
+  else if (!_wsetlocale (LC_ALL, spec_locale))
+    panic (_("Bad locale name specified by the option '%s'"), opt_name_array);
+
+  /* Convert program arguments to multibyte strings.  */
+  argv = convert_wargv (argc, wargv);
+#endif /* WINDOWS_NATIVE */
+
   set_program_name (argv[0]);
   initialize_main (&argc, &argv);
+
+  /* Suppress error reporting in getopt.  */
+  opterr = 0;
+
+  while ((opt = getopt_long (argc, argv, SHORTOPTS, longopts, NULL)) != EOF)
+    {
+      switch (opt)
+        {
+        case 'C':
+          def_locale = "C";
+          break;
+        }
+    }
+
+  /* Restore getopt behaviour.  */
+  opterr = 1;
+  optind = 1;
+
 #if HAVE_SETLOCALE
+#ifndef WINDOWS_NATIVE
   /* Set locale according to user's wishes.  */
-  setlocale (LC_ALL, "");
+  setlocale (LC_ALL, def_locale);
+#else /* WINDOWS_NATIVE */
+  if (def_locale[0])
+    {
+      /* User wants to use "C"-locale.  */
+      if (spec_locale)
+        panic (_("Options '-C/--ignore-locale' and '--locale' cannot be used together."));
+      setlocale (LC_ALL, def_locale);
+
+      /* Cannot free argv array now:
+         argv[0] was passed to set_program_name ().  */
+      old_argv = argv;
+      argv = convert_wargv (argc, wargv);
+    }
+#endif /* WINDOWS_NATIVE */
 #endif
   initialize_mbcs ();
   init_localeinfo (&localeinfo);
@@ -315,6 +540,10 @@
 #endif
           break;
 
+        case 'C':
+          /* already processed */
+          break;
+
         case 'E':
         case 'r':
           extended_regexp_flags = REG_EXTENDED;
@@ -332,6 +561,12 @@
           debug = true;
           break;
 
+#ifdef WINDOWS_NATIVE
+        case LOCALE_OPTION:
+          /* already processed */
+          break;
+#endif
+
         case 'u':
           unbuffered = true;
           break;
@@ -370,6 +605,15 @@
        if (set_binary_mode ( fileno (stdout), O_BINARY) == -1)
          panic (_("failed to set binary mode on STDOUT"));
     }
+  else
+    {
+       /* Under CYGWIN, standard input/output streams are in BINARY
+          mode by default, make sure they are in TEXT mode.  */
+       if (set_binary_mode ( fileno (stdin), O_TEXT) == -1)
+         panic (_("failed to set binary mode on STDIN"));
+       if (set_binary_mode ( fileno (stdout), O_TEXT) == -1)
+         panic (_("failed to set binary mode on STDOUT"));
+    }
 #endif
 
   if (debug)
@@ -380,5 +624,11 @@
   finish_program (the_program);
   ck_fclose (NULL);
 
+#ifdef WINDOWS_NATIVE
+  if (old_argv)
+    free_argv (old_argv);
+  free_argv (argv);
+#endif
+
   return return_code;
 }
diff -Naur ../orig/sed-4.9/sed/utils.c ./sed/utils.c
--- ../orig/sed-4.9/sed/utils.c	2022-09-15 22:51:33.000000000 +0300
+++ ./sed/utils.c	2022-12-01 17:13:49.534209800 +0300
@@ -14,6 +14,12 @@
     You should have received a copy of the GNU General Public License
     along with this program; If not, see <https://www.gnu.org/licenses/>. */
 
+#if defined _WIN32 && !defined __CYGWIN__
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#define WINDOWS_NATIVE
+#endif
+
 #include <config.h>
 
 #include <stdio.h>
@@ -188,14 +194,15 @@
   char *template = xmalloc (strlen (tmpdir) + strlen (base) + 8);
   sprintf (template, "%s/%sXXXXXX", tmpdir, base);
 
+  {
    /* The ownership might change, so omit some permissions at first
       so unauthorized users cannot nip in before the file is ready.
       mkstemp forces O_BINARY on cygwin, so use mkostemp instead.  */
   mode_t save_umask = umask (0077);
   int fd = mkostemp (template, 0);
   int err = errno;
-  umask (save_umask);
   FILE *fp = NULL;
+  umask (save_umask);
 
   if (0 <= fd)
     {
@@ -217,18 +224,530 @@
 
   register_open_file (fp, template);
   return fp;
+  }
+}
+
+#ifdef WINDOWS_NATIVE
+
+/* Convert wide-character string to multibyte.
+   Returns NULL on error, else - malloc'ated '\0'-terminated
+   string, which caller should free via free().  */
+static char *
+convert_wc_to_mb (const wchar_t *wc)
+{
+  const size_t need = wcstombs (NULL, wc, 0);
+
+  if ((size_t) -1 == need)
+    return NULL; /* Error.  errno is set to EILSEQ.  */
+
+  {
+    char *a = (char*) xmalloc (need + 1);
+    wcstombs (a, wc, need + 1);
+    return a;
+  }
+}
+
+/* Called on panic.  */
+static const char *
+get_last_err_msg (unsigned int last_err)
+{
+  /* First try to get message in locale encoding.  */
+  wchar_t *wmsg;
+  DWORD n_chars = FormatMessageW (
+    FORMAT_MESSAGE_ALLOCATE_BUFFER |
+    FORMAT_MESSAGE_FROM_SYSTEM |
+    FORMAT_MESSAGE_IGNORE_INSERTS,
+    NULL, last_err, 0, (LPWSTR) &wmsg, 0, NULL);
+
+  /* trim "\r\n" at end of msg */
+  if (n_chars && L'\n' == wmsg[n_chars - 1])
+    {
+      wmsg[--n_chars] = L'\0';
+      if (n_chars && L'\r' == wmsg[n_chars - 1])
+        wmsg[--n_chars] = L'\0';
+    }
+
+  if (!n_chars)
+    return "";
+
+  {
+    char *msg = convert_wc_to_mb (wmsg);
+    if (msg)
+      {
+        /* Check if failed to translate message to locale code page.  */
+        const char *c = msg;
+        while ('?' == *c || ' ' == *c)
+          c++;
+        if ('.' == *c && !c[1])
+          c++; /* Something like "?????." */
+        if (!*c)
+          {
+            free (msg);
+            msg = NULL;
+          }
+      }
+
+    if (!msg)
+      {
+        /* Just get error message in English.  */
+        n_chars = FormatMessageA (
+          FORMAT_MESSAGE_ALLOCATE_BUFFER |
+          FORMAT_MESSAGE_FROM_SYSTEM |
+          FORMAT_MESSAGE_IGNORE_INSERTS,
+          NULL, last_err,
+          MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
+          (LPSTR) &msg, 0, NULL);
+
+        /* trim "\r\n" at end of msg */
+        if (n_chars && '\n' == msg[n_chars - 1])
+          {
+            msg[--n_chars] = '\0';
+            if (n_chars && '\r' == msg[n_chars - 1])
+              msg[--n_chars] = '\0';
+          }
+
+        if (!n_chars)
+          return "";
+      }
+
+    return msg;
+  }
+}
+
+/* Check if file descriptor fd designates a console.
+   If this is true, then due to bugs in MS UCRT,
+   standard stream i/o functions read(2)/write(2)
+   on the fd may fail, e.g. if the console may print
+   one symbol per multibyte character (for example,
+   if LC_CTYPE=Russian_Russia.1251 and the console
+   code page is 65001).  */
+/* Return INVALID_HANDLE_VALUE if fd do not belongs
+   to a console.  */
+static HANDLE
+get_console_handle (int fd)
+{
+  HANDLE ch;
+  DWORD mode;
+
+  if (!_isatty (fd))
+    return INVALID_HANDLE_VALUE;
+
+  ch = (HANDLE) _get_osfhandle (fd);
+  if (ch != INVALID_HANDLE_VALUE &&
+    GetConsoleMode (ch, &mode))
+    return ch;
+
+  /* Not a console handle.  */
+  return INVALID_HANDLE_VALUE;
+}
+
+/* As a workaround to MS UCRT bugs, call WriteConsoleW
+   directly.  */
+/* Note: fwrite() internally calls WriteFile, which
+   in turn seems like calls WriteConsole expecting
+   that it will return number of bytes written. But
+   WriteConsole returns number of _chars_ written.
+   As result, writing stops after printing only one
+   multibyte character.  */
+/* Returns non-zero on error:
+   - caller should check errno, then GetLastError().  */
+static int
+write_to_console (const void *ptr, size_t size, HANDLE ch)
+{
+  /* Write only full mulitbyte chars, so may need to cache
+     a part of unwritten multibyte char.  */
+  static char remaining_wbuf[MB_LEN_MAX];
+  static unsigned remaining_wbuf_filled = 0;
+
+#ifndef WINDOWS_CONSOLE_WBUF_SIZE
+#define WINDOWS_CONSOLE_WBUF_SIZE 512 /* Must be > 1.  */
+#endif
+  wchar_t tmp[WINDOWS_CONSOLE_WBUF_SIZE];
+  wchar_t *at = tmp;
+  const char *c = (const char*) ptr;
+  const char *const e = c + size;
+  int n;
+
+  if (remaining_wbuf_filled)
+    {
+      unsigned to_copy = sizeof(remaining_wbuf) - remaining_wbuf_filled;
+      if (to_copy > size)
+        to_copy = (unsigned) size;
+      memcpy (&remaining_wbuf[remaining_wbuf_filled], c, to_copy);
+      remaining_wbuf_filled += to_copy;
+
+      n = mbtowc (at, remaining_wbuf, remaining_wbuf_filled);
+      if (n < 0)
+        {
+          if (remaining_wbuf_filled < sizeof(remaining_wbuf))
+            return 0; /* need more bytes of multibyte char for one wide-character */
+
+          /* Cannot convert multibyte to wide-char in current locale.  */
+          errno = EILSEQ;
+          return -1;
+        }
+
+      c += to_copy - (remaining_wbuf_filled - n);
+      remaining_wbuf_filled = 0;
+      at++;
+    }
+
+  for (; c < e; at = tmp)
+    {
+      /* Convert to wide-characters.  */
+      do
+        {
+          const size_t to_convert = (size_t) (e - c);
+          n = mbtowc (at, c, to_convert);
+          if (n < 0)
+            {
+              if (to_convert < sizeof(remaining_wbuf))
+                {
+                  remaining_wbuf_filled = (unsigned) to_convert;
+                  memcpy (remaining_wbuf, c, remaining_wbuf_filled);
+                  c = e;
+                  break; /* need more multibyte chars for one wide-character */
+                }
+
+              /* Cannot convert multibyte to wide-char in current locale.  */
+              errno = EILSEQ;
+              return -1;
+            }
+
+          if (n)
+            c += n;
+          else
+            {
+              *at = L'\0';
+              c++;
+            }
+
+          if (&tmp[sizeof(tmp)/sizeof(tmp[0])] == ++at)
+            break; /* buffer is full */
+        }
+      while (c < e);
+
+      if (at == tmp)
+        break; /* nothing to print */
+
+      /* Write to the console.  */
+      {
+        DWORD NumberOfCharsWritten;
+        if (!WriteConsoleW (ch, tmp, (DWORD) (at - tmp), &NumberOfCharsWritten, NULL))
+          {
+            errno = 0; /* Caller should check GetLastError().  */
+            return -1;
+          }
+      }
+    }
+
+  return 0;
+}
+
+/* Buffer for characters read from the console.
+   Note: ReadConsole() cannot handle big buffers (about 64 Kib).  */
+#ifndef WINDOWS_CONSOLE_RBUF_SIZE
+#ifdef _WIN64
+#define WINDOWS_CONSOLE_RBUF_SIZE 30000 /* Must be non-zero.  */
+#else
+#define WINDOWS_CONSOLE_RBUF_SIZE 15000 /* Must be non-zero.  */
+#endif
+#endif
+static wchar_t console_rbuf[WINDOWS_CONSOLE_RBUF_SIZE];
+static unsigned console_rbuf_offset = 0;
+static unsigned console_rbuf_filled = 0;
+
+/* May read only a part of a multibyte character,
+   so may need to cache remaining part of the character.  */
+static char remaining_rbuf[MB_LEN_MAX];
+static unsigned remaining_rbuf_offset = 0;
+static unsigned remaining_rbuf_filled = 0;
+
+/* Stop console input on Ctrl-Z or Ctrl-D.
+   See https://stackoverflow.com/questions/43836040/win-api-readconsole.  */
+#ifndef WINDOWS_CONSOLE_READ_STOP_CONTROL_MASK
+#define WINDOWS_CONSOLE_READ_STOP_CONTROL_MASK (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED)
+#endif
+#ifndef WINDOWS_CONSOLE_READ_STOP_CHAR1
+#define WINDOWS_CONSOLE_READ_STOP_CHAR1 'z'
+#endif
+#ifndef WINDOWS_CONSOLE_READ_STOP_CHAR2
+#define WINDOWS_CONSOLE_READ_STOP_CHAR2 'd'
+#endif
+#define WINDOWS_CONSOLE_READ_STOP_VALUE1 (WINDOWS_CONSOLE_READ_STOP_CHAR1 - 'a' + 1)
+#define WINDOWS_CONSOLE_READ_STOP_VALUE2 (WINDOWS_CONSOLE_READ_STOP_CHAR2 - 'a' + 1)
+
+static CONSOLE_READCONSOLE_CONTROL console_ctrl = {
+  sizeof(CONSOLE_READCONSOLE_CONTROL), 0,
+  (1u << WINDOWS_CONSOLE_READ_STOP_VALUE1) |
+  (1u << WINDOWS_CONSOLE_READ_STOP_VALUE2), 0
+};
+
+#define is_win_console_stop_input \
+  ((console_rbuf[console_rbuf_offset] == WINDOWS_CONSOLE_READ_STOP_VALUE1 ||  \
+    console_rbuf[console_rbuf_offset] == WINDOWS_CONSOLE_READ_STOP_VALUE2) &&  \
+  (console_ctrl.dwControlKeyState & WINDOWS_CONSOLE_READ_STOP_CONTROL_MASK))
+
+/* Read wide-characters from the console.
+   Returns non-zero on error:
+   - caller should check GetLastError().  */
+static int
+read_from_console_w (HANDLE ch)
+{
+  DWORD NumberOfCharsRead;
+  if (!ReadConsoleW (ch, console_rbuf,
+    sizeof(console_rbuf)/sizeof(console_rbuf[0]), &NumberOfCharsRead, &console_ctrl))
+    {
+      errno = 0; /* Caller should check GetLastError().  */
+      return -1;
+    }
+
+  /* Console is a text stream, so convert CRLF->LF.  */
+  if (NumberOfCharsRead >= 2 &&
+    console_rbuf[NumberOfCharsRead - 2] == L'\r' &&
+    console_rbuf[NumberOfCharsRead - 1] == L'\n')
+    console_rbuf[--NumberOfCharsRead - 1] = L'\n';
+
+  console_rbuf_filled = NumberOfCharsRead;
+  return 0;
+}
+
+/* As a workaround to MS UCRT bugs, call ReadConsoleW
+   directly.  */
+/* Note: fread() internally calls ReadFile, which
+   in turn seems like calls ReadConsole expecting
+   that it will return number of bytes read. But
+   ReadConsole returns number of _chars_ read.
+   As result, reading stops if read just one byte
+   of a multibyte character.  */
+/* Returns number of bytes read, < size on eof/error:
+   - caller should check errno, then GetLastError().  */
+static size_t
+read_from_console (void *ptr, size_t size, HANDLE ch)
+{
+  char *d = (char*) ptr;
+  const char *const e = d + size;
+
+  if (remaining_rbuf_filled)
+    {
+      unsigned to_copy = remaining_rbuf_filled;
+      if (to_copy > size)
+        to_copy = (unsigned) size;
+      d = to_copy + (char*) memcpy (d,
+        &remaining_rbuf[remaining_rbuf_offset], to_copy);
+      remaining_rbuf_filled -= to_copy;
+      if (remaining_rbuf_filled || d == e)
+        {
+          remaining_rbuf_offset += to_copy;
+          return size;
+        }
+    }
+
+  for (;; console_rbuf_offset = 0)
+    {
+      /* Convert wide-characters.  */
+      while (console_rbuf_filled)
+        {
+          int n;
+
+          if (is_win_console_stop_input)
+            goto stop_input;
+
+          n = wctomb (remaining_rbuf, console_rbuf[console_rbuf_offset]);
+          if (n < 0)
+            {
+              /* Cannot convert wide-char to multibyte in current locale.  */
+              errno = EILSEQ;
+              return (size_t) (d - (char*) ptr); /* < size */
+            }
+
+          console_rbuf_filled--;
+          console_rbuf_offset++;
+
+          {
+            unsigned to_copy = n;
+            if (to_copy > (size_t) (e - d))
+              to_copy = (unsigned) (e - d);
+            d = to_copy + (char*) memcpy (d, remaining_rbuf, to_copy);
+            if (d == e)
+              {
+                remaining_rbuf_filled = (unsigned) n - to_copy;
+                remaining_rbuf_offset = to_copy;
+                return (size_t) (d - (char*) ptr); /* == size */
+              }
+          }
+        }
+
+      /* Read from the console.  */
+      if (read_from_console_w (ch))
+        return (size_t) (d - (char*) ptr); /* < size */
+    }
+
+stop_input:
+  /* EOF: no error - both errno and last error are zero.  */
+  errno = 0;
+  SetLastError (0);
+  return (size_t) (d - (char*) ptr); /* < size */
+}
+
+/* As a workaround to MS UCRT bugs, call ReadConsoleW
+   directly.  */
+/* Returns number of bytes read, including delimiter, but
+   not including terminating '\0', returns -1 on eof or error:
+   - caller should check errno, then GetLastError().  */
+static ssize_t
+read_from_console_delim (char **text, size_t *buflen, char buffer_delimiter, HANDLE ch)
+{
+  size_t filled = 0;
+
+  /* Previous ck_fread() should read whole multibyte characters,
+     (possibly by multiple calls).  */
+  if (remaining_rbuf_filled)
+    panic (_("encountered partially read multibyte character"));
+
+  for (;; console_rbuf_offset = 0)
+    {
+      /* Convert wide-characters.  */
+      while (console_rbuf_filled)
+        {
+          char tmp[MB_LEN_MAX];
+          int n;
+
+          if (is_win_console_stop_input)
+            goto stop_input;
+
+          n = wctomb (tmp, console_rbuf[console_rbuf_offset]);
+          if (n < 0)
+            {
+              /* Cannot convert wide-char to multibyte in current locale.  */
+              errno = EILSEQ;
+              return -1;
+            }
+
+          console_rbuf_filled--;
+          console_rbuf_offset++;
+
+          /* One byte is needed for the terminating '\0'.  */
+          if ((unsigned) n + 1 > *buflen - filled)
+            {
+              /* Don't have a space, need to realloc.  */
+#ifndef READ_FROM_CONSOLE_DELIM_REALLOC_SIZE
+#define READ_FROM_CONSOLE_DELIM_REALLOC_SIZE 256 /* Must be > MB_LEN_MAX */
+#endif
+              (void)sizeof(int[1-2*(READ_FROM_CONSOLE_DELIM_REALLOC_SIZE <= MB_LEN_MAX)]);
+              {
+                size_t need = *buflen + READ_FROM_CONSOLE_DELIM_REALLOC_SIZE;
+                void *new_buf = xrealloc (*text, need);
+                *text = (char*) new_buf;
+                *buflen = need;
+              }
+            }
+
+          memcpy (*text + filled, tmp, (unsigned) n);
+          filled += (unsigned) n;
+
+          if ((*text)[filled - 1] == buffer_delimiter)
+            {
+              (*text)[filled] = '\0';
+              return (ssize_t) filled;
+            }
+        }
+
+      /* Read from the console.  */
+      if (read_from_console_w (ch))
+        return -1;
+    }
+
+stop_input:
+  if (filled)
+    {
+      (*text)[filled] = '\0';
+      return (ssize_t) filled;
+    }
+
+  /* EOF: no error - both errno and last error are zero.  */
+  errno = 0;
+  SetLastError (0);
+  return -1;
+}
+
+/* Writing to console failed - panic.
+   First checks errno, then GetLastError().  */
+static void
+write_console_panic (void)
+{
+  if (EILSEQ == errno)
+    panic (_("failed to write to console: cannot to convert character"
+      " (LC_CTYPE=%s -> Unicode): %s"), setlocale (LC_CTYPE, NULL),
+      strerror (errno));
+
+  if (errno)
+    panic (_("failed to write to console: %s"), strerror (errno));
+
+  {
+    const DWORD last_err = GetLastError ();
+    const char *msg = get_last_err_msg (last_err);
+    panic (_("failed to write to console, system error: 0x%x (%s)"),
+      last_err, msg);
+  }
 }
 
+/* Check if reading from console failed.
+   First checks errno, then GetLastError().
+   Panics on error.  */
+static void
+check_read_console_error (void)
+{
+  if (EILSEQ == errno)
+    panic (_("failed to read from console: cannot to convert character"
+      " (Unicode -> LC_CTYPE=%s): %s"), setlocale (LC_CTYPE, NULL),
+      strerror (errno));
+
+  if (errno)
+    panic (_("failed to read from console: %s"), strerror (errno));
+
+  {
+    DWORD last_err = GetLastError ();
+    if (last_err)
+      {
+        const char *msg = get_last_err_msg (last_err);
+        panic (_("failed to read from console, system error: 0x%x (%s)"),
+          last_err, msg);
+      }
+  }
+
+  /* No error.  */
+}
+
+#endif /* WINDOWS_NATIVE */
+
 /* Panic on failing fwrite */
 void
 ck_fwrite (const void *ptr, size_t size, size_t nmemb, FILE *stream)
 {
   clearerr (stream);
-  if (size && fwrite (ptr, size, nmemb, stream) != nmemb)
-    panic (ngettext ("couldn't write %llu item to %s: %s",
-                   "couldn't write %llu items to %s: %s", nmemb),
-          (unsigned long long) nmemb, utils_fp_name (stream),
-          strerror (errno));
+  if (!size || !nmemb)
+    return;
+
+#ifdef WINDOWS_NATIVE
+  {
+    const HANDLE ch = get_console_handle (fileno (stream));
+    if (ch != INVALID_HANDLE_VALUE)
+      {
+        if (write_to_console (ptr, size*nmemb, ch))
+          write_console_panic ();
+        return;
+      }
+  }
+#endif /* WINDOWS_NATIVE */
+
+  if (fwrite (ptr, size, nmemb, stream) == nmemb)
+    return;
+
+  panic (ngettext ("couldn't write %llu item to %s: %s",
+                 "couldn't write %llu items to %s: %s", nmemb),
+        (unsigned long long) nmemb, utils_fp_name (stream),
+        strerror (errno));
 }
 
 /* Panic on failing fread */
@@ -236,7 +755,31 @@
 ck_fread (void *ptr, size_t size, size_t nmemb, FILE *stream)
 {
   clearerr (stream);
-  if (size && (nmemb=fread (ptr, size, nmemb, stream)) <= 0 && ferror (stream))
+  if (!size)
+    return nmemb;
+
+#ifdef WINDOWS_NATIVE
+  {
+    const HANDLE ch = get_console_handle (fileno (stream));
+    if (ch != INVALID_HANDLE_VALUE)
+      {
+        /* Item sizes other than 1 (byte) are not supported.  */
+        if (size != 1)
+          panic (_("ck_fread assert: item size != 1"));
+
+        {
+          const size_t nread = read_from_console (ptr, nmemb, ch);
+
+          if (nread < nmemb)
+            check_read_console_error ();
+
+          return nread;
+        }
+      }
+  }
+#endif /* WINDOWS_NATIVE */
+
+  if ((nmemb=fread (ptr, size, nmemb, stream)) <= 0 && ferror (stream))
     panic (_("read error on %s: %s"), utils_fp_name (stream), strerror (errno));
 
   return nmemb;
@@ -245,12 +788,24 @@
 size_t
 ck_getdelim (char **text, size_t *buflen, char delim, FILE *stream)
 {
-  ssize_t result;
+  ssize_t result = -1; /* Make compiler happy.  */
   bool error;
 
   error = ferror (stream);
   if (!error)
     {
+#ifdef WINDOWS_NATIVE
+      const HANDLE ch = get_console_handle (fileno (stream));
+      if (ch != INVALID_HANDLE_VALUE)
+        {
+          result = read_from_console_delim (text, buflen, delim, ch);
+
+          if (result < 0)
+            check_read_console_error ();
+
+          return result; /* -1 if no line was read (and there is EOF).  */
+        }
+#endif /* WINDOWS_NATIVE */
       result = getdelim (text, buflen, delim, stream);
       error = ferror (stream);
     }
diff -Naur ../orig/sed-4.9/sed/version.c ./sed/version.c
--- ../orig/sed-4.9/sed/version.c	1970-01-01 03:00:00.000000000 +0300
+++ ./sed/version.c	2022-12-01 17:14:11.514128800 +0300
@@ -0,0 +1,2 @@
+#include <config.h>
+char const *Version = "4.9";
diff -Naur ../orig/sed-4.9/sed/version.h ./sed/version.h
--- ../orig/sed-4.9/sed/version.h	1970-01-01 03:00:00.000000000 +0300
+++ ./sed/version.h	2022-12-01 17:14:11.614129000 +0300
@@ -0,0 +1 @@
+extern char const *Version;
diff -Naur ../orig/sed-4.9/stdbool.h ./stdbool.h
--- ../orig/sed-4.9/stdbool.h	1970-01-01 03:00:00.000000000 +0300
+++ ./stdbool.h	2022-12-01 19:00:03.321681700 +0300
@@ -0,0 +1 @@
+
